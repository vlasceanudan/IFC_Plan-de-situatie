/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@thatopen/fragments@3.0.7/dist/index.mjs
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import*as t from"/npm/three@0.176.0/+esm";import{Box3 as e,Vector3 as s,UniformsLib as i,Vector2 as r,ShaderLib as n,UniformsUtils as o,Vector4 as a,Matrix4 as c,Line3 as h,Sphere as l,Plane as d,Ray as b,Mesh as u,MathUtils as f,Triangle as I,BufferGeometry as _,ShaderMaterial as p,InstancedBufferGeometry as E,Float32BufferAttribute as m,InstancedInterleavedBuffer as C,InterleavedBufferAttribute as g,WireframeGeometry as T,BufferAttribute as A,FrontSide as F,BackSide as R,DoubleSide as y}from"/npm/three@0.176.0/+esm";import*as O from"/npm/web-ifc@0.0.68/+esm";var w=Object.defineProperty,S=(t,e,s)=>(((t,e,s)=>{e in t?w(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s})(t,"symbol"!=typeof e?e+"":e,s),s);function N(t,e){const s=Object.getPrototypeOf(t),i=Object.getOwnPropertyNames(s);for(const r of i){if("constructor"===r||"__init"===r)continue;if(r.includes("mutate_"))continue;if(r.match(/.*Array$/))continue;const i=s[r];if("function"==typeof i){const s=void 0!==t[`${r}Length`]&&void 0!==t[`${r}Array`];if(2===i.length||s){const s=t[`${r}Length`](),i=[];e[r]=i;for(let e=0;e<s;e++){const s=t[r](e);if("object"==typeof s&&null!==s&&"bb"in s){const t={};N(s,t),i.push(t)}else i.push(s)}continue}const n=t[r]();if("object"!=typeof n||null===n){e[r]=n;continue}e[r]={},N(n,e[r])}else e[r]=i}}const L={950732822:"IFCURIREFERENCE",4075327185:"IFCTIME",1209108979:"IFCTEMPERATURERATEOFCHANGEMEASURE",3457685358:"IFCSOUNDPRESSURELEVELMEASURE",4157543285:"IFCSOUNDPOWERLEVELMEASURE",2798247006:"IFCPROPERTYSETDEFINITIONSET",1790229001:"IFCPOSITIVEINTEGER",525895558:"IFCNONNEGATIVELENGTHMEASURE",1774176899:"IFCLINEINDEX",1275358634:"IFCLANGUAGEID",2541165894:"IFCDURATION",3701338814:"IFCDAYINWEEKNUMBER",2195413836:"IFCDATETIME",937566702:"IFCDATE",1683019596:"IFCCARDINALPOINTREFERENCE",2314439260:"IFCBINARY",1500781891:"IFCAREADENSITYMEASURE",3683503648:"IFCARCINDEX",4065007721:"IFCYEARNUMBER",1718600412:"IFCWARPINGMOMENTMEASURE",51269191:"IFCWARPINGCONSTANTMEASURE",2593997549:"IFCVOLUMETRICFLOWRATEMEASURE",3458127941:"IFCVOLUMEMEASURE",3345633955:"IFCVAPORPERMEABILITYMEASURE",1278329552:"IFCTORQUEMEASURE",2591213694:"IFCTIMESTAMP",2726807636:"IFCTIMEMEASURE",743184107:"IFCTHERMODYNAMICTEMPERATUREMEASURE",2016195849:"IFCTHERMALTRANSMITTANCEMEASURE",857959152:"IFCTHERMALRESISTANCEMEASURE",2281867870:"IFCTHERMALEXPANSIONCOEFFICIENTMEASURE",2645777649:"IFCTHERMALCONDUCTIVITYMEASURE",232962298:"IFCTHERMALADMITTANCEMEASURE",296282323:"IFCTEXTTRANSFORMATION",603696268:"IFCTEXTFONTNAME",3490877962:"IFCTEXTDECORATION",1460886941:"IFCTEXTALIGNMENT",2801250643:"IFCTEXT",58845555:"IFCTEMPERATUREGRADIENTMEASURE",361837227:"IFCSPECULARROUGHNESS",2757832317:"IFCSPECULAREXPONENT",3477203348:"IFCSPECIFICHEATCAPACITYMEASURE",993287707:"IFCSOUNDPRESSUREMEASURE",846465480:"IFCSOUNDPOWERMEASURE",3471399674:"IFCSOLIDANGLEMEASURE",408310005:"IFCSHEARMODULUSMEASURE",2190458107:"IFCSECTIONALAREAINTEGRALMEASURE",3467162246:"IFCSECTIONMODULUSMEASURE",2766185779:"IFCSECONDINMINUTE",3211557302:"IFCROTATIONALSTIFFNESSMEASURE",1755127002:"IFCROTATIONALMASSMEASURE",2133746277:"IFCROTATIONALFREQUENCYMEASURE",200335297:"IFCREAL",96294661:"IFCRATIOMEASURE",3972513137:"IFCRADIOACTIVITYMEASURE",3665567075:"IFCPRESSUREMEASURE",2169031380:"IFCPRESENTABLETEXT",1364037233:"IFCPOWERMEASURE",1245737093:"IFCPOSITIVERATIOMEASURE",3054510233:"IFCPOSITIVEPLANEANGLEMEASURE",2815919920:"IFCPOSITIVELENGTHMEASURE",4042175685:"IFCPLANEANGLEMEASURE",2642773653:"IFCPLANARFORCEMEASURE",2260317790:"IFCPARAMETERVALUE",929793134:"IFCPHMEASURE",2395907400:"IFCNUMERICMEASURE",2095195183:"IFCNORMALISEDRATIOMEASURE",765770214:"IFCMONTHINYEARNUMBER",2615040989:"IFCMONETARYMEASURE",3114022597:"IFCMOMENTOFINERTIAMEASURE",1648970520:"IFCMOLECULARWEIGHTMEASURE",3177669450:"IFCMOISTUREDIFFUSIVITYMEASURE",1753493141:"IFCMODULUSOFSUBGRADEREACTIONMEASURE",1052454078:"IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE",2173214787:"IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE",3341486342:"IFCMODULUSOFELASTICITYMEASURE",102610177:"IFCMINUTEINHOUR",3531705166:"IFCMASSPERLENGTHMEASURE",3124614049:"IFCMASSMEASURE",4017473158:"IFCMASSFLOWRATEMEASURE",1477762836:"IFCMASSDENSITYMEASURE",2486716878:"IFCMAGNETICFLUXMEASURE",286949696:"IFCMAGNETICFLUXDENSITYMEASURE",151039812:"IFCLUMINOUSINTENSITYMEASURE",2755797622:"IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE",2095003142:"IFCLUMINOUSFLUXMEASURE",503418787:"IFCLOGICAL",3086160713:"IFCLINEARVELOCITYMEASURE",1307019551:"IFCLINEARSTIFFNESSMEASURE",2128979029:"IFCLINEARMOMENTMEASURE",191860431:"IFCLINEARFORCEMEASURE",1243674935:"IFCLENGTHMEASURE",3258342251:"IFCLABEL",2054016361:"IFCKINEMATICVISCOSITYMEASURE",3192672207:"IFCISOTHERMALMOISTURECAPACITYMEASURE",3686016028:"IFCIONCONCENTRATIONMEASURE",3809634241:"IFCINTEGERCOUNTRATEMEASURE",1939436016:"IFCINTEGER",2679005408:"IFCINDUCTANCEMEASURE",3358199106:"IFCILLUMINANCEMEASURE",983778844:"IFCIDENTIFIER",2589826445:"IFCHOURINDAY",1158859006:"IFCHEATINGVALUEMEASURE",3113092358:"IFCHEATFLUXDENSITYMEASURE",3064340077:"IFCGLOBALLYUNIQUEID",3044325142:"IFCFREQUENCYMEASURE",1361398929:"IFCFORCEMEASURE",2590844177:"IFCFONTWEIGHT",2715512545:"IFCFONTVARIANT",1102727119:"IFCFONTSTYLE",2078135608:"IFCENERGYMEASURE",2506197118:"IFCELECTRICVOLTAGEMEASURE",2951915441:"IFCELECTRICRESISTANCEMEASURE",3790457270:"IFCELECTRICCURRENTMEASURE",2093906313:"IFCELECTRICCONDUCTANCEMEASURE",3818826038:"IFCELECTRICCHARGEMEASURE",1827137117:"IFCELECTRICCAPACITANCEMEASURE",69416015:"IFCDYNAMICVISCOSITYMEASURE",524656162:"IFCDOSEEQUIVALENTMEASURE",4134073009:"IFCDIMENSIONCOUNT",1514641115:"IFCDESCRIPTIVEMEASURE",300323983:"IFCDAYLIGHTSAVINGHOUR",86635668:"IFCDAYINMONTHNUMBER",94842927:"IFCCURVATUREMEASURE",1778710042:"IFCCOUNTMEASURE",3238673880:"IFCCONTEXTDEPENDENTMEASURE",3812528620:"IFCCOMPOUNDPLANEANGLEMEASURE",2991860651:"IFCCOMPLEXNUMBER",1867003952:"IFCBOXALIGNMENT",2735952531:"IFCBOOLEAN",2650437152:"IFCAREAMEASURE",632304761:"IFCANGULARVELOCITYMEASURE",360377573:"IFCAMOUNTOFSUBSTANCEMEASURE",4182062534:"IFCACCELERATIONMEASURE",3699917729:"IFCABSORBEDDOSEMEASURE",1971632696:"IFCGEOSLICE",2680139844:"IFCGEOMODEL",24726584:"IFCELECTRICFLOWTREATMENTDEVICE",3693000487:"IFCDISTRIBUTIONBOARD",3460952963:"IFCCONVEYORSEGMENT",3999819293:"IFCCAISSONFOUNDATION",3314249567:"IFCBOREHOLE",4196446775:"IFCBEARING",325726236:"IFCALIGNMENT",3425753595:"IFCTRACKELEMENT",991950508:"IFCSIGNAL",3798194928:"IFCREINFORCEDSOIL",3290496277:"IFCRAIL",1383356374:"IFCPAVEMENT",2182337498:"IFCNAVIGATIONELEMENT",234836483:"IFCMOORINGDEVICE",2078563270:"IFCMOBILETELECOMMUNICATIONSAPPLIANCE",1638804497:"IFCLIQUIDTERMINAL",1154579445:"IFCLINEARPOSITIONINGELEMENT",2696325953:"IFCKERB",2713699986:"IFCGEOTECHNICALASSEMBLY",2142170206:"IFCELECTRICFLOWTREATMENTDEVICETYPE",3376911765:"IFCEARTHWORKSFILL",1077100507:"IFCEARTHWORKSELEMENT",3071239417:"IFCEARTHWORKSCUT",479945903:"IFCDISTRIBUTIONBOARDTYPE",3426335179:"IFCDEEPFOUNDATION",1502416096:"IFCCOURSE",2940368186:"IFCCONVEYORSEGMENTTYPE",3203706013:"IFCCAISSONFOUNDATIONTYPE",3862327254:"IFCBUILTSYSTEM",1876633798:"IFCBUILTELEMENT",963979645:"IFCBRIDGEPART",644574406:"IFCBRIDGE",3649138523:"IFCBEARINGTYPE",1662888072:"IFCALIGNMENTVERTICAL",317615605:"IFCALIGNMENTSEGMENT",1545765605:"IFCALIGNMENTHORIZONTAL",4266260250:"IFCALIGNMENTCANT",3956297820:"IFCVIBRATIONDAMPERTYPE",1530820697:"IFCVIBRATIONDAMPER",840318589:"IFCVEHICLE",1953115116:"IFCTRANSPORTATIONDEVICE",618700268:"IFCTRACKELEMENTTYPE",2281632017:"IFCTENDONCONDUITTYPE",3663046924:"IFCTENDONCONDUIT",42703149:"IFCSINESPIRAL",1894708472:"IFCSIGNALTYPE",3599934289:"IFCSIGNTYPE",33720170:"IFCSIGN",1027922057:"IFCSEVENTHORDERPOLYNOMIALSPIRAL",544395925:"IFCSEGMENTEDREFERENCECURVE",3649235739:"IFCSECONDORDERPOLYNOMIALSPIRAL",550521510:"IFCROADPART",146592293:"IFCROAD",3818125796:"IFCRELADHERESTOELEMENT",4021432810:"IFCREFERENT",1891881377:"IFCRAILWAYPART",3992365140:"IFCRAILWAY",1763565496:"IFCRAILTYPE",1946335990:"IFCPOSITIONINGELEMENT",514975943:"IFCPAVEMENTTYPE",506776471:"IFCNAVIGATIONELEMENTTYPE",710110818:"IFCMOORINGDEVICETYPE",1950438474:"IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE",976884017:"IFCMARINEPART",525669439:"IFCMARINEFACILITY",1770583370:"IFCLIQUIDTERMINALTYPE",2176059722:"IFCLINEARELEMENT",679976338:"IFCKERBTYPE",3948183225:"IFCIMPACTPROTECTIONDEVICETYPE",2568555532:"IFCIMPACTPROTECTIONDEVICE",2898700619:"IFCGRADIENTCURVE",1594536857:"IFCGEOTECHNICALSTRATUM",4230923436:"IFCGEOTECHNICALELEMENT",4228831410:"IFCFACILITYPARTCOMMON",1310830890:"IFCFACILITYPART",24185140:"IFCFACILITY",4234616927:"IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID",1306400036:"IFCDEEPFOUNDATIONTYPE",4189326743:"IFCCOURSETYPE",2000195564:"IFCCOSINESPIRAL",3497074424:"IFCCLOTHOID",1626504194:"IFCBUILTELEMENTTYPE",3651464721:"IFCVEHICLETYPE",1229763772:"IFCTRIANGULATEDIRREGULARNETWORK",3665877780:"IFCTRANSPORTATIONDEVICETYPE",782932809:"IFCTHIRDORDERPOLYNOMIALSPIRAL",2735484536:"IFCSPIRAL",1356537516:"IFCSECTIONEDSURFACE",1290935644:"IFCSECTIONEDSOLIDHORIZONTAL",1862484736:"IFCSECTIONEDSOLID",1441486842:"IFCRELPOSITIONS",1033248425:"IFCRELASSOCIATESPROFILEDEF",3381221214:"IFCPOLYNOMIALCURVE",2485787929:"IFCOFFSETCURVEBYDISTANCES",590820931:"IFCOFFSETCURVE",3465909080:"IFCINDEXEDPOLYGONALTEXTUREMAP",593015953:"IFCDIRECTRIXCURVESWEPTAREASOLID",4212018352:"IFCCURVESEGMENT",3425423356:"IFCAXIS2PLACEMENTLINEAR",823603102:"IFCSEGMENT",2165702409:"IFCPOINTBYDISTANCEEXPRESSION",182550632:"IFCOPENCROSSPROFILEDEF",388784114:"IFCLINEARPLACEMENT",536804194:"IFCALIGNMENTHORIZONTALSEGMENT",3752311538:"IFCALIGNMENTCANTSEGMENT",1010789467:"IFCTEXTURECOORDINATEINDICESWITHVOIDS",222769930:"IFCTEXTURECOORDINATEINDICES",2691318326:"IFCQUANTITYNUMBER",3633395639:"IFCALIGNMENTVERTICALSEGMENT",2879124712:"IFCALIGNMENTPARAMETERSEGMENT",25142252:"IFCCONTROLLER",3087945054:"IFCALARM",4288193352:"IFCACTUATOR",630975310:"IFCUNITARYCONTROLELEMENT",4086658281:"IFCSENSOR",2295281155:"IFCPROTECTIVEDEVICETRIPPINGUNIT",182646315:"IFCFLOWINSTRUMENT",1426591983:"IFCFIRESUPPRESSIONTERMINAL",819412036:"IFCFILTER",3415622556:"IFCFAN",1003880860:"IFCELECTRICTIMECONTROL",402227799:"IFCELECTRICMOTOR",264262732:"IFCELECTRICGENERATOR",3310460725:"IFCELECTRICFLOWSTORAGEDEVICE",862014818:"IFCELECTRICDISTRIBUTIONBOARD",1904799276:"IFCELECTRICAPPLIANCE",1360408905:"IFCDUCTSILENCER",3518393246:"IFCDUCTSEGMENT",342316401:"IFCDUCTFITTING",562808652:"IFCDISTRIBUTIONCIRCUIT",4074379575:"IFCDAMPER",3640358203:"IFCCOOLINGTOWER",4136498852:"IFCCOOLEDBEAM",2272882330:"IFCCONDENSER",3571504051:"IFCCOMPRESSOR",3221913625:"IFCCOMMUNICATIONSAPPLIANCE",639361253:"IFCCOIL",3902619387:"IFCCHILLER",4217484030:"IFCCABLESEGMENT",1051757585:"IFCCABLEFITTING",3758799889:"IFCCABLECARRIERSEGMENT",635142910:"IFCCABLECARRIERFITTING",2938176219:"IFCBURNER",32344328:"IFCBOILER",2906023776:"IFCBEAMSTANDARDCASE",277319702:"IFCAUDIOVISUALAPPLIANCE",2056796094:"IFCAIRTOAIRHEATRECOVERY",177149247:"IFCAIRTERMINALBOX",1634111441:"IFCAIRTERMINAL",486154966:"IFCWINDOWSTANDARDCASE",4237592921:"IFCWASTETERMINAL",4156078855:"IFCWALLELEMENTEDCASE",4207607924:"IFCVALVE",4292641817:"IFCUNITARYEQUIPMENT",3179687236:"IFCUNITARYCONTROLELEMENTTYPE",3026737570:"IFCTUBEBUNDLE",3825984169:"IFCTRANSFORMER",812556717:"IFCTANK",1162798199:"IFCSWITCHINGDEVICE",385403989:"IFCSTRUCTURALLOADCASE",1404847402:"IFCSTACKTERMINAL",1999602285:"IFCSPACEHEATER",3420628829:"IFCSOLARDEVICE",3027962421:"IFCSLABSTANDARDCASE",3127900445:"IFCSLABELEMENTEDCASE",1329646415:"IFCSHADINGDEVICE",3053780830:"IFCSANITARYTERMINAL",2572171363:"IFCREINFORCINGBARTYPE",1232101972:"IFCRATIONALBSPLINECURVEWITHKNOTS",90941305:"IFCPUMP",655969474:"IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",738039164:"IFCPROTECTIVEDEVICE",1156407060:"IFCPLATESTANDARDCASE",3612865200:"IFCPIPESEGMENT",310824031:"IFCPIPEFITTING",3694346114:"IFCOUTLET",144952367:"IFCOUTERBOUNDARYCURVE",2474470126:"IFCMOTORCONNECTION",1911478936:"IFCMEMBERSTANDARDCASE",1437502449:"IFCMEDICALDEVICE",629592764:"IFCLIGHTFIXTURE",76236018:"IFCLAMP",2176052936:"IFCJUNCTIONBOX",4175244083:"IFCINTERCEPTOR",2068733104:"IFCHUMIDIFIER",3319311131:"IFCHEATEXCHANGER",2188021234:"IFCFLOWMETER",1209101575:"IFCEXTERNALSPATIALELEMENT",484807127:"IFCEVAPORATOR",3747195512:"IFCEVAPORATIVECOOLER",2814081492:"IFCENGINE",2417008758:"IFCELECTRICDISTRIBUTIONBOARDTYPE",3242481149:"IFCDOORSTANDARDCASE",3205830791:"IFCDISTRIBUTIONSYSTEM",400855858:"IFCCOMMUNICATIONSAPPLIANCETYPE",905975707:"IFCCOLUMNSTANDARDCASE",1677625105:"IFCCIVILELEMENT",3296154744:"IFCCHIMNEY",2674252688:"IFCCABLEFITTINGTYPE",2188180465:"IFCBURNERTYPE",1177604601:"IFCBUILDINGSYSTEM",39481116:"IFCBUILDINGELEMENTPARTTYPE",1136057603:"IFCBOUNDARYCURVE",2461110595:"IFCBSPLINECURVEWITHKNOTS",1532957894:"IFCAUDIOVISUALAPPLIANCETYPE",4088093105:"IFCWORKCALENDAR",4009809668:"IFCWINDOWTYPE",926996030:"IFCVOIDINGFEATURE",2391383451:"IFCVIBRATIONISOLATOR",2415094496:"IFCTENDONTYPE",3081323446:"IFCTENDONANCHORTYPE",413509423:"IFCSYSTEMFURNITUREELEMENT",3101698114:"IFCSURFACEFEATURE",3657597509:"IFCSTRUCTURALSURFACEACTION",2757150158:"IFCSTRUCTURALCURVEREACTION",1004757350:"IFCSTRUCTURALCURVEACTION",338393293:"IFCSTAIRTYPE",1072016465:"IFCSOLARDEVICETYPE",4074543187:"IFCSHADINGDEVICETYPE",2157484638:"IFCSEAMCURVE",2781568857:"IFCROOFTYPE",2310774935:"IFCREINFORCINGMESHTYPE",964333572:"IFCREINFORCINGELEMENTTYPE",683857671:"IFCRATIONALBSPLINESURFACEWITHKNOTS",1469900589:"IFCRAMPTYPE",2839578677:"IFCPOLYGONALFACESET",1158309216:"IFCPILETYPE",3079942009:"IFCOPENINGSTANDARDCASE",1114901282:"IFCMEDICALDEVICETYPE",3113134337:"IFCINTERSECTIONCURVE",3946677679:"IFCINTERCEPTORTYPE",2571569899:"IFCINDEXEDPOLYCURVE",3493046030:"IFCGEOGRAPHICELEMENT",1509553395:"IFCFURNITURE",1893162501:"IFCFOOTINGTYPE",2853485674:"IFCEXTERNALSPATIALSTRUCTUREELEMENT",4148101412:"IFCEVENT",132023988:"IFCENGINETYPE",2397081782:"IFCELEMENTASSEMBLYTYPE",2323601079:"IFCDOORTYPE",1213902940:"IFCCYLINDRICALSURFACE",1525564444:"IFCCONSTRUCTIONPRODUCTRESOURCETYPE",4105962743:"IFCCONSTRUCTIONMATERIALRESOURCETYPE",2185764099:"IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",15328376:"IFCCOMPOSITECURVEONSURFACE",3875453745:"IFCCOMPLEXPROPERTYTEMPLATE",3893394355:"IFCCIVILELEMENTTYPE",2197970202:"IFCCHIMNEYTYPE",167062518:"IFCBSPLINESURFACEWITHKNOTS",2887950389:"IFCBSPLINESURFACE",2603310189:"IFCADVANCEDBREPWITHVOIDS",1635779807:"IFCADVANCEDBREP",2916149573:"IFCTRIANGULATEDFACESET",1935646853:"IFCTOROIDALSURFACE",2387106220:"IFCTESSELLATEDFACESET",3206491090:"IFCTASKTYPE",699246055:"IFCSURFACECURVE",4095615324:"IFCSUBCONTRACTRESOURCETYPE",603775116:"IFCSTRUCTURALSURFACEREACTION",4015995234:"IFCSPHERICALSURFACE",2481509218:"IFCSPATIALZONETYPE",463610769:"IFCSPATIALZONE",710998568:"IFCSPATIALELEMENTTYPE",1412071761:"IFCSPATIALELEMENT",3663146110:"IFCSIMPLEPROPERTYTEMPLATE",3243963512:"IFCREVOLVEDAREASOLIDTAPERED",816062949:"IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",1521410863:"IFCRELSPACEBOUNDARY2NDLEVEL",3523091289:"IFCRELSPACEBOUNDARY1STLEVEL",427948657:"IFCRELINTERFERESELEMENTS",307848117:"IFCRELDEFINESBYTEMPLATE",1462361463:"IFCRELDEFINESBYOBJECT",2565941209:"IFCRELDECLARES",1027710054:"IFCRELASSIGNSTOGROUPBYFACTOR",3521284610:"IFCPROPERTYTEMPLATE",492091185:"IFCPROPERTYSETTEMPLATE",653396225:"IFCPROJECTLIBRARY",569719735:"IFCPROCEDURETYPE",3967405729:"IFCPREDEFINEDPROPERTYSET",1682466193:"IFCPCURVE",428585644:"IFCLABORRESOURCETYPE",2294589976:"IFCINDEXEDPOLYGONALFACEWITHVOIDS",178912537:"IFCINDEXEDPOLYGONALFACE",4095422895:"IFCGEOGRAPHICELEMENTTYPE",2652556860:"IFCFIXEDREFERENCESWEPTAREASOLID",2804161546:"IFCEXTRUDEDAREASOLIDTAPERED",4024345920:"IFCEVENTTYPE",2629017746:"IFCCURVEBOUNDEDSURFACE",1815067380:"IFCCREWRESOURCETYPE",3419103109:"IFCCONTEXT",2574617495:"IFCCONSTRUCTIONRESOURCETYPE",2059837836:"IFCCARTESIANPOINTLIST3D",1675464909:"IFCCARTESIANPOINTLIST2D",574549367:"IFCCARTESIANPOINTLIST",3406155212:"IFCADVANCEDFACE",3698973494:"IFCTYPERESOURCE",3736923433:"IFCTYPEPROCESS",901063453:"IFCTESSELLATEDITEM",1096409881:"IFCSWEPTDISKSOLIDPOLYGONAL",1042787934:"IFCRESOURCETIME",1608871552:"IFCRESOURCECONSTRAINTRELATIONSHIP",2943643501:"IFCRESOURCEAPPROVALRELATIONSHIP",2090586900:"IFCQUANTITYSET",1482703590:"IFCPROPERTYTEMPLATEDEFINITION",3778827333:"IFCPREDEFINEDPROPERTIES",2998442950:"IFCMIRROREDPROFILEDEF",853536259:"IFCMATERIALRELATIONSHIP",3404854881:"IFCMATERIALPROFILESETUSAGETAPERING",3079605661:"IFCMATERIALPROFILESETUSAGE",2852063980:"IFCMATERIALCONSTITUENTSET",3708119e3:"IFCMATERIALCONSTITUENT",1585845231:"IFCLAGTIME",2133299955:"IFCINDEXEDTRIANGLETEXTUREMAP",1437953363:"IFCINDEXEDTEXTUREMAP",3570813810:"IFCINDEXEDCOLOURMAP",1437805879:"IFCEXTERNALREFERENCERELATIONSHIP",297599258:"IFCEXTENDEDPROPERTIES",211053100:"IFCEVENTTIME",2713554722:"IFCCONVERSIONBASEDUNITWITHOFFSET",3285139300:"IFCCOLOURRGBLIST",1236880293:"IFCWORKTIME",1199560280:"IFCTIMEPERIOD",3611470254:"IFCTEXTUREVERTEXLIST",2771591690:"IFCTASKTIMERECURRING",1549132990:"IFCTASKTIME",2043862942:"IFCTABLECOLUMN",2934153892:"IFCSURFACEREINFORCEMENTAREA",609421318:"IFCSTRUCTURALLOADORRESULT",3478079324:"IFCSTRUCTURALLOADCONFIGURATION",1054537805:"IFCSCHEDULINGTIME",2439245199:"IFCRESOURCELEVELRELATIONSHIP",2433181523:"IFCREFERENCE",3915482550:"IFCRECURRENCEPATTERN",986844984:"IFCPROPERTYABSTRACTION",3843373140:"IFCPROJECTEDCRS",677532197:"IFCPRESENTATIONITEM",1507914824:"IFCMATERIALUSAGEDEFINITION",552965576:"IFCMATERIALPROFILEWITHOFFSETS",164193824:"IFCMATERIALPROFILESET",2235152071:"IFCMATERIALPROFILE",1847252529:"IFCMATERIALLAYERWITHOFFSETS",760658860:"IFCMATERIALDEFINITION",3057273783:"IFCMAPCONVERSION",4294318154:"IFCEXTERNALINFORMATION",1466758467:"IFCCOORDINATEREFERENCESYSTEM",1785450214:"IFCCOORDINATEOPERATION",775493141:"IFCCONNECTIONVOLUMEGEOMETRY",979691226:"IFCREINFORCINGBAR",3700593921:"IFCELECTRICDISTRIBUTIONPOINT",1062813311:"IFCDISTRIBUTIONCONTROLELEMENT",1052013943:"IFCDISTRIBUTIONCHAMBERELEMENT",578613899:"IFCCONTROLLERTYPE",2454782716:"IFCCHAMFEREDGEFEATURE",753842376:"IFCBEAM",3001207471:"IFCALARMTYPE",2874132201:"IFCACTUATORTYPE",3304561284:"IFCWINDOW",3512223829:"IFCWALLSTANDARDCASE",2391406946:"IFCWALL",3313531582:"IFCVIBRATIONISOLATORTYPE",2347447852:"IFCTENDONANCHOR",3824725483:"IFCTENDON",2515109513:"IFCSTRUCTURALANALYSISMODEL",4252922144:"IFCSTAIRFLIGHT",331165859:"IFCSTAIR",1529196076:"IFCSLAB",1783015770:"IFCSENSORTYPE",1376911519:"IFCROUNDEDEDGEFEATURE",2016517767:"IFCROOF",2320036040:"IFCREINFORCINGMESH",3027567501:"IFCREINFORCINGELEMENT",3055160366:"IFCRATIONALBEZIERCURVE",3283111854:"IFCRAMPFLIGHT",3024970846:"IFCRAMP",2262370178:"IFCRAILING",3171933400:"IFCPLATE",1687234759:"IFCPILE",1073191201:"IFCMEMBER",900683007:"IFCFOOTING",3508470533:"IFCFLOWTREATMENTDEVICE",2223149337:"IFCFLOWTERMINAL",707683696:"IFCFLOWSTORAGEDEVICE",987401354:"IFCFLOWSEGMENT",3132237377:"IFCFLOWMOVINGDEVICE",4037862832:"IFCFLOWINSTRUMENTTYPE",4278956645:"IFCFLOWFITTING",2058353004:"IFCFLOWCONTROLLER",4222183408:"IFCFIRESUPPRESSIONTERMINALTYPE",1810631287:"IFCFILTERTYPE",346874300:"IFCFANTYPE",1658829314:"IFCENERGYCONVERSIONDEVICE",857184966:"IFCELECTRICALELEMENT",1634875225:"IFCELECTRICALCIRCUIT",712377611:"IFCELECTRICTIMECONTROLTYPE",1217240411:"IFCELECTRICMOTORTYPE",1365060375:"IFCELECTRICHEATERTYPE",1534661035:"IFCELECTRICGENERATORTYPE",3277789161:"IFCELECTRICFLOWSTORAGEDEVICETYPE",663422040:"IFCELECTRICAPPLIANCETYPE",855621170:"IFCEDGEFEATURE",2030761528:"IFCDUCTSILENCERTYPE",3760055223:"IFCDUCTSEGMENTTYPE",869906466:"IFCDUCTFITTINGTYPE",395920057:"IFCDOOR",3041715199:"IFCDISTRIBUTIONPORT",3040386961:"IFCDISTRIBUTIONFLOWELEMENT",1945004755:"IFCDISTRIBUTIONELEMENT",2063403501:"IFCDISTRIBUTIONCONTROLELEMENTTYPE",1599208980:"IFCDISTRIBUTIONCHAMBERELEMENTTYPE",2635815018:"IFCDISCRETEACCESSORYTYPE",1335981549:"IFCDISCRETEACCESSORY",4147604152:"IFCDIAMETERDIMENSION",3961806047:"IFCDAMPERTYPE",3495092785:"IFCCURTAINWALL",1973544240:"IFCCOVERING",2954562838:"IFCCOOLINGTOWERTYPE",335055490:"IFCCOOLEDBEAMTYPE",488727124:"IFCCONSTRUCTIONPRODUCTRESOURCE",1060000209:"IFCCONSTRUCTIONMATERIALRESOURCE",3898045240:"IFCCONSTRUCTIONEQUIPMENTRESOURCE",1163958913:"IFCCONDITIONCRITERION",2188551683:"IFCCONDITION",2816379211:"IFCCONDENSERTYPE",3850581409:"IFCCOMPRESSORTYPE",843113511:"IFCCOLUMN",2301859152:"IFCCOILTYPE",2611217952:"IFCCIRCLE",2951183804:"IFCCHILLERTYPE",1285652485:"IFCCABLESEGMENTTYPE",3293546465:"IFCCABLECARRIERSEGMENTTYPE",395041908:"IFCCABLECARRIERFITTINGTYPE",1909888760:"IFCBUILDINGELEMENTPROXYTYPE",1095909175:"IFCBUILDINGELEMENTPROXY",2979338954:"IFCBUILDINGELEMENTPART",52481810:"IFCBUILDINGELEMENTCOMPONENT",3299480353:"IFCBUILDINGELEMENT",231477066:"IFCBOILERTYPE",1916977116:"IFCBEZIERCURVE",819618141:"IFCBEAMTYPE",1967976161:"IFCBSPLINECURVE",3460190687:"IFCASSET",2470393545:"IFCANGULARDIMENSION",1871374353:"IFCAIRTOAIRHEATRECOVERYTYPE",3352864051:"IFCAIRTERMINALTYPE",1411407467:"IFCAIRTERMINALBOXTYPE",3821786052:"IFCACTIONREQUEST",1213861670:"IFC2DCOMPOSITECURVE",1033361043:"IFCZONE",3342526732:"IFCWORKSCHEDULE",4218914973:"IFCWORKPLAN",1028945134:"IFCWORKCONTROL",1133259667:"IFCWASTETERMINALTYPE",1898987631:"IFCWALLTYPE",2769231204:"IFCVIRTUALELEMENT",728799441:"IFCVALVETYPE",1911125066:"IFCUNITARYEQUIPMENTTYPE",1600972822:"IFCTUBEBUNDLETYPE",3593883385:"IFCTRIMMEDCURVE",1620046519:"IFCTRANSPORTELEMENT",1692211062:"IFCTRANSFORMERTYPE",1637806684:"IFCTIMESERIESSCHEDULE",5716631:"IFCTANKTYPE",2254336722:"IFCSYSTEM",2315554128:"IFCSWITCHINGDEVICETYPE",148013059:"IFCSUBCONTRACTRESOURCE",1975003073:"IFCSTRUCTURALSURFACECONNECTION",2986769608:"IFCSTRUCTURALRESULTGROUP",1235345126:"IFCSTRUCTURALPOINTREACTION",734778138:"IFCSTRUCTURALPOINTCONNECTION",2082059205:"IFCSTRUCTURALPOINTACTION",3987759626:"IFCSTRUCTURALPLANARACTIONVARYING",1621171031:"IFCSTRUCTURALPLANARACTION",1252848954:"IFCSTRUCTURALLOADGROUP",1721250024:"IFCSTRUCTURALLINEARACTIONVARYING",1807405624:"IFCSTRUCTURALLINEARACTION",2445595289:"IFCSTRUCTURALCURVEMEMBERVARYING",214636428:"IFCSTRUCTURALCURVEMEMBER",4243806635:"IFCSTRUCTURALCURVECONNECTION",1179482911:"IFCSTRUCTURALCONNECTION",682877961:"IFCSTRUCTURALACTION",1039846685:"IFCSTAIRFLIGHTTYPE",3112655638:"IFCSTACKTERMINALTYPE",3812236995:"IFCSPACETYPE",652456506:"IFCSPACEPROGRAM",1305183839:"IFCSPACEHEATERTYPE",3856911033:"IFCSPACE",2533589738:"IFCSLABTYPE",4097777520:"IFCSITE",4105383287:"IFCSERVICELIFE",3517283431:"IFCSCHEDULETIMECONTROL",1768891740:"IFCSANITARYTERMINALTYPE",2863920197:"IFCRELASSIGNSTASKS",160246688:"IFCRELAGGREGATES",2324767716:"IFCRAMPFLIGHTTYPE",2893384427:"IFCRAILINGTYPE",3248260540:"IFCRADIUSDIMENSION",2250791053:"IFCPUMPTYPE",1842657554:"IFCPROTECTIVEDEVICETYPE",3651124850:"IFCPROJECTIONELEMENT",3642467123:"IFCPROJECTORDERRECORD",2904328755:"IFCPROJECTORDER",2744685151:"IFCPROCEDURE",3740093272:"IFCPORT",3724593414:"IFCPOLYLINE",4017108033:"IFCPLATETYPE",4231323485:"IFCPIPESEGMENTTYPE",804291784:"IFCPIPEFITTINGTYPE",3327091369:"IFCPERMIT",2382730787:"IFCPERFORMANCEHISTORY",2837617999:"IFCOUTLETTYPE",3425660407:"IFCORDERACTION",3588315303:"IFCOPENINGELEMENT",4143007308:"IFCOCCUPANT",1916936684:"IFCMOVE",977012517:"IFCMOTORCONNECTIONTYPE",3181161470:"IFCMEMBERTYPE",2108223431:"IFCMECHANICALFASTENERTYPE",377706215:"IFCMECHANICALFASTENER",2506943328:"IFCLINEARDIMENSION",1161773419:"IFCLIGHTFIXTURETYPE",1051575348:"IFCLAMPTYPE",3827777499:"IFCLABORRESOURCE",4288270099:"IFCJUNCTIONBOXTYPE",2391368822:"IFCINVENTORY",1806887404:"IFCHUMIDIFIERTYPE",1251058090:"IFCHEATEXCHANGERTYPE",2706460486:"IFCGROUP",3009204131:"IFCGRID",200128114:"IFCGASTERMINALTYPE",814719939:"IFCFURNITURESTANDARD",263784265:"IFCFURNISHINGELEMENT",3009222698:"IFCFLOWTREATMENTDEVICETYPE",2297155007:"IFCFLOWTERMINALTYPE",1339347760:"IFCFLOWSTORAGEDEVICETYPE",1834744321:"IFCFLOWSEGMENTTYPE",1482959167:"IFCFLOWMOVINGDEVICETYPE",3815607619:"IFCFLOWMETERTYPE",3198132628:"IFCFLOWFITTINGTYPE",3907093117:"IFCFLOWCONTROLLERTYPE",1287392070:"IFCFEATUREELEMENTSUBTRACTION",2143335405:"IFCFEATUREELEMENTADDITION",2827207264:"IFCFEATUREELEMENT",2489546625:"IFCFASTENERTYPE",647756555:"IFCFASTENER",3737207727:"IFCFACETEDBREPWITHVOIDS",807026263:"IFCFACETEDBREP",3390157468:"IFCEVAPORATORTYPE",3174744832:"IFCEVAPORATIVECOOLERTYPE",3272907226:"IFCEQUIPMENTSTANDARD",1962604670:"IFCEQUIPMENTELEMENT",2107101300:"IFCENERGYCONVERSIONDEVICETYPE",1704287377:"IFCELLIPSE",2590856083:"IFCELEMENTCOMPONENTTYPE",1623761950:"IFCELEMENTCOMPONENT",4123344466:"IFCELEMENTASSEMBLY",1758889154:"IFCELEMENT",360485395:"IFCELECTRICALBASEPROPERTIES",3849074793:"IFCDISTRIBUTIONFLOWELEMENTTYPE",3256556792:"IFCDISTRIBUTIONELEMENTTYPE",681481545:"IFCDIMENSIONCURVEDIRECTEDCALLOUT",1457835157:"IFCCURTAINWALLTYPE",3295246426:"IFCCREWRESOURCE",1916426348:"IFCCOVERINGTYPE",1419761937:"IFCCOSTSCHEDULE",3895139033:"IFCCOSTITEM",3293443760:"IFCCONTROL",2559216714:"IFCCONSTRUCTIONRESOURCE",2510884976:"IFCCONIC",3732776249:"IFCCOMPOSITECURVE",300633059:"IFCCOLUMNTYPE",2937912522:"IFCCIRCLEHOLLOWPROFILEDEF",3124254112:"IFCBUILDINGSTOREY",1950629157:"IFCBUILDINGELEMENTTYPE",4031249490:"IFCBUILDING",1260505505:"IFCBOUNDEDCURVE",3649129432:"IFCBOOLEANCLIPPINGRESULT",1334484129:"IFCBLOCK",3207858831:"IFCASYMMETRICISHAPEPROFILEDEF",1674181508:"IFCANNOTATION",2296667514:"IFCACTOR",2097647324:"IFCTRANSPORTELEMENTTYPE",3473067441:"IFCTASK",1580310250:"IFCSYSTEMFURNITUREELEMENTTYPE",4124788165:"IFCSURFACEOFREVOLUTION",2809605785:"IFCSURFACEOFLINEAREXTRUSION",2028607225:"IFCSURFACECURVESWEPTAREASOLID",4070609034:"IFCSTRUCTUREDDIMENSIONCALLOUT",2218152070:"IFCSTRUCTURALSURFACEMEMBERVARYING",3979015343:"IFCSTRUCTURALSURFACEMEMBER",3689010777:"IFCSTRUCTURALREACTION",530289379:"IFCSTRUCTURALMEMBER",3136571912:"IFCSTRUCTURALITEM",3544373492:"IFCSTRUCTURALACTIVITY",451544542:"IFCSPHERE",3893378262:"IFCSPATIALSTRUCTUREELEMENTTYPE",2706606064:"IFCSPATIALSTRUCTUREELEMENT",3626867408:"IFCRIGHTCIRCULARCYLINDER",4158566097:"IFCRIGHTCIRCULARCONE",1856042241:"IFCREVOLVEDAREASOLID",2914609552:"IFCRESOURCE",1401173127:"IFCRELVOIDSELEMENT",3451746338:"IFCRELSPACEBOUNDARY",366585022:"IFCRELSERVICESBUILDINGS",4122056220:"IFCRELSEQUENCE",1058617721:"IFCRELSCHEDULESCOSTITEMS",1245217292:"IFCRELREFERENCEDINSPATIALSTRUCTURE",750771296:"IFCRELPROJECTSELEMENT",202636808:"IFCRELOVERRIDESPROPERTIES",2051452291:"IFCRELOCCUPIESSPACES",3268803585:"IFCRELNESTS",4189434867:"IFCRELINTERACTIONREQUIREMENTS",279856033:"IFCRELFLOWCONTROLELEMENTS",3940055652:"IFCRELFILLSELEMENT",781010003:"IFCRELDEFINESBYTYPE",4186316022:"IFCRELDEFINESBYPROPERTIES",693640335:"IFCRELDEFINES",2551354335:"IFCRELDECOMPOSES",2802773753:"IFCRELCOVERSSPACES",886880790:"IFCRELCOVERSBLDGELEMENTS",3242617779:"IFCRELCONTAINEDINSPATIALSTRUCTURE",3678494232:"IFCRELCONNECTSWITHREALIZINGELEMENTS",504942748:"IFCRELCONNECTSWITHECCENTRICITY",1638771189:"IFCRELCONNECTSSTRUCTURALMEMBER",3912681535:"IFCRELCONNECTSSTRUCTURALELEMENT",2127690289:"IFCRELCONNECTSSTRUCTURALACTIVITY",3190031847:"IFCRELCONNECTSPORTS",4201705270:"IFCRELCONNECTSPORTTOELEMENT",3945020480:"IFCRELCONNECTSPATHELEMENTS",1204542856:"IFCRELCONNECTSELEMENTS",826625072:"IFCRELCONNECTS",2851387026:"IFCRELASSOCIATESPROFILEPROPERTIES",2655215786:"IFCRELASSOCIATESMATERIAL",3840914261:"IFCRELASSOCIATESLIBRARY",982818633:"IFCRELASSOCIATESDOCUMENT",2728634034:"IFCRELASSOCIATESCONSTRAINT",919958153:"IFCRELASSOCIATESCLASSIFICATION",4095574036:"IFCRELASSOCIATESAPPROVAL",1327628568:"IFCRELASSOCIATESAPPLIEDVALUE",1865459582:"IFCRELASSOCIATES",205026976:"IFCRELASSIGNSTORESOURCE",3372526763:"IFCRELASSIGNSTOPROJECTORDER",2857406711:"IFCRELASSIGNSTOPRODUCT",4278684876:"IFCRELASSIGNSTOPROCESS",1307041759:"IFCRELASSIGNSTOGROUP",2495723537:"IFCRELASSIGNSTOCONTROL",1683148259:"IFCRELASSIGNSTOACTOR",3939117080:"IFCRELASSIGNS",3454111270:"IFCRECTANGULARTRIMMEDSURFACE",2798486643:"IFCRECTANGULARPYRAMID",2770003689:"IFCRECTANGLEHOLLOWPROFILEDEF",3219374653:"IFCPROXY",1451395588:"IFCPROPERTYSET",4194566429:"IFCPROJECTIONCURVE",103090709:"IFCPROJECT",4208778838:"IFCPRODUCT",2945172077:"IFCPROCESS",220341763:"IFCPLANE",603570806:"IFCPLANARBOX",3566463478:"IFCPERMEABLECOVERINGPROPERTIES",3505215534:"IFCOFFSETCURVE3D",3388369263:"IFCOFFSETCURVE2D",3888040117:"IFCOBJECT",1425443689:"IFCMANIFOLDSOLIDBREP",1281925730:"IFCLINE",572779678:"IFCLSHAPEPROFILEDEF",1484403080:"IFCISHAPEPROFILEDEF",987898635:"IFCGEOMETRICCURVESET",1268542332:"IFCFURNITURETYPE",4238390223:"IFCFURNISHINGELEMENTTYPE",3455213021:"IFCFLUIDFLOWPROPERTIES",315944413:"IFCFILLAREASTYLETILES",4203026998:"IFCFILLAREASTYLETILESYMBOLWITHSTYLE",374418227:"IFCFILLAREASTYLEHATCHING",2047409740:"IFCFACEBASEDSURFACEMODEL",477187591:"IFCEXTRUDEDAREASOLID",80994333:"IFCENERGYPROPERTIES",2835456948:"IFCELLIPSEPROFILEDEF",2777663545:"IFCELEMENTARYSURFACE",339256511:"IFCELEMENTTYPE",1883228015:"IFCELEMENTQUANTITY",1472233963:"IFCEDGELOOP",4006246654:"IFCDRAUGHTINGPREDEFINEDCURVEFONT",445594917:"IFCDRAUGHTINGPREDEFINEDCOLOUR",3073041342:"IFCDRAUGHTINGCALLOUT",526551008:"IFCDOORSTYLE",1714330368:"IFCDOORPANELPROPERTIES",2963535650:"IFCDOORLININGPROPERTIES",32440307:"IFCDIRECTION",4054601972:"IFCDIMENSIONCURVETERMINATOR",606661476:"IFCDIMENSIONCURVE",693772133:"IFCDEFINEDSYMBOL",2827736869:"IFCCURVEBOUNDEDPLANE",2601014836:"IFCCURVE",2147822146:"IFCCSGSOLID",2506170314:"IFCCSGPRIMITIVE3D",194851669:"IFCCRANERAILFSHAPEPROFILEDEF",4133800736:"IFCCRANERAILASHAPEPROFILEDEF",2485617015:"IFCCOMPOSITECURVESEGMENT",2205249479:"IFCCLOSEDSHELL",1383045692:"IFCCIRCLEPROFILEDEF",1416205885:"IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",3331915920:"IFCCARTESIANTRANSFORMATIONOPERATOR3D",3486308946:"IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",3749851601:"IFCCARTESIANTRANSFORMATIONOPERATOR2D",59481748:"IFCCARTESIANTRANSFORMATIONOPERATOR",1123145078:"IFCCARTESIANPOINT",2898889636:"IFCCSHAPEPROFILEDEF",2713105998:"IFCBOXEDHALFSPACE",2581212453:"IFCBOUNDINGBOX",4182860854:"IFCBOUNDEDSURFACE",2736907675:"IFCBOOLEANRESULT",2740243338:"IFCAXIS2PLACEMENT3D",3125803723:"IFCAXIS2PLACEMENT2D",4261334040:"IFCAXIS1PLACEMENT",1302238472:"IFCANNOTATIONSURFACE",2265737646:"IFCANNOTATIONFILLAREAOCCURRENCE",669184980:"IFCANNOTATIONFILLAREA",3288037868:"IFCANNOTATIONCURVEOCCURRENCE",2543172580:"IFCZSHAPEPROFILEDEF",1299126871:"IFCWINDOWSTYLE",512836454:"IFCWINDOWPANELPROPERTIES",336235671:"IFCWINDOWLININGPROPERTIES",2759199220:"IFCVERTEXLOOP",1417489154:"IFCVECTOR",427810014:"IFCUSHAPEPROFILEDEF",2347495698:"IFCTYPEPRODUCT",1628702193:"IFCTYPEOBJECT",1345879162:"IFCTWODIRECTIONREPEATFACTOR",2715220739:"IFCTRAPEZIUMPROFILEDEF",3124975700:"IFCTEXTLITERALWITHEXTENT",4282788508:"IFCTEXTLITERAL",3028897424:"IFCTERMINATORSYMBOL",3071757647:"IFCTSHAPEPROFILEDEF",230924584:"IFCSWEPTSURFACE",1260650574:"IFCSWEPTDISKSOLID",2247615214:"IFCSWEPTAREASOLID",1878645084:"IFCSURFACESTYLERENDERING",2513912981:"IFCSURFACE",2233826070:"IFCSUBEDGE",3653947884:"IFCSTRUCTURALSTEELPROFILEPROPERTIES",3843319758:"IFCSTRUCTURALPROFILEPROPERTIES",1190533807:"IFCSTRUCTURALLOADSINGLEFORCEWARPING",1597423693:"IFCSTRUCTURALLOADSINGLEFORCE",1973038258:"IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",2473145415:"IFCSTRUCTURALLOADSINGLEDISPLACEMENT",2668620305:"IFCSTRUCTURALLOADPLANARFORCE",1595516126:"IFCSTRUCTURALLOADLINEARFORCE",390701378:"IFCSPACETHERMALLOADPROPERTIES",1202362311:"IFCSOUNDVALUE",2485662743:"IFCSOUNDPROPERTIES",723233188:"IFCSOLIDMODEL",2609359061:"IFCSLIPPAGECONNECTIONCONDITION",4124623270:"IFCSHELLBASEDSURFACEMODEL",2411513650:"IFCSERVICELIFEFACTOR",1509187699:"IFCSECTIONEDSPINE",2778083089:"IFCROUNDEDRECTANGLEPROFILEDEF",478536968:"IFCRELATIONSHIP",3765753017:"IFCREINFORCEMENTDEFINITIONPROPERTIES",3413951693:"IFCREGULARTIMESERIES",3615266464:"IFCRECTANGLEPROFILEDEF",110355661:"IFCPROPERTYTABLEVALUE",3650150729:"IFCPROPERTYSINGLEVALUE",3357820518:"IFCPROPERTYSETDEFINITION",941946838:"IFCPROPERTYREFERENCEVALUE",2752243245:"IFCPROPERTYLISTVALUE",4166981789:"IFCPROPERTYENUMERATEDVALUE",1680319473:"IFCPROPERTYDEFINITION",871118103:"IFCPROPERTYBOUNDEDVALUE",673634403:"IFCPRODUCTDEFINITIONSHAPE",179317114:"IFCPREDEFINEDPOINTMARKERSYMBOL",433424934:"IFCPREDEFINEDDIMENSIONSYMBOL",2559016684:"IFCPREDEFINEDCURVEFONT",759155922:"IFCPREDEFINEDCOLOUR",2775532180:"IFCPOLYGONALBOUNDEDHALFSPACE",2924175390:"IFCPOLYLOOP",1423911732:"IFCPOINTONSURFACE",4022376103:"IFCPOINTONCURVE",2067069095:"IFCPOINT",1663979128:"IFCPLANAREXTENT",2004835150:"IFCPLACEMENT",597895409:"IFCPIXELTEXTURE",3021840470:"IFCPHYSICALCOMPLEXQUANTITY",2519244187:"IFCPATH",2529465313:"IFCPARAMETERIZEDPROFILEDEF",1029017970:"IFCORIENTEDEDGE",2665983363:"IFCOPENSHELL",2833995503:"IFCONEDIRECTIONREPEATFACTOR",219451334:"IFCOBJECTDEFINITION",1430189142:"IFCMECHANICALCONCRETEMATERIALPROPERTIES",2022407955:"IFCMATERIALDEFINITIONREPRESENTATION",2347385850:"IFCMAPPEDITEM",1008929658:"IFCLOOP",2624227202:"IFCLOCALPLACEMENT",3422422726:"IFCLIGHTSOURCESPOT",1520743889:"IFCLIGHTSOURCEPOSITIONAL",4266656042:"IFCLIGHTSOURCEGONIOMETRIC",2604431987:"IFCLIGHTSOURCEDIRECTIONAL",125510826:"IFCLIGHTSOURCEAMBIENT",1402838566:"IFCLIGHTSOURCE",3741457305:"IFCIRREGULARTIMESERIES",3905492369:"IFCIMAGETEXTURE",2445078500:"IFCHYGROSCOPICMATERIALPROPERTIES",812098782:"IFCHALFSPACESOLID",178086475:"IFCGRIDPLACEMENT",3590301190:"IFCGEOMETRICSET",4142052618:"IFCGEOMETRICREPRESENTATIONSUBCONTEXT",2453401579:"IFCGEOMETRICREPRESENTATIONITEM",3448662350:"IFCGEOMETRICREPRESENTATIONCONTEXT",1446786286:"IFCGENERALPROFILEPROPERTIES",803998398:"IFCGENERALMATERIALPROPERTIES",3857492461:"IFCFUELPROPERTIES",738692330:"IFCFILLAREASTYLE",4219587988:"IFCFAILURECONNECTIONCONDITION",3008276851:"IFCFACESURFACE",803316827:"IFCFACEOUTERBOUND",1809719519:"IFCFACEBOUND",2556980723:"IFCFACE",1860660968:"IFCEXTENDEDMATERIALPROPERTIES",476780140:"IFCEDGECURVE",3900360178:"IFCEDGE",4170525392:"IFCDRAUGHTINGPREDEFINEDTEXTFONT",3732053477:"IFCDOCUMENTREFERENCE",1694125774:"IFCDIMENSIONPAIR",2273265877:"IFCDIMENSIONCALLOUTRELATIONSHIP",3632507154:"IFCDERIVEDPROFILEDEF",3800577675:"IFCCURVESTYLE",2889183280:"IFCCONVERSIONBASEDUNIT",3050246964:"IFCCONTEXTDEPENDENTUNIT",45288368:"IFCCONNECTIONPOINTECCENTRICITY",1981873012:"IFCCONNECTIONCURVEGEOMETRY",370225590:"IFCCONNECTEDFACESET",1485152156:"IFCCOMPOSITEPROFILEDEF",2542286263:"IFCCOMPLEXPROPERTY",776857604:"IFCCOLOURRGB",647927063:"IFCCLASSIFICATIONREFERENCE",3150382593:"IFCCENTERLINEPROFILEDEF",616511568:"IFCBLOBTEXTURE",2705031697:"IFCARBITRARYPROFILEDEFWITHVOIDS",1310608509:"IFCARBITRARYOPENPROFILEDEF",3798115385:"IFCARBITRARYCLOSEDPROFILEDEF",2297822566:"IFCANNOTATIONTEXTOCCURRENCE",3612888222:"IFCANNOTATIONSYMBOLOCCURRENCE",962685235:"IFCANNOTATIONSURFACEOCCURRENCE",2442683028:"IFCANNOTATIONOCCURRENCE",1065908215:"IFCWATERPROPERTIES",891718957:"IFCVIRTUALGRIDINTERSECTION",1907098498:"IFCVERTEXPOINT",3304826586:"IFCVERTEXBASEDTEXTUREMAP",2799835756:"IFCVERTEX",180925521:"IFCUNITASSIGNMENT",1735638870:"IFCTOPOLOGYREPRESENTATION",1377556343:"IFCTOPOLOGICALREPRESENTATIONITEM",581633288:"IFCTIMESERIESVALUE",1718945513:"IFCTIMESERIESREFERENCERELATIONSHIP",3101149627:"IFCTIMESERIES",3317419933:"IFCTHERMALMATERIALPROPERTIES",1210645708:"IFCTEXTUREVERTEX",2552916305:"IFCTEXTUREMAP",1742049831:"IFCTEXTURECOORDINATEGENERATOR",280115917:"IFCTEXTURECOORDINATE",1484833681:"IFCTEXTSTYLEWITHBOXCHARACTERISTICS",1640371178:"IFCTEXTSTYLETEXTMODEL",2636378356:"IFCTEXTSTYLEFORDEFINEDFONT",1983826977:"IFCTEXTSTYLEFONTMODEL",1447204868:"IFCTEXTSTYLE",912023232:"IFCTELECOMADDRESS",531007025:"IFCTABLEROW",985171141:"IFCTABLE",1290481447:"IFCSYMBOLSTYLE",626085974:"IFCSURFACETEXTURE",1351298697:"IFCSURFACESTYLEWITHTEXTURES",846575682:"IFCSURFACESTYLESHADING",1607154358:"IFCSURFACESTYLEREFRACTION",3303107099:"IFCSURFACESTYLELIGHTING",1300840506:"IFCSURFACESTYLE",3049322572:"IFCSTYLEDREPRESENTATION",3958052878:"IFCSTYLEDITEM",2830218821:"IFCSTYLEMODEL",3408363356:"IFCSTRUCTURALLOADTEMPERATURE",2525727697:"IFCSTRUCTURALLOADSTATIC",2162789131:"IFCSTRUCTURALLOAD",2273995522:"IFCSTRUCTURALCONNECTIONCONDITION",3692461612:"IFCSIMPLEPROPERTY",4240577450:"IFCSHAPEREPRESENTATION",3982875396:"IFCSHAPEMODEL",867548509:"IFCSHAPEASPECT",4165799628:"IFCSECTIONREINFORCEMENTPROPERTIES",2042790032:"IFCSECTIONPROPERTIES",448429030:"IFCSIUNIT",2341007311:"IFCROOT",3679540991:"IFCRIBPLATEPROFILEPROPERTIES",1660063152:"IFCREPRESENTATIONMAP",3008791417:"IFCREPRESENTATIONITEM",3377609919:"IFCREPRESENTATIONCONTEXT",1076942058:"IFCREPRESENTATION",1222501353:"IFCRELAXATION",1580146022:"IFCREINFORCEMENTBARPROPERTIES",2692823254:"IFCREFERENCESVALUEDOCUMENT",825690147:"IFCQUANTITYWEIGHT",2405470396:"IFCQUANTITYVOLUME",3252649465:"IFCQUANTITYTIME",931644368:"IFCQUANTITYLENGTH",2093928680:"IFCQUANTITYCOUNT",2044713172:"IFCQUANTITYAREA",3710013099:"IFCPROPERTYENUMERATION",148025276:"IFCPROPERTYDEPENDENCYRELATIONSHIP",3896028662:"IFCPROPERTYCONSTRAINTRELATIONSHIP",2598011224:"IFCPROPERTY",2802850158:"IFCPROFILEPROPERTIES",3958567839:"IFCPROFILEDEF",2267347899:"IFCPRODUCTSOFCOMBUSTIONPROPERTIES",2095639259:"IFCPRODUCTREPRESENTATION",2417041796:"IFCPRESENTATIONSTYLEASSIGNMENT",3119450353:"IFCPRESENTATIONSTYLE",1304840413:"IFCPRESENTATIONLAYERWITHSTYLE",2022622350:"IFCPRESENTATIONLAYERASSIGNMENT",1775413392:"IFCPREDEFINEDTEXTFONT",3213052703:"IFCPREDEFINEDTERMINATORSYMBOL",990879717:"IFCPREDEFINEDSYMBOL",3727388367:"IFCPREDEFINEDITEM",3355820592:"IFCPOSTALADDRESS",2226359599:"IFCPHYSICALSIMPLEQUANTITY",2483315170:"IFCPHYSICALQUANTITY",101040310:"IFCPERSONANDORGANIZATION",2077209135:"IFCPERSON",1207048766:"IFCOWNERHISTORY",1411181986:"IFCORGANIZATIONRELATIONSHIP",4251960020:"IFCORGANIZATION",1227763645:"IFCOPTICALMATERIALPROPERTIES",2251480897:"IFCOBJECTIVE",3701648758:"IFCOBJECTPLACEMENT",1918398963:"IFCNAMEDUNIT",2706619895:"IFCMONETARYUNIT",3368373690:"IFCMETRIC",677618848:"IFCMECHANICALSTEELMATERIALPROPERTIES",4256014907:"IFCMECHANICALMATERIALPROPERTIES",2597039031:"IFCMEASUREWITHUNIT",3265635763:"IFCMATERIALPROPERTIES",2199411900:"IFCMATERIALLIST",1303795690:"IFCMATERIALLAYERSETUSAGE",3303938423:"IFCMATERIALLAYERSET",248100487:"IFCMATERIALLAYER",1847130766:"IFCMATERIALCLASSIFICATIONRELATIONSHIP",1838606355:"IFCMATERIAL",30780891:"IFCLOCALTIME",1566485204:"IFCLIGHTINTENSITYDISTRIBUTION",4162380809:"IFCLIGHTDISTRIBUTIONDATA",3452421091:"IFCLIBRARYREFERENCE",2655187982:"IFCLIBRARYINFORMATION",3020489413:"IFCIRREGULARTIMESERIESVALUE",852622518:"IFCGRIDAXIS",3548104201:"IFCEXTERNALLYDEFINEDTEXTFONT",3207319532:"IFCEXTERNALLYDEFINEDSYMBOL",1040185647:"IFCEXTERNALLYDEFINEDSURFACESTYLE",2242383968:"IFCEXTERNALLYDEFINEDHATCHSTYLE",3200245327:"IFCEXTERNALREFERENCE",1648886627:"IFCENVIRONMENTALIMPACTVALUE",3796139169:"IFCDRAUGHTINGCALLOUTRELATIONSHIP",770865208:"IFCDOCUMENTINFORMATIONRELATIONSHIP",1154170062:"IFCDOCUMENTINFORMATION",1376555844:"IFCDOCUMENTELECTRONICFORMAT",2949456006:"IFCDIMENSIONALEXPONENTS",1045800335:"IFCDERIVEDUNITELEMENT",1765591967:"IFCDERIVEDUNIT",1072939445:"IFCDATEANDTIME",3510044353:"IFCCURVESTYLEFONTPATTERN",2367409068:"IFCCURVESTYLEFONTANDSCALING",1105321065:"IFCCURVESTYLEFONT",539742890:"IFCCURRENCYRELATIONSHIP",602808272:"IFCCOSTVALUE",1065062679:"IFCCOORDINATEDUNIVERSALTIMEOFFSET",347226245:"IFCCONSTRAINTRELATIONSHIP",613356794:"IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP",1658513725:"IFCCONSTRAINTAGGREGATIONRELATIONSHIP",1959218052:"IFCCONSTRAINT",2732653382:"IFCCONNECTIONSURFACEGEOMETRY",4257277454:"IFCCONNECTIONPORTGEOMETRY",2614616156:"IFCCONNECTIONPOINTGEOMETRY",2859738748:"IFCCONNECTIONGEOMETRY",3264961684:"IFCCOLOURSPECIFICATION",3639012971:"IFCCLASSIFICATIONNOTATIONFACET",938368621:"IFCCLASSIFICATIONNOTATION",1098599126:"IFCCLASSIFICATIONITEMRELATIONSHIP",1767535486:"IFCCLASSIFICATIONITEM",747523909:"IFCCLASSIFICATION",622194075:"IFCCALENDARDATE",2069777674:"IFCBOUNDARYNODECONDITIONWARPING",1387855156:"IFCBOUNDARYNODECONDITION",3367102660:"IFCBOUNDARYFACECONDITION",1560379544:"IFCBOUNDARYEDGECONDITION",4037036970:"IFCBOUNDARYCONDITION",3869604511:"IFCAPPROVALRELATIONSHIP",390851274:"IFCAPPROVALPROPERTYRELATIONSHIP",2080292479:"IFCAPPROVALACTORRELATIONSHIP",130549933:"IFCAPPROVAL",1110488051:"IFCAPPLIEDVALUERELATIONSHIP",411424972:"IFCAPPLIEDVALUE",639542469:"IFCAPPLICATION",618182010:"IFCADDRESS",3630933823:"IFCACTORROLE",599546466:"FILE_DESCRIPTION",1390159747:"FILE_NAME",1109904537:"FILE_SCHEMA"};class v{constructor(){S(this,"enabled",!0),S(this,"trigger",(t=>{if(!this.enabled)return;const e=this.handlers.slice(0);for(const s of e)s(t)})),S(this,"handlers",[])}add(t){this.handlers.push(t)}remove(t){this.handlers=this.handlers.filter((e=>e!==t))}reset(){this.handlers.length=0}}class x{constructor(){S(this,"enabled",!0),S(this,"trigger",(async t=>{if(!this.enabled)return;const e=this.handlers.slice(0);for(const s of e)await s(t)})),S(this,"handlers",[])}add(t){this.handlers.push(t)}remove(t){this.handlers=this.handlers.filter((e=>e!==t))}reset(){this.handlers.length=0}}class P extends Map{constructor(t){super(t),S(this,"onItemSet",new v),S(this,"onItemUpdated",new v),S(this,"onItemDeleted",new v),S(this,"onBeforeDelete",new v),S(this,"onCleared",new v),S(this,"guard",(()=>!0))}clear(){for(const[t,e]of this)this.onBeforeDelete.trigger({key:t,value:e});super.clear(),this.onCleared.trigger()}set(t,e){const s=this.has(t);if(!(this.guard??(()=>!0))(t,e))return this;const i=super.set(t,e);return s?(this.onItemUpdated||(this.onItemUpdated=new v),this.onItemUpdated.trigger({key:t,value:e})):(this.onItemSet||(this.onItemSet=new v),this.onItemSet.trigger({key:t,value:e})),i}delete(t){const e=this.get(t);if(!e)return!1;this.onBeforeDelete.trigger({key:t,value:e});const s=super.delete(t);return s&&this.onItemDeleted.trigger(t),s}dispose(){this.clear(),this.onItemSet.reset(),this.onItemDeleted.reset(),this.onCleared.reset(),this.onBeforeDelete.reset()}}class M extends Set{constructor(t){super(t),S(this,"onItemAdded",new v),S(this,"onBeforeDelete",new v),S(this,"onItemDeleted",new v),S(this,"onCleared",new v),S(this,"guard",(()=>!0))}clear(){for(const t of this)this.onBeforeDelete.trigger(t);super.clear(),this.onCleared.trigger()}add(...t){for(const e of t){if(this.has(e))continue;(this.guard??(()=>!0))(e)&&(super.add(e),this.onItemAdded||(this.onItemAdded=new v),this.onItemAdded.trigger(e))}return this}delete(t){if(!this.has(t))return!1;this.onBeforeDelete.trigger(t);const e=super.delete(t);return e&&this.onItemDeleted.trigger(),e}dispose(){this.clear(),this.onItemAdded.reset(),this.onItemDeleted.reset(),this.onCleared.reset(),this.onBeforeDelete.reset()}}const U=new Int32Array(2),D=new Float32Array(U.buffer),V=new Float64Array(U.buffer),B=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0];var G,z;(z=G||(G={}))[z.UTF8_BYTES=1]="UTF8_BYTES",z[z.UTF16_STRING=2]="UTF16_STRING";class Y{constructor(t){this.bytes_=t,this.position_=0,this.text_decoder_=new TextDecoder}static allocate(t){return new Y(new Uint8Array(t))}clear(){this.position_=0}bytes(){return this.bytes_}position(){return this.position_}setPosition(t){this.position_=t}capacity(){return this.bytes_.length}readInt8(t){return this.readUint8(t)<<24>>24}readUint8(t){return this.bytes_[t]}readInt16(t){return this.readUint16(t)<<16>>16}readUint16(t){return this.bytes_[t]|this.bytes_[t+1]<<8}readInt32(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24}readUint32(t){return this.readInt32(t)>>>0}readInt64(t){return BigInt.asIntN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readUint64(t){return BigInt.asUintN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readFloat32(t){return U[0]=this.readInt32(t),D[0]}readFloat64(t){return U[B?0:1]=this.readInt32(t),U[B?1:0]=this.readInt32(t+4),V[0]}writeInt8(t,e){this.bytes_[t]=e}writeUint8(t,e){this.bytes_[t]=e}writeInt16(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8}writeUint16(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8}writeInt32(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24}writeUint32(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24}writeInt64(t,e){this.writeInt32(t,Number(BigInt.asIntN(32,e))),this.writeInt32(t+4,Number(BigInt.asIntN(32,e>>BigInt(32))))}writeUint64(t,e){this.writeUint32(t,Number(BigInt.asUintN(32,e))),this.writeUint32(t+4,Number(BigInt.asUintN(32,e>>BigInt(32))))}writeFloat32(t,e){D[0]=e,this.writeInt32(t,U[0])}writeFloat64(t,e){V[0]=e,this.writeInt32(t,U[B?0:1]),this.writeInt32(t+4,U[B?1:0])}getBufferIdentifier(){if(this.bytes_.length<this.position_+4+4)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");let t="";for(let e=0;e<4;e++)t+=String.fromCharCode(this.readInt8(this.position_+4+e));return t}__offset(t,e){const s=t-this.readInt32(t);return e<this.readInt16(s)?this.readInt16(s+e):0}__union(t,e){return t.bb_pos=e+this.readInt32(e),t.bb=this,t}__string(t,e){t+=this.readInt32(t);const s=this.readInt32(t);t+=4;const i=this.bytes_.subarray(t,t+s);return e===G.UTF8_BYTES?i:this.text_decoder_.decode(i)}__union_with_string(t,e){return"string"==typeof t?this.__string(e):this.__union(t,e)}__indirect(t){return t+this.readInt32(t)}__vector(t){return t+this.readInt32(t)+4}__vector_len(t){return this.readInt32(t+this.readInt32(t))}__has_identifier(t){if(4!=t.length)throw new Error("FlatBuffers: file identifier must be length 4");for(let e=0;e<4;e++)if(t.charCodeAt(e)!=this.readInt8(this.position()+4+e))return!1;return!0}createScalarList(t,e){const s=[];for(let i=0;i<e;++i){const e=t(i);null!==e&&s.push(e)}return s}createObjList(t,e){const s=[];for(let i=0;i<e;++i){const e=t(i);null!==e&&s.push(e.unpack())}return s}}class k{constructor(t){let e;this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null,this.text_encoder=new TextEncoder,e=t||1024,this.bb=Y.allocate(e),this.space=e}clear(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null}forceDefaults(t){this.force_defaults=t}dataBuffer(){return this.bb}asUint8Array(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())}prep(t,e){t>this.minalign&&(this.minalign=t);const s=1+~(this.bb.capacity()-this.space+e)&t-1;for(;this.space<s+t+e;){const t=this.bb.capacity();this.bb=k.growByteBuffer(this.bb),this.space+=this.bb.capacity()-t}this.pad(s)}pad(t){for(let e=0;e<t;e++)this.bb.writeInt8(--this.space,0)}writeInt8(t){this.bb.writeInt8(this.space-=1,t)}writeInt16(t){this.bb.writeInt16(this.space-=2,t)}writeInt32(t){this.bb.writeInt32(this.space-=4,t)}writeInt64(t){this.bb.writeInt64(this.space-=8,t)}writeFloat32(t){this.bb.writeFloat32(this.space-=4,t)}writeFloat64(t){this.bb.writeFloat64(this.space-=8,t)}addInt8(t){this.prep(1,0),this.writeInt8(t)}addInt16(t){this.prep(2,0),this.writeInt16(t)}addInt32(t){this.prep(4,0),this.writeInt32(t)}addInt64(t){this.prep(8,0),this.writeInt64(t)}addFloat32(t){this.prep(4,0),this.writeFloat32(t)}addFloat64(t){this.prep(8,0),this.writeFloat64(t)}addFieldInt8(t,e,s){(this.force_defaults||e!=s)&&(this.addInt8(e),this.slot(t))}addFieldInt16(t,e,s){(this.force_defaults||e!=s)&&(this.addInt16(e),this.slot(t))}addFieldInt32(t,e,s){(this.force_defaults||e!=s)&&(this.addInt32(e),this.slot(t))}addFieldInt64(t,e,s){(this.force_defaults||e!==s)&&(this.addInt64(e),this.slot(t))}addFieldFloat32(t,e,s){(this.force_defaults||e!=s)&&(this.addFloat32(e),this.slot(t))}addFieldFloat64(t,e,s){(this.force_defaults||e!=s)&&(this.addFloat64(e),this.slot(t))}addFieldOffset(t,e,s){(this.force_defaults||e!=s)&&(this.addOffset(e),this.slot(t))}addFieldStruct(t,e,s){e!=s&&(this.nested(e),this.slot(t))}nested(t){if(t!=this.offset())throw new TypeError("FlatBuffers: struct must be serialized inline.")}notNested(){if(this.isNested)throw new TypeError("FlatBuffers: object serialization must not be nested.")}slot(t){null!==this.vtable&&(this.vtable[t]=this.offset())}offset(){return this.bb.capacity()-this.space}static growByteBuffer(t){const e=t.capacity();if(3221225472&e)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");const s=e<<1,i=Y.allocate(s);return i.setPosition(s-e),i.bytes().set(t.bytes(),s-e),i}addOffset(t){this.prep(4,0),this.writeInt32(this.offset()-t+4)}startObject(t){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=t;for(let e=0;e<t;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()}endObject(){if(null==this.vtable||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);const t=this.offset();let e=this.vtable_in_use-1;for(;e>=0&&0==this.vtable[e];e--);const s=e+1;for(;e>=0;e--)this.addInt16(0!=this.vtable[e]?t-this.vtable[e]:0);this.addInt16(t-this.object_start);const i=2*(s+2);this.addInt16(i);let r=0;const n=this.space;t:for(e=0;e<this.vtables.length;e++){const t=this.bb.capacity()-this.vtables[e];if(i==this.bb.readInt16(t)){for(let e=2;e<i;e+=2)if(this.bb.readInt16(n+e)!=this.bb.readInt16(t+e))continue t;r=this.vtables[e];break}}return r?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,r-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t}finish(t,e,s){const i=s?4:0;if(e){const t=e;if(this.prep(this.minalign,8+i),4!=t.length)throw new TypeError("FlatBuffers: file identifier must be length 4");for(let e=3;e>=0;e--)this.writeInt8(t.charCodeAt(e))}this.prep(this.minalign,4+i),this.addOffset(t),i&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)}finishSizePrefixed(t,e){this.finish(t,e,!0)}requiredField(t,e){const s=this.bb.capacity()-t,i=s-this.bb.readInt32(s);if(!(e<this.bb.readInt16(i)&&0!=this.bb.readInt16(i+e)))throw new TypeError("FlatBuffers: field "+e+" must be set")}startVector(t,e,s){this.notNested(),this.vector_num_elems=e,this.prep(4,t*e),this.prep(s,t*e)}endVector(){return this.writeInt32(this.vector_num_elems),this.offset()}createSharedString(t){if(!t)return 0;if(this.string_maps||(this.string_maps=new Map),this.string_maps.has(t))return this.string_maps.get(t);const e=this.createString(t);return this.string_maps.set(t,e),e}createString(t){if(null==t)return 0;let e;return e=t instanceof Uint8Array?t:this.text_encoder.encode(t),this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length),this.bb.bytes().set(e,this.space),this.endVector()}createByteVector(t){return null==t?0:(this.startVector(1,t.length,1),this.bb.setPosition(this.space-=t.length),this.bb.bytes().set(t,this.space),this.endVector())}createObjectOffset(t){return null===t?0:"string"==typeof t?this.createString(t):t.pack(this)}createObjectOffsetList(t){const e=[];for(let s=0;s<t.length;++s){const i=t[s];if(null===i)throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");e.push(this.createObjectOffset(i))}return e}createStructOffsetList(t,e){return e(this,t.length),this.createObjectOffsetList(t.slice().reverse()),this.endVector()}}let H=class t{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAlignment(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsAlignment(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}absolute(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}absoluteLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}absoluteArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startAlignment(t){t.startObject(1)}static addAbsolute(t,e){t.addFieldOffset(0,e,0)}static createAbsoluteVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startAbsoluteVector(t,e){t.startVector(4,e,4)}static endAlignment(t){return t.endObject()}static createAlignment(e,s){return t.startAlignment(e),t.addAbsolute(e,s),t.endAlignment(e)}};class W{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAttribute(t,e){return(e||new W).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAttribute(t,e){return t.setPosition(t.position()+4),(e||new W).__init(t.readInt32(t.position())+t.position(),t)}data(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}dataLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startAttribute(t){t.startObject(1)}static addData(t,e){t.addFieldOffset(0,e,0)}static createDataVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startDataVector(t,e){t.startVector(4,e,4)}static endAttribute(t){const e=t.endObject();return t.requiredField(e,4),e}static createAttribute(t,e){return W.startAttribute(t),W.addData(t,e),W.endAttribute(t)}}class j{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}x(){return this.bb.readFloat32(this.bb_pos)}mutate_x(t){return this.bb.writeFloat32(this.bb_pos+0,t),!0}y(){return this.bb.readFloat32(this.bb_pos+4)}mutate_y(t){return this.bb.writeFloat32(this.bb_pos+4,t),!0}z(){return this.bb.readFloat32(this.bb_pos+8)}mutate_z(t){return this.bb.writeFloat32(this.bb_pos+8,t),!0}static sizeOf(){return 12}static createFloatVector(t,e,s,i){return t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class q{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}aperture(){return this.bb.readFloat32(this.bb_pos)}mutate_aperture(t){return this.bb.writeFloat32(this.bb_pos+0,t),!0}position(t){return(t||new j).__init(this.bb_pos+4,this.bb)}radius(){return this.bb.readFloat32(this.bb_pos+16)}mutate_radius(t){return this.bb.writeFloat32(this.bb_pos+16,t),!0}xDirection(t){return(t||new j).__init(this.bb_pos+20,this.bb)}yDirection(t){return(t||new j).__init(this.bb_pos+32,this.bb)}static sizeOf(){return 44}static createCircleCurve(t,e,s,i,r,n,o,a,c,h,l,d){return t.prep(4,44),t.prep(4,12),t.writeFloat32(d),t.writeFloat32(l),t.writeFloat32(h),t.prep(4,12),t.writeFloat32(c),t.writeFloat32(a),t.writeFloat32(o),t.writeFloat32(n),t.prep(4,12),t.writeFloat32(r),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class X{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}p1(t){return(t||new j).__init(this.bb_pos,this.bb)}p2(t){return(t||new j).__init(this.bb_pos+12,this.bb)}static sizeOf(){return 24}static createWire(t,e,s,i,r,n,o){return t.prep(4,24),t.prep(4,12),t.writeFloat32(o),t.writeFloat32(n),t.writeFloat32(r),t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class Z{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsWireSet(t,e){return(e||new Z).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsWireSet(t,e){return t.setPosition(t.position()+4),(e||new Z).__init(t.readInt32(t.position())+t.position(),t)}ps(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new j).__init(this.bb.__vector(this.bb_pos+s)+12*t,this.bb):null}psLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startWireSet(t){t.startObject(1)}static addPs(t,e){t.addFieldOffset(0,e,0)}static startPsVector(t,e){t.startVector(12,e,4)}static endWireSet(t){return t.endObject()}static createWireSet(t,e){return Z.startWireSet(t),Z.addPs(t,e),Z.endWireSet(t)}}class K{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAxis(t,e){return(e||new K).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAxis(t,e){return t.setPosition(t.position()+4),(e||new K).__init(t.readInt32(t.position())+t.position(),t)}wires(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new X).__init(this.bb.__vector(this.bb_pos+s)+24*t,this.bb):null}wiresLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}order(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}orderLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}orderArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}parts(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt8(this.bb.__vector(this.bb_pos+e)+t):0}partsLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}partsArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Int8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}wireSets(t,e){const s=this.bb.__offset(this.bb_pos,10);return s?(e||new Z).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}wireSetsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}circleCurves(t,e){const s=this.bb.__offset(this.bb_pos,12);return s?(e||new q).__init(this.bb.__vector(this.bb_pos+s)+44*t,this.bb):null}circleCurvesLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}static startAxis(t){t.startObject(5)}static addWires(t,e){t.addFieldOffset(0,e,0)}static startWiresVector(t,e){t.startVector(24,e,4)}static addOrder(t,e){t.addFieldOffset(1,e,0)}static createOrderVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startOrderVector(t,e){t.startVector(4,e,4)}static addParts(t,e){t.addFieldOffset(2,e,0)}static createPartsVector(t,e){t.startVector(1,e.length,1);for(let s=e.length-1;s>=0;s--)t.addInt8(e[s]);return t.endVector()}static startPartsVector(t,e){t.startVector(1,e,1)}static addWireSets(t,e){t.addFieldOffset(3,e,0)}static createWireSetsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startWireSetsVector(t,e){t.startVector(4,e,4)}static addCircleCurves(t,e){t.addFieldOffset(4,e,0)}static startCircleCurvesVector(t,e){t.startVector(44,e,4)}static endAxis(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,10),t.requiredField(e,12),e}static createAxis(t,e,s,i,r,n){return K.startAxis(t),K.addWires(t,e),K.addOrder(t,s),K.addParts(t,i),K.addWireSets(t,r),K.addCircleCurves(t,n),K.endAxis(t)}}var $=(t=>(t[t.NONE=0]="NONE",t[t.WIRE=1]="WIRE",t[t.WIRE_SET=2]="WIRE_SET",t[t.CIRCLE_CURVE=3]="CIRCLE_CURVE",t))($||{});class Q{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}min(t){return(t||new j).__init(this.bb_pos,this.bb)}max(t){return(t||new j).__init(this.bb_pos+12,this.bb)}static sizeOf(){return 24}static createBoundingBox(t,e,s,i,r,n,o){return t.prep(4,24),t.prep(4,12),t.writeFloat32(o),t.writeFloat32(n),t.writeFloat32(r),t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class J{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCircleExtrusion(t,e){return(e||new J).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCircleExtrusion(t,e){return t.setPosition(t.position()+4),(e||new J).__init(t.readInt32(t.position())+t.position(),t)}radius(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat64(this.bb.__vector(this.bb_pos+e)+8*t):0}radiusLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}radiusArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float64Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}axes(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new K).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}axesLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startCircleExtrusion(t){t.startObject(2)}static addRadius(t,e){t.addFieldOffset(0,e,0)}static createRadiusVector(t,e){t.startVector(8,e.length,8);for(let s=e.length-1;s>=0;s--)t.addFloat64(e[s]);return t.endVector()}static startRadiusVector(t,e){t.startVector(8,e,8)}static addAxes(t,e){t.addFieldOffset(1,e,0)}static createAxesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAxesVector(t,e){t.startVector(4,e,4)}static endCircleExtrusion(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),e}static createCircleExtrusion(t,e,s){return J.startCircleExtrusion(t),J.addRadius(t,e),J.addAxes(t,s),J.endCircleExtrusion(t)}}class tt{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}x(){return this.bb.readFloat64(this.bb_pos)}mutate_x(t){return this.bb.writeFloat64(this.bb_pos+0,t),!0}y(){return this.bb.readFloat64(this.bb_pos+8)}mutate_y(t){return this.bb.writeFloat64(this.bb_pos+8,t),!0}z(){return this.bb.readFloat64(this.bb_pos+16)}mutate_z(t){return this.bb.writeFloat64(this.bb_pos+16,t),!0}static sizeOf(){return 24}static createDoubleVector(t,e,s,i){return t.prep(8,24),t.writeFloat64(i),t.writeFloat64(s),t.writeFloat64(e),t.offset()}}class et{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsGeometryLines(t,e){return(e||new et).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsGeometryLines(t,e){return t.setPosition(t.position()+4),(e||new et).__init(t.readInt32(t.position())+t.position(),t)}points(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new j).__init(this.bb.__vector(this.bb_pos+s)+12*t,this.bb):null}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startGeometryLines(t){t.startObject(1)}static addPoints(t,e){t.addFieldOffset(0,e,0)}static startPointsVector(t,e){t.startVector(12,e,4)}static endGeometryLines(t){const e=t.endObject();return t.requiredField(e,4),e}static createGeometryLines(t,e){return et.startGeometryLines(t),et.addPoints(t,e),et.endGeometryLines(t)}}class st{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}geometryClass(){return this.bb.readInt8(this.bb_pos)}mutate_geometry_class(t){return this.bb.writeInt8(this.bb_pos+0,t),!0}id(){return this.bb.readUint32(this.bb_pos+4)}mutate_id(t){return this.bb.writeUint32(this.bb_pos+4,t),!0}transform(){return this.bb.readUint32(this.bb_pos+8)}mutate_transform(t){return this.bb.writeUint32(this.bb_pos+8,t),!0}static sizeOf(){return 12}static createGeometrySample(t,e,s,i){return t.prep(4,12),t.writeInt32(i),t.writeInt32(s),t.pad(3),t.writeInt8(e),t.offset()}}class it{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}position(t){return(t||new tt).__init(this.bb_pos,this.bb)}xDirection(t){return(t||new j).__init(this.bb_pos+24,this.bb)}yDirection(t){return(t||new j).__init(this.bb_pos+36,this.bb)}static sizeOf(){return 48}static createTransform(t,e,s,i,r,n,o,a,c,h){return t.prep(8,48),t.prep(4,12),t.writeFloat32(h),t.writeFloat32(c),t.writeFloat32(a),t.prep(4,12),t.writeFloat32(o),t.writeFloat32(n),t.writeFloat32(r),t.prep(8,24),t.writeFloat64(i),t.writeFloat64(s),t.writeFloat64(e),t.offset()}}class rt{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsGeometries(t,e){return(e||new rt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsGeometries(t,e){return t.setPosition(t.position()+4),(e||new rt).__init(t.readInt32(t.position())+t.position(),t)}samples(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new st).__init(this.bb.__vector(this.bb_pos+s)+12*t,this.bb):null}samplesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}transforms(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new it).__init(this.bb.__vector(this.bb_pos+s)+48*t,this.bb):null}transformsLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}lines(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new et).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}linesLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startGeometries(t){t.startObject(3)}static addSamples(t,e){t.addFieldOffset(0,e,0)}static startSamplesVector(t,e){t.startVector(12,e,4)}static addTransforms(t,e){t.addFieldOffset(1,e,0)}static startTransformsVector(t,e){t.startVector(48,e,8)}static addLines(t,e){t.addFieldOffset(2,e,0)}static createLinesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startLinesVector(t,e){t.startVector(4,e,4)}static endGeometries(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),t.requiredField(e,8),e}static createGeometries(t,e,s,i){return rt.startGeometries(t),rt.addSamples(t,e),rt.addTransforms(t,s),rt.addLines(t,i),rt.endGeometries(t)}}var nt=(t=>(t[t.NONE=0]="NONE",t[t.LINES=1]="LINES",t[t.ELLIPSE_ARC=2]="ELLIPSE_ARC",t[t.CLOTHOID=3]="CLOTHOID",t[t.PARABOLA=4]="PARABOLA",t))(nt||{});class ot{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}r(){return this.bb.readUint8(this.bb_pos)}mutate_r(t){return this.bb.writeUint8(this.bb_pos+0,t),!0}g(){return this.bb.readUint8(this.bb_pos+1)}mutate_g(t){return this.bb.writeUint8(this.bb_pos+1,t),!0}b(){return this.bb.readUint8(this.bb_pos+2)}mutate_b(t){return this.bb.writeUint8(this.bb_pos+2,t),!0}a(){return this.bb.readUint8(this.bb_pos+3)}mutate_a(t){return this.bb.writeUint8(this.bb_pos+3,t),!0}renderedFaces(){return this.bb.readInt8(this.bb_pos+4)}mutate_rendered_faces(t){return this.bb.writeInt8(this.bb_pos+4,t),!0}stroke(){return this.bb.readInt8(this.bb_pos+5)}mutate_stroke(t){return this.bb.writeInt8(this.bb_pos+5,t),!0}static sizeOf(){return 6}static createMaterial(t,e,s,i,r,n,o){return t.prep(1,6),t.writeInt8(o),t.writeInt8(n),t.writeInt8(r),t.writeInt8(i),t.writeInt8(s),t.writeInt8(e),t.offset()}}class at{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}id(){return this.bb.readUint32(this.bb_pos)}mutate_id(t){return this.bb.writeUint32(this.bb_pos+0,t),!0}bbox(t){return(t||new Q).__init(this.bb_pos+4,this.bb)}representationClass(){return this.bb.readInt8(this.bb_pos+28)}mutate_representation_class(t){return this.bb.writeInt8(this.bb_pos+28,t),!0}static sizeOf(){return 32}static createRepresentation(t,e,s,i,r,n,o,a,c){return t.prep(4,32),t.pad(3),t.writeInt8(c),t.prep(4,24),t.prep(4,12),t.writeFloat32(a),t.writeFloat32(o),t.writeFloat32(n),t.prep(4,12),t.writeFloat32(r),t.writeFloat32(i),t.writeFloat32(s),t.writeInt32(e),t.offset()}}class ct{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}item(){return this.bb.readUint32(this.bb_pos)}mutate_item(t){return this.bb.writeUint32(this.bb_pos+0,t),!0}material(){return this.bb.readUint32(this.bb_pos+4)}mutate_material(t){return this.bb.writeUint32(this.bb_pos+4,t),!0}representation(){return this.bb.readUint32(this.bb_pos+8)}mutate_representation(t){return this.bb.writeUint32(this.bb_pos+8,t),!0}localTransform(){return this.bb.readUint32(this.bb_pos+12)}mutate_local_transform(t){return this.bb.writeUint32(this.bb_pos+12,t),!0}static sizeOf(){return 16}static createSample(t,e,s,i,r){return t.prep(4,16),t.writeInt32(r),t.writeInt32(i),t.writeInt32(s),t.writeInt32(e),t.offset()}}class ht{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShellHole(t,e){return(e||new ht).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShellHole(t,e){return t.setPosition(t.position()+4),(e||new ht).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint16(this.bb.__vector(this.bb_pos+e)+2*t):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint16Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}profileId(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint16(this.bb_pos+t):0}mutate_profile_id(t){const e=this.bb.__offset(this.bb_pos,6);return 0!==e&&(this.bb.writeUint16(this.bb_pos+e,t),!0)}static startShellHole(t){t.startObject(2)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(2,e.length,2);for(let s=e.length-1;s>=0;s--)t.addInt16(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(2,e,2)}static addProfileId(t,e){t.addFieldInt16(1,e,0)}static endShellHole(t){const e=t.endObject();return t.requiredField(e,4),e}static createShellHole(t,e,s){return ht.startShellHole(t),ht.addIndices(t,e),ht.addProfileId(t,s),ht.endShellHole(t)}}class lt{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShellProfile(t,e){return(e||new lt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShellProfile(t,e){return t.setPosition(t.position()+4),(e||new lt).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint16(this.bb.__vector(this.bb_pos+e)+2*t):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint16Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startShellProfile(t){t.startObject(1)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(2,e.length,2);for(let s=e.length-1;s>=0;s--)t.addInt16(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(2,e,2)}static endShellProfile(t){const e=t.endObject();return t.requiredField(e,4),e}static createShellProfile(t,e){return lt.startShellProfile(t),lt.addIndices(t,e),lt.endShellProfile(t)}}class dt{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShell(t,e){return(e||new dt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShell(t,e){return t.setPosition(t.position()+4),(e||new dt).__init(t.readInt32(t.position())+t.position(),t)}profiles(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new lt).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}profilesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}holes(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new ht).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}holesLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}points(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new j).__init(this.bb.__vector(this.bb_pos+s)+12*t,this.bb):null}pointsLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startShell(t){t.startObject(3)}static addProfiles(t,e){t.addFieldOffset(0,e,0)}static createProfilesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startProfilesVector(t,e){t.startVector(4,e,4)}static addHoles(t,e){t.addFieldOffset(1,e,0)}static createHolesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startHolesVector(t,e){t.startVector(4,e,4)}static addPoints(t,e){t.addFieldOffset(2,e,0)}static startPointsVector(t,e){t.startVector(12,e,4)}static endShell(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),t.requiredField(e,8),e}static createShell(t,e,s,i){return dt.startShell(t),dt.addProfiles(t,e),dt.addHoles(t,s),dt.addPoints(t,i),dt.endShell(t)}}class bt{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsMeshes(t,e){return(e||new bt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsMeshes(t,e){return t.setPosition(t.position()+4),(e||new bt).__init(t.readInt32(t.position())+t.position(),t)}coordinates(t){const e=this.bb.__offset(this.bb_pos,4);return e?(t||new it).__init(this.bb_pos+e,this.bb):null}meshesItems(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}meshesItemsLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}meshesItemsArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}samples(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new ct).__init(this.bb.__vector(this.bb_pos+s)+16*t,this.bb):null}samplesLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}representations(t,e){const s=this.bb.__offset(this.bb_pos,10);return s?(e||new at).__init(this.bb.__vector(this.bb_pos+s)+32*t,this.bb):null}representationsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}materials(t,e){const s=this.bb.__offset(this.bb_pos,12);return s?(e||new ot).__init(this.bb.__vector(this.bb_pos+s)+6*t,this.bb):null}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}circleExtrusions(t,e){const s=this.bb.__offset(this.bb_pos,14);return s?(e||new J).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}circleExtrusionsLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}shells(t,e){const s=this.bb.__offset(this.bb_pos,16);return s?(e||new dt).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}shellsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}localTransforms(t,e){const s=this.bb.__offset(this.bb_pos,18);return s?(e||new it).__init(this.bb.__vector(this.bb_pos+s)+48*t,this.bb):null}localTransformsLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}globalTransforms(t,e){const s=this.bb.__offset(this.bb_pos,20);return s?(e||new it).__init(this.bb.__vector(this.bb_pos+s)+48*t,this.bb):null}globalTransformsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}static startMeshes(t){t.startObject(9)}static addCoordinates(t,e){t.addFieldStruct(0,e,0)}static addMeshesItems(t,e){t.addFieldOffset(1,e,0)}static createMeshesItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startMeshesItemsVector(t,e){t.startVector(4,e,4)}static addSamples(t,e){t.addFieldOffset(2,e,0)}static startSamplesVector(t,e){t.startVector(16,e,4)}static addRepresentations(t,e){t.addFieldOffset(3,e,0)}static startRepresentationsVector(t,e){t.startVector(32,e,4)}static addMaterials(t,e){t.addFieldOffset(4,e,0)}static startMaterialsVector(t,e){t.startVector(6,e,1)}static addCircleExtrusions(t,e){t.addFieldOffset(5,e,0)}static createCircleExtrusionsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startCircleExtrusionsVector(t,e){t.startVector(4,e,4)}static addShells(t,e){t.addFieldOffset(6,e,0)}static createShellsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startShellsVector(t,e){t.startVector(4,e,4)}static addLocalTransforms(t,e){t.addFieldOffset(7,e,0)}static startLocalTransformsVector(t,e){t.startVector(48,e,8)}static addGlobalTransforms(t,e){t.addFieldOffset(8,e,0)}static startGlobalTransformsVector(t,e){t.startVector(48,e,8)}static endMeshes(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,10),t.requiredField(e,12),t.requiredField(e,14),t.requiredField(e,16),t.requiredField(e,18),t.requiredField(e,20),e}static createMeshes(t,e,s,i,r,n,o,a,c,h){return bt.startMeshes(t),bt.addCoordinates(t,e),bt.addMeshesItems(t,s),bt.addSamples(t,i),bt.addRepresentations(t,r),bt.addMaterials(t,n),bt.addCircleExtrusions(t,o),bt.addShells(t,a),bt.addLocalTransforms(t,c),bt.addGlobalTransforms(t,h),bt.endMeshes(t)}}class ut{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsRelation(t,e){return(e||new ut).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsRelation(t,e){return t.setPosition(t.position()+4),(e||new ut).__init(t.readInt32(t.position())+t.position(),t)}data(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}dataLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startRelation(t){t.startObject(1)}static addData(t,e){t.addFieldOffset(0,e,0)}static createDataVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startDataVector(t,e){t.startVector(4,e,4)}static endRelation(t){const e=t.endObject();return t.requiredField(e,4),e}static createRelation(t,e){return ut.startRelation(t),ut.addData(t,e),ut.endRelation(t)}}class ft{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSpatialStructure(t,e){return(e||new ft).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSpatialStructure(t,e){return t.setPosition(t.position()+4),(e||new ft).__init(t.readInt32(t.position())+t.position(),t)}localId(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):null}mutate_local_id(t){const e=this.bb.__offset(this.bb_pos,4);return 0!==e&&(this.bb.writeUint32(this.bb_pos+e,t),!0)}category(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}children(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new ft).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}childrenLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startSpatialStructure(t){t.startObject(3)}static addLocalId(t,e){t.addFieldInt32(0,e,null)}static addCategory(t,e){t.addFieldOffset(1,e,0)}static addChildren(t,e){t.addFieldOffset(2,e,0)}static createChildrenVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startChildrenVector(t,e){t.startVector(4,e,4)}static endSpatialStructure(t){return t.endObject()}static createSpatialStructure(t,e,s,i){return ft.startSpatialStructure(t),null!==e&&ft.addLocalId(t,e),ft.addCategory(t,s),ft.addChildren(t,i),ft.endSpatialStructure(t)}}class It{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsModel(t,e){return(e||new It).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsModel(t,e){return t.setPosition(t.position()+4),(e||new It).__init(t.readInt32(t.position())+t.position(),t)}static bufferHasIdentifier(t){return t.__has_identifier("0001")}metadata(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}guids(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}guidsLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}guidsItems(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}guidsItemsLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}guidsItemsArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}maxLocalId(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readUint32(this.bb_pos+t):0}mutate_max_local_id(t){const e=this.bb.__offset(this.bb_pos,10);return 0!==e&&(this.bb.writeUint32(this.bb_pos+e,t),!0)}localIds(t){const e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}localIdsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}localIdsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}categories(t,e){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}categoriesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}meshes(t){const e=this.bb.__offset(this.bb_pos,16);return e?(t||new bt).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}attributes(t,e){const s=this.bb.__offset(this.bb_pos,18);return s?(e||new W).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}attributesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}relations(t,e){const s=this.bb.__offset(this.bb_pos,20);return s?(e||new ut).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}relationsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}relationsItems(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}relationsItemsLength(){const t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}relationsItemsArray(){const t=this.bb.__offset(this.bb_pos,22);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}guid(t){const e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__string(this.bb_pos+e,t):null}spatialStructure(t){const e=this.bb.__offset(this.bb_pos,26);return e?(t||new ft).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}alignments(t,e){const s=this.bb.__offset(this.bb_pos,28);return s?(e||new H).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}geometries(t){const e=this.bb.__offset(this.bb_pos,30);return e?(t||new rt).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startModel(t){t.startObject(14)}static addMetadata(t,e){t.addFieldOffset(0,e,0)}static addGuids(t,e){t.addFieldOffset(1,e,0)}static createGuidsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startGuidsVector(t,e){t.startVector(4,e,4)}static addGuidsItems(t,e){t.addFieldOffset(2,e,0)}static createGuidsItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startGuidsItemsVector(t,e){t.startVector(4,e,4)}static addMaxLocalId(t,e){t.addFieldInt32(3,e,0)}static addLocalIds(t,e){t.addFieldOffset(4,e,0)}static createLocalIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startLocalIdsVector(t,e){t.startVector(4,e,4)}static addCategories(t,e){t.addFieldOffset(5,e,0)}static createCategoriesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startCategoriesVector(t,e){t.startVector(4,e,4)}static addMeshes(t,e){t.addFieldOffset(6,e,0)}static addAttributes(t,e){t.addFieldOffset(7,e,0)}static createAttributesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAttributesVector(t,e){t.startVector(4,e,4)}static addRelations(t,e){t.addFieldOffset(8,e,0)}static createRelationsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startRelationsVector(t,e){t.startVector(4,e,4)}static addRelationsItems(t,e){t.addFieldOffset(9,e,0)}static createRelationsItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startRelationsItemsVector(t,e){t.startVector(4,e,4)}static addGuid(t,e){t.addFieldOffset(10,e,0)}static addSpatialStructure(t,e){t.addFieldOffset(11,e,0)}static addAlignments(t,e){t.addFieldOffset(12,e,0)}static createAlignmentsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAlignmentsVector(t,e){t.startVector(4,e,4)}static addGeometries(t,e){t.addFieldOffset(13,e,0)}static endModel(t){const e=t.endObject();return t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,12),t.requiredField(e,14),t.requiredField(e,16),t.requiredField(e,24),e}static finishModelBuffer(t,e){t.finish(e,"0001")}static finishSizePrefixedModelBuffer(t,e){t.finish(e,"0001",!0)}}var _t=(t=>(t[t.ONE=0]="ONE",t[t.TWO=1]="TWO",t))(_t||{}),pt=(t=>(t[t.NONE=0]="NONE",t[t.SHELL=1]="SHELL",t[t.CIRCLE_EXTRUSION=2]="CIRCLE_EXTRUSION",t))(pt||{}),Et=(t=>(t[t.DEFAULT=0]="DEFAULT",t))(Et||{});const mt=65536;var Ct=(t=>(t[t.LINE=0]="LINE",t[t.SHELL=1]="SHELL",t))(Ct||{}),gt=(t=>(t[t.UPDATE=0]="UPDATE",t[t.CREATE=1]="CREATE",t[t.DELETE=2]="DELETE",t[t.FINISH=3]="FINISH",t))(gt||{}),Tt=(t=>(t[t.GEOMETRY=0]="GEOMETRY",t[t.WIRES=1]="WIRES",t[t.INVISIBLE=2]="INVISIBLE",t))(Tt||{}),At=(t=>(t[t.CREATE_MODEL=0]="CREATE_MODEL",t[t.DELETE_MODEL=1]="DELETE_MODEL",t[t.EXECUTE=2]="EXECUTE",t[t.RAYCAST=3]="RAYCAST",t[t.FETCH_BOXES=4]="FETCH_BOXES",t[t.REFRESH_VIEW=5]="REFRESH_VIEW",t[t.RECOMPUTE_MESHES=6]="RECOMPUTE_MESHES",t[t.CREATE_MATERIAL=7]="CREATE_MATERIAL",t[t.THROW_ERROR=8]="THROW_ERROR",t))(At||{}),Ft=(t=>(t[t.VISIBLE=0]="VISIBLE",t))(Ft||{}),Rt=(t=>(t[t.POINT=0]="POINT",t[t.LINE=1]="LINE",t[t.FACE=2]="FACE",t))(Rt||{});class yt{static containedInParallelPlanes(t,e){let s=!0;for(const i of t){const t=i.distanceToPoint(e);s=s&&t>=0}return s}static collides(t,e,s){for(const i of e){if(this.getPointDistance(i,s,t)<0)return!1}return!0}static getPointDistance(t,e,s){const i=t.normal;for(const t of this.dimensions){const r=i[t]>=0!==e;this.tempPoint[t]=r?s.max[t]:s.min[t]}return t.distanceToPoint(this.tempPoint)}}S(yt,"tempPoint",new t.Vector3),S(yt,"dimensions",["x","y","z"]);class Ot{static transform(e,s,i=new t.Frustum){for(let t=0;t<i.planes.length;t++){const r=i.planes[t],n=e.planes[t];r.copy(n),r.applyMatrix4(s)}return i}static isIncluded(t,e){return yt.collides(t,e,!0)}static collides(t,e){return yt.collides(t,e,!1)}}var wt={exports:{}};function St(t,e,s){s=s||2;var i,r,n,o,a,c,h,l=e&&e.length,d=l?e[0]*s:t.length,b=Nt(t,0,d,s,!0),u=[];if(!b||b.next===b.prev)return u;if(l&&(b=function(t,e,s,i){var r,n,o,a=[];for(r=0,n=e.length;r<n;r++)(o=Nt(t,e[r]*i,r<n-1?e[r+1]*i:t.length,i,!1))===o.next&&(o.steiner=!0),a.push(zt(o));for(a.sort(Dt),r=0;r<a.length;r++)s=Vt(a[r],s);return s}(t,e,b,s)),t.length>80*s){i=n=t[0],r=o=t[1];for(var f=s;f<d;f+=s)(a=t[f])<i&&(i=a),(c=t[f+1])<r&&(r=c),a>n&&(n=a),c>o&&(o=c);h=0!==(h=Math.max(n-i,o-r))?32767/h:0}return vt(b,u,s,i,r,h,0),u}function Nt(t,e,s,i,r){var n,o;if(r===te(t,e,s,i)>0)for(n=e;n<s;n+=i)o=$t(n,t[n],t[n+1],o);else for(n=s-i;n>=e;n-=i)o=$t(n,t[n],t[n+1],o);return o&&Wt(o,o.next)&&(Qt(o),o=o.next),o}function Lt(t,e){if(!t)return t;e||(e=t);var s,i=t;do{if(s=!1,i.steiner||!Wt(i,i.next)&&0!==Ht(i.prev,i,i.next))i=i.next;else{if(Qt(i),(i=e=i.prev)===i.next)break;s=!0}}while(s||i!==e);return e}function vt(t,e,s,i,r,n,o){if(t){!o&&n&&function(t,e,s,i){var r=t;do{0===r.z&&(r.z=Gt(r.x,r.y,e,s,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next}while(r!==t);r.prevZ.nextZ=null,r.prevZ=null,function(t){var e,s,i,r,n,o,a,c,h=1;do{for(s=t,t=null,n=null,o=0;s;){for(o++,i=s,a=0,e=0;e<h&&(a++,i=i.nextZ);e++);for(c=h;a>0||c>0&&i;)0!==a&&(0===c||!i||s.z<=i.z)?(r=s,s=s.nextZ,a--):(r=i,i=i.nextZ,c--),n?n.nextZ=r:t=r,r.prevZ=n,n=r;s=i}n.nextZ=null,h*=2}while(o>1)}(r)}(t,i,r,n);for(var a,c,h=t;t.prev!==t.next;)if(a=t.prev,c=t.next,n?Pt(t,i,r,n):xt(t))e.push(a.i/s|0),e.push(t.i/s|0),e.push(c.i/s|0),Qt(t),t=c.next,h=c.next;else if((t=c)===h){o?1===o?vt(t=Mt(Lt(t),e,s),e,s,i,r,n,2):2===o&&Ut(t,e,s,i,r,n):vt(Lt(t),e,s,i,r,n,1);break}}}function xt(t){var e=t.prev,s=t,i=t.next;if(Ht(e,s,i)>=0)return!1;for(var r=e.x,n=s.x,o=i.x,a=e.y,c=s.y,h=i.y,l=r<n?r<o?r:o:n<o?n:o,d=a<c?a<h?a:h:c<h?c:h,b=r>n?r>o?r:o:n>o?n:o,u=a>c?a>h?a:h:c>h?c:h,f=i.next;f!==e;){if(f.x>=l&&f.x<=b&&f.y>=d&&f.y<=u&&Yt(r,a,n,c,o,h,f.x,f.y)&&Ht(f.prev,f,f.next)>=0)return!1;f=f.next}return!0}function Pt(t,e,s,i){var r=t.prev,n=t,o=t.next;if(Ht(r,n,o)>=0)return!1;for(var a=r.x,c=n.x,h=o.x,l=r.y,d=n.y,b=o.y,u=a<c?a<h?a:h:c<h?c:h,f=l<d?l<b?l:b:d<b?d:b,I=a>c?a>h?a:h:c>h?c:h,_=l>d?l>b?l:b:d>b?d:b,p=Gt(u,f,e,s,i),E=Gt(I,_,e,s,i),m=t.prevZ,C=t.nextZ;m&&m.z>=p&&C&&C.z<=E;){if(m.x>=u&&m.x<=I&&m.y>=f&&m.y<=_&&m!==r&&m!==o&&Yt(a,l,c,d,h,b,m.x,m.y)&&Ht(m.prev,m,m.next)>=0)return!1;if(m=m.prevZ,C.x>=u&&C.x<=I&&C.y>=f&&C.y<=_&&C!==r&&C!==o&&Yt(a,l,c,d,h,b,C.x,C.y)&&Ht(C.prev,C,C.next)>=0)return!1;C=C.nextZ}for(;m&&m.z>=p;){if(m.x>=u&&m.x<=I&&m.y>=f&&m.y<=_&&m!==r&&m!==o&&Yt(a,l,c,d,h,b,m.x,m.y)&&Ht(m.prev,m,m.next)>=0)return!1;m=m.prevZ}for(;C&&C.z<=E;){if(C.x>=u&&C.x<=I&&C.y>=f&&C.y<=_&&C!==r&&C!==o&&Yt(a,l,c,d,h,b,C.x,C.y)&&Ht(C.prev,C,C.next)>=0)return!1;C=C.nextZ}return!0}function Mt(t,e,s){var i=t;do{var r=i.prev,n=i.next.next;!Wt(r,n)&&jt(r,i,i.next,n)&&Zt(r,n)&&Zt(n,r)&&(e.push(r.i/s|0),e.push(i.i/s|0),e.push(n.i/s|0),Qt(i),Qt(i.next),i=t=n),i=i.next}while(i!==t);return Lt(i)}function Ut(t,e,s,i,r,n){var o=t;do{for(var a=o.next.next;a!==o.prev;){if(o.i!==a.i&&kt(o,a)){var c=Kt(o,a);return o=Lt(o,o.next),c=Lt(c,c.next),vt(o,e,s,i,r,n,0),void vt(c,e,s,i,r,n,0)}a=a.next}o=o.next}while(o!==t)}function Dt(t,e){return t.x-e.x}function Vt(t,e){var s=function(t,e){var s,i=e,r=t.x,n=t.y,o=-1/0;do{if(n<=i.y&&n>=i.next.y&&i.next.y!==i.y){var a=i.x+(n-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(a<=r&&a>o&&(o=a,s=i.x<i.next.x?i:i.next,a===r))return s}i=i.next}while(i!==e);if(!s)return null;var c,h=s,l=s.x,d=s.y,b=1/0;i=s;do{r>=i.x&&i.x>=l&&r!==i.x&&Yt(n<d?r:o,n,l,d,n<d?o:r,n,i.x,i.y)&&(c=Math.abs(n-i.y)/(r-i.x),Zt(i,t)&&(c<b||c===b&&(i.x>s.x||i.x===s.x&&Bt(s,i)))&&(s=i,b=c)),i=i.next}while(i!==h);return s}(t,e);if(!s)return e;var i=Kt(s,t);return Lt(i,i.next),Lt(s,s.next)}function Bt(t,e){return Ht(t.prev,t,e.prev)<0&&Ht(e.next,t,t.next)<0}function Gt(t,e,s,i,r){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-s)*r|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-i)*r|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function zt(t){var e=t,s=t;do{(e.x<s.x||e.x===s.x&&e.y<s.y)&&(s=e),e=e.next}while(e!==t);return s}function Yt(t,e,s,i,r,n,o,a){return(r-o)*(e-a)>=(t-o)*(n-a)&&(t-o)*(i-a)>=(s-o)*(e-a)&&(s-o)*(n-a)>=(r-o)*(i-a)}function kt(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){var s=t;do{if(s.i!==t.i&&s.next.i!==t.i&&s.i!==e.i&&s.next.i!==e.i&&jt(s,s.next,t,e))return!0;s=s.next}while(s!==t);return!1}(t,e)&&(Zt(t,e)&&Zt(e,t)&&function(t,e){var s=t,i=!1,r=(t.x+e.x)/2,n=(t.y+e.y)/2;do{s.y>n!=s.next.y>n&&s.next.y!==s.y&&r<(s.next.x-s.x)*(n-s.y)/(s.next.y-s.y)+s.x&&(i=!i),s=s.next}while(s!==t);return i}(t,e)&&(Ht(t.prev,t,e.prev)||Ht(t,e.prev,e))||Wt(t,e)&&Ht(t.prev,t,t.next)>0&&Ht(e.prev,e,e.next)>0)}function Ht(t,e,s){return(e.y-t.y)*(s.x-e.x)-(e.x-t.x)*(s.y-e.y)}function Wt(t,e){return t.x===e.x&&t.y===e.y}function jt(t,e,s,i){var r=Xt(Ht(t,e,s)),n=Xt(Ht(t,e,i)),o=Xt(Ht(s,i,t)),a=Xt(Ht(s,i,e));return r!==n&&o!==a||(!(0!==r||!qt(t,s,e))||(!(0!==n||!qt(t,i,e))||(!(0!==o||!qt(s,t,i))||!(0!==a||!qt(s,e,i)))))}function qt(t,e,s){return e.x<=Math.max(t.x,s.x)&&e.x>=Math.min(t.x,s.x)&&e.y<=Math.max(t.y,s.y)&&e.y>=Math.min(t.y,s.y)}function Xt(t){return t>0?1:t<0?-1:0}function Zt(t,e){return Ht(t.prev,t,t.next)<0?Ht(t,e,t.next)>=0&&Ht(t,t.prev,e)>=0:Ht(t,e,t.prev)<0||Ht(t,t.next,e)<0}function Kt(t,e){var s=new Jt(t.i,t.x,t.y),i=new Jt(e.i,e.x,e.y),r=t.next,n=e.prev;return t.next=e,e.prev=t,s.next=r,r.prev=s,i.next=s,s.prev=i,n.next=i,i.prev=n,i}function $t(t,e,s,i){var r=new Jt(t,e,s);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function Qt(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function Jt(t,e,s){this.i=t,this.x=e,this.y=s,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function te(t,e,s,i){for(var r=0,n=e,o=s-i;n<s;n+=i)r+=(t[o]-t[n])*(t[n+1]+t[o+1]),o=n;return r}wt.exports=St,wt.exports.default=St,St.deviation=function(t,e,s,i){var r=e&&e.length,n=r?e[0]*s:t.length,o=Math.abs(te(t,0,n,s));if(r)for(var a=0,c=e.length;a<c;a++){var h=e[a]*s,l=a<c-1?e[a+1]*s:t.length;o-=Math.abs(te(t,h,l,s))}var d=0;for(a=0;a<i.length;a+=3){var b=i[a]*s,u=i[a+1]*s,f=i[a+2]*s;d+=Math.abs((t[b]-t[f])*(t[u+1]-t[b+1])-(t[b]-t[u])*(t[f+1]-t[b+1]))}return 0===o&&0===d?0:Math.abs((d-o)/o)},St.flatten=function(t){for(var e=t[0][0].length,s={vertices:[],holes:[],dimensions:e},i=0,r=0;r<t.length;r++){for(var n=0;n<t[r].length;n++)for(var o=0;o<e;o++)s.vertices.push(t[r][n][o]);r>0&&(i+=t[r-1].length,s.holes.push(i))}return s};class ee{constructor(){S(this,"int"),S(this,"float"),S(this,"buffer"),S(this,"s1",4),S(this,"s2",8);const{intBuffer:t,floatBuffer:e,buffer:s}=this.newBuffers();this.int=t,this.float=e,this.buffer=s}newBuffers(){const t=new Int32Array(1),e=t.buffer;return{intBuffer:t,floatBuffer:new Float32Array(e),buffer:new Uint8Array(e)}}}class se{static check(t){const e=Number.isInteger(t),s=t<this._max,i=t>this._min;return e&&s&&i}}S(se,"_max",2147483647),S(se,"_min",-2147483648);const ie=class t{constructor(){S(this,"_core",new ee),S(this,"_handlers"),S(this,"_result",-1),S(this,"handleObject",(t=>{const e=Object.keys(t);for(const s of e)t.hasOwnProperty(s)&&this.compute(t[s])})),S(this,"handleString",(t=>{const e=t.length;for(let s=0;s<e;++s){const e=t.codePointAt(s);this._core.int[0]=e,this.update()}})),S(this,"handleBoolean",(t=>{this._core.int[0]=t?1:0,this.update()})),S(this,"handleNumber",(t=>{(se.check(t)?this._core.int:this._core.float)[0]=t,this.update()})),this._handlers=this.newHandlers()}get value(){return~this._result}fromMaterialData(t){const{modelId:e,objectClass:s,currentLod:i,templateId:r,...n}=t;this.reset(),this.compute(e),this.compute(s),this.compute(n),this.compute(i),this.compute(void 0!==r)}generate(t){this.reset();for(const e of t)this.compute(e);return this.value}compute(t){return this.getHandler(t)(t),this}reset(){return this._result=-1,this}getHandler(t){const e=typeof t,s=this._handlers[e];if(!s)throw new Error("Fragments: Unsupported input type");return s}newHandlers(){return{number:this.handleNumber,boolean:this.handleBoolean,string:this.handleString,object:this.handleObject}}update(){for(let e=0;e<this._core.s1;++e){this._result^=this._core.buffer[e];for(let e=0;e<this._core.s2;++e)1&this._result?this._result=this._result>>1^t._polynomial:this._result>>=1}}};S(ie,"_polynomial",2197175160);let re=ie;const ne=class t{constructor(t,e){S(this,"_first"),this._first=this.newData(t,e)}static getComplementary(t,e){let s=0;const i=t.position.length;s=this.makeBufferComplementary(i,t,s,e),s!==1/0&&e(s,1/0)}static get(t,e,s,i){const{filtered:r,position:n,size:o}=this.getData(t,s);return this.setAllBufferData(r,e,n,o,i),{position:n,size:o}}fullOf(t){const e=this._first.following,s=this._first.data;return null===e&&s===t}update(t,e){const s=this.getBufferData(t);if(!(s.data===e)){const{a:i,c:r,b:n}=this.newBuffers(t,s,e);this.setupInputData(s,i,r),this.setupUpdateBuffers(i,n,r)}}size(t){let e=0,s=this._first;for(;null!==s;){this.doesFilterPass(t,s)&&e++,s=s.following}return e}static setAllBufferData(t,e,s,i,r){for(let n=0;n<t.length;++n){const o=t[n];this.transform(o,e),this.setBuffers(s,i,n),r&&r(n,o.data)}}static makeBufferComplementary(t,e,s,i){for(let r=0;r<t;++r){const t=this.getBuffers(e,r),{position:n,size:o}=t;n>s&&i(s,n-s),s=n+o}return s}static setBuffers(t,e,s){t[s]=this._tempData.position;const i=this._tempData.size===1/0;e[s]=i?this._inf:this._tempData.size}add(e,s,i){if(!t._stash.length)return this.newData(s,i,e);const r=t._stash.pop();if(!r)throw new Error("Fragments: No stash found");return r.position=e,r.size=s,r.data=i,r}remove(e){e&&(e.following=null,e.past=null,t._stash.push(e))}static getData(t,e){const s=t.filter(e),i=s.length;return{filtered:s,position:new Uint32Array(i),size:new Uint32Array(i)}}filter(t){const e=[];let s=this._first;for(;null!==s;){this.doesFilterPass(t,s)&&e.push(s),s=s.following}return e}static transform(t,e){const s=this.getTempData(),i=t.position+t.size,r=i===e.length;if(s.position=e[t.position],r)s.size=1/0;else{const t=e[i];s.size=t-s.position}return s}static getBuffers(t,e){const s=t.position[e];let i;return i=t.size[e]===this._inf?1/0:t.size[e],{position:s,size:i}}static getTempData(){return this._tempData?this._tempData:{position:0,size:0}}doesFilterPass(t,e){return!t||t(e.data)}setupUpdateBuffers(t,e,s){this.chainBuffers(t,e,s),this.setupFirstBuffer(t,e),this.setupLastBuffer(s,e),this.setupMiddleBufferStart(e),this.setupMiddleBufferEnd(e)}setupMiddleBufferEnd(t){var e;if((null==(e=t.following)?void 0:e.data)===t.data){if(!t.following)return;const e=t.following.size+t.size,s=t.following.following;t.size=e,this.remove(t.following),t.following=s,t.following&&(t.following.past=t)}}setupFirstBuffer(t,e){t.size||(t.past?t.past.following=e:this._first=e,e.past=t.past,this.remove(t))}setupMiddleBufferStart(t){var e;if((null==(e=t.past)?void 0:e.data)===t.data){if(!t.past)return;t.size=t.past.size+t.size,t.position=t.past.position;const e=t.past.past;this.remove(t.past),t.past=e,t.past?t.past.following=t:this._first=t}}chainBuffers(t,e,s){t.following=e,e.past=t,e.following=s,s.past=e}setupLastBuffer(t,e){t.size||(t.following&&(t.following.past=e),e.following=t.following,this.remove(t))}newBuffers(t,e,s){const i=t-e.position,r=this.add(e.position,i,e.data),n=this.add(t,1,s),o=e.size-r.size-1;return{a:r,c:this.add(t+1,o,e.data),b:n}}setupInputData(t,e,s){t.past?(t.past.following=e,e.past=t.past):this._first=e,t.following&&(t.following.past=s,s.following=t.following),this.remove(t)}newData(t,e,s=0){return{position:s,size:t,past:null,following:null,data:e}}getBufferData(t){let e=this._first;for(;;){const s=null===e,i=e.position<=t,r=t<e.position+e.size;if(s||i&&r)return e;e=e.following}}};S(ne,"_stash",[]),S(ne,"_tempData",{position:0,size:0}),S(ne,"_inf",4294967295);let oe=ne;class ae{static fixNumber(t){return Number.isNaN(t)?0:Number.isFinite(t)?t:0}static forEach(t,e){if(Array.isArray(t)){let s=0;for(const i of t)e(i,s++)}else e(t,0)}}class ce{static estimateCapacity(){const t=this.capacityFactor,e=window.screen.width,s=window.screen.height,i=window.devicePixelRatio;return Math.trunc(e*s*i*i*t)}}S(ce,"capacityFactor",200);class he{static parseMaterial(e){const s=e.r()/255,i=e.g()/255,r=e.b()/255,n=e.a()/255,o=e.a()<255;return{color:new t.Color(s,i,r),renderedFaces:e.renderedFaces(),opacity:n,transparent:o}}static parseBox(t,e){this.getBox(t,e,"min"),this.getBox(t,e,"max")}static parseTransform(t,e){return this.getVector(t,"position",this._doubleVector),this.getVector(t,"xDirection",this._floatVector),this.getVector(t,"yDirection",this._floatVector),this.computeZVector(),this.setTransform(e),e}static setTransform(t){const{x:e,y:s,z:i}=this._temp.xDirection,{x:r,y:n,z:o}=this._temp.yDirection,{x:a,y:c,z:h}=this._temp.zDirection,{x:l,y:d,z:b}=this._temp.position;t.set(e,r,a,l,s,n,c,d,i,o,h,b,0,0,0,1)}static getBox(t,e,s){t[s](this._floatVector);const i=this._floatVector.x(),r=this._floatVector.y(),n=this._floatVector.z();e[s].x=ae.fixNumber(i),e[s].y=ae.fixNumber(r),e[s].z=ae.fixNumber(n)}static getVector(t,e,s){t[e](s);const i=this._temp[e],r=s.x(),n=s.y(),o=s.z();i.x=ae.fixNumber(r),i.y=ae.fixNumber(n),i.z=ae.fixNumber(o)}static computeZVector(){this._temp.zDirection.crossVectors(this._temp.xDirection,this._temp.yDirection)}}S(he,"_temp",{position:new t.Vector3,xDirection:new t.Vector3,yDirection:new t.Vector3,zDirection:new t.Vector3}),S(he,"_doubleVector",new tt),S(he,"_floatVector",new j);const le=class{static get(t,e,s){this.fetchSampleTransform(t,e),this.fetchItemTransform(t,e),s.multiplyMatrices(this._item,this._sample)}static getBox(t,e){t.bbox(this._box),he.parseBox(this._box,e)}static getBoxData(t){this._min.copy(t.min),this._max.copy(t.max),this._center.addVectors(this._min,this._max),this._center.divideScalar(2),t.getSize(this._distance)}static boxSize(t){return this.getBoxData(t),this.applyTransformer(),this._edge.start=this._min.clone(),this._edge.end=this._max.clone(),this._edge}static applyTransformer(){const{x:t,y:e,z:s}=this._distance,i=Math.max(t,e,s);t===i?this._transformers.x():e===i?this._transformers.y():this._transformers.z()}static fetchItemTransform(t,e){const s=t.item();e.globalTransforms(s,this._transform),he.parseTransform(this._transform,this._item)}static fetchSampleTransform(t,e){const s=t.localTransform();e.localTransforms(s,this._transform),he.parseTransform(this._transform,this._sample)}static setBoxZ(){this._min.set(this._center.x,this._center.y,this._min.z),this._max.set(this._center.x,this._center.y,this._max.z)}static setBoxY(){this._min.set(this._center.x,this._min.y,this._center.z),this._max.set(this._center.x,this._max.y,this._center.z)}static setBoxX(){this._min.set(this._min.x,this._center.y,this._center.z),this._max.set(this._max.x,this._center.y,this._center.z)}};S(le,"_transform",new it),S(le,"_min",new t.Vector3),S(le,"_max",new t.Vector3),S(le,"_center",new t.Vector3),S(le,"_distance",new t.Vector3),S(le,"_edge",new t.Line3),S(le,"_item",new t.Matrix4),S(le,"_sample",new t.Matrix4),S(le,"_box",new Q),S(le,"_transformers",{x:()=>le.setBoxX(),y:()=>le.setBoxY(),z:()=>le.setBoxZ()});S(class{static getWidth(t){return t.getSize(this._temp.vector),this._temp.vector.x>this._temp.vector.y&&this._temp.vector.set(this._temp.vector.y,this._temp.vector.x,this._temp.vector.z),this._temp.vector.y>this._temp.vector.z&&this._temp.vector.set(this._temp.vector.x,this._temp.vector.z,this._temp.vector.y),this._temp.vector.x>this._temp.vector.y&&this._temp.vector.set(this._temp.vector.y,this._temp.vector.x,this._temp.vector.z),this._temp.vector.y}},"_temp",{vector:new t.Vector3});const de=new e,be=new s;class ue extends E{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new m([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new m([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}applyMatrix4(t){const e=this.attributes.instanceStart,s=this.attributes.instanceEnd;return void 0!==e&&(e.applyMatrix4(t),s.applyMatrix4(t),e.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}setPositions(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const s=new C(e,6,1);return this.setAttribute("instanceStart",new g(s,3,0)),this.setAttribute("instanceEnd",new g(s,3,3)),this.instanceCount=this.attributes.instanceStart.count,this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const s=new C(e,6,1);return this.setAttribute("instanceColorStart",new g(s,3,0)),this.setAttribute("instanceColorEnd",new g(s,3,3)),this}fromWireframeGeometry(t){return this.setPositions(t.attributes.position.array),this}fromEdgesGeometry(t){return this.setPositions(t.attributes.position.array),this}fromMesh(t){return this.fromWireframeGeometry(new T(t.geometry)),this}fromLineSegments(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new e);const t=this.attributes.instanceStart,s=this.attributes.instanceEnd;void 0!==t&&void 0!==s&&(this.boundingBox.setFromBufferAttribute(t),de.setFromBufferAttribute(s),this.boundingBox.union(de))}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new l),null===this.boundingBox&&this.computeBoundingBox();const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(void 0!==t&&void 0!==e){const s=this.boundingSphere.center;this.boundingBox.getCenter(s);let i=0;for(let r=0,n=t.count;r<n;r++)be.fromBufferAttribute(t,r),i=Math.max(i,s.distanceToSquared(be)),be.fromBufferAttribute(e,r),i=Math.max(i,s.distanceToSquared(be));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}}i.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new r(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}},n.line={uniforms:o.merge([i.common,i.fog,i.line]),vertexShader:"\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\n\t\t\t\tvec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\n\t\t\t\tvec3 worldFwd = cross( worldDir, worldUp );\n\t\t\t\tworldPos = position.y < 0.5 ? start: end;\n\n\t\t\t\t// height offset\n\t\t\t\tfloat hw = linewidth * 0.5;\n\t\t\t\tworldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.xyz += worldFwd * hw;\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\tworldPos.xyz -= worldFwd * 2.0 * hw;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"};class fe extends p{constructor(t){super({type:"LineMaterial",uniforms:o.clone(n.line.uniforms),vertexShader:n.line.vertexShader,fragmentShader:n.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,this.setValues(t)}get color(){return this.uniforms.diffuse.value}set color(t){this.uniforms.diffuse.value=t}get worldUnits(){return"WORLD_UNITS"in this.defines}set worldUnits(t){!0===t?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}get linewidth(){return this.uniforms.linewidth.value}set linewidth(t){this.uniforms.linewidth&&(this.uniforms.linewidth.value=t)}get dashed(){return"USE_DASH"in this.defines}set dashed(t){!0===t!==this.dashed&&(this.needsUpdate=!0),!0===t?this.defines.USE_DASH="":delete this.defines.USE_DASH}get dashScale(){return this.uniforms.dashScale.value}set dashScale(t){this.uniforms.dashScale.value=t}get dashSize(){return this.uniforms.dashSize.value}set dashSize(t){this.uniforms.dashSize.value=t}get dashOffset(){return this.uniforms.dashOffset.value}set dashOffset(t){this.uniforms.dashOffset.value=t}get gapSize(){return this.uniforms.gapSize.value}set gapSize(t){this.uniforms.gapSize.value=t}get opacity(){return this.uniforms.opacity.value}set opacity(t){this.uniforms&&(this.uniforms.opacity.value=t)}get resolution(){return this.uniforms.resolution.value}set resolution(t){this.uniforms.resolution.value.copy(t)}get alphaToCoverage(){return"USE_ALPHA_TO_COVERAGE"in this.defines}set alphaToCoverage(t){this.defines&&(!0===t!==this.alphaToCoverage&&(this.needsUpdate=!0),!0===t?this.defines.USE_ALPHA_TO_COVERAGE="":delete this.defines.USE_ALPHA_TO_COVERAGE)}}const Ie=new a,_e=new s,pe=new s,Ee=new a,me=new a,Ce=new a,ge=new s,Te=new c,Ae=new h,Fe=new s,Re=new e,ye=new l,Oe=new a;let we,Se;function Ne(t,e,s){return Oe.set(0,0,-e,1).applyMatrix4(t.projectionMatrix),Oe.multiplyScalar(1/Oe.w),Oe.x=Se/s.width,Oe.y=Se/s.height,Oe.applyMatrix4(t.projectionMatrixInverse),Oe.multiplyScalar(1/Oe.w),Math.abs(Math.max(Oe.x,Oe.y))}class Le extends u{constructor(t=new ue,e=new fe({color:16777215*Math.random()})){super(t,e),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const t=this.geometry,e=t.attributes.instanceStart,s=t.attributes.instanceEnd,i=new Float32Array(2*e.count);for(let t=0,r=0,n=e.count;t<n;t++,r+=2)_e.fromBufferAttribute(e,t),pe.fromBufferAttribute(s,t),i[r]=0===r?0:i[r-1],i[r+1]=i[r]+_e.distanceTo(pe);const r=new C(i,2,1);return t.setAttribute("instanceDistanceStart",new g(r,1,0)),t.setAttribute("instanceDistanceEnd",new g(r,1,1)),this}raycast(t,e){const i=this.material.worldUnits,r=t.camera;null!==r||i||console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const n=void 0!==t.params.Line2&&t.params.Line2.threshold||0;we=t.ray;const o=this.matrixWorld,a=this.geometry,c=this.material;let h,l;if(Se=c.linewidth+n,null===a.boundingSphere&&a.computeBoundingSphere(),ye.copy(a.boundingSphere).applyMatrix4(o),i)h=.5*Se;else{h=Ne(r,Math.max(r.near,ye.distanceToPoint(we.origin)),c.resolution)}if(ye.radius+=h,!1!==we.intersectsSphere(ye)){if(null===a.boundingBox&&a.computeBoundingBox(),Re.copy(a.boundingBox).applyMatrix4(o),i)l=.5*Se;else{l=Ne(r,Math.max(r.near,Re.distanceToPoint(we.origin)),c.resolution)}Re.expandByScalar(l),!1!==we.intersectsBox(Re)&&(i?function(t,e){const i=t.matrixWorld,r=t.geometry,n=r.attributes.instanceStart,o=r.attributes.instanceEnd;for(let a=0,c=Math.min(r.instanceCount,n.count);a<c;a++){Ae.start.fromBufferAttribute(n,a),Ae.end.fromBufferAttribute(o,a),Ae.applyMatrix4(i);const r=new s,c=new s;we.distanceSqToSegment(Ae.start,Ae.end,c,r),c.distanceTo(r)<.5*Se&&e.push({point:c,pointOnLine:r,distance:we.origin.distanceTo(c),object:t,face:null,faceIndex:a,uv:null,uv1:null})}}(this,e):function(t,e,i){const r=e.projectionMatrix,n=t.material.resolution,o=t.matrixWorld,a=t.geometry,c=a.attributes.instanceStart,h=a.attributes.instanceEnd,l=Math.min(a.instanceCount,c.count),d=-e.near;we.at(1,Ce),Ce.w=1,Ce.applyMatrix4(e.matrixWorldInverse),Ce.applyMatrix4(r),Ce.multiplyScalar(1/Ce.w),Ce.x*=n.x/2,Ce.y*=n.y/2,Ce.z=0,ge.copy(Ce),Te.multiplyMatrices(e.matrixWorldInverse,o);for(let e=0,a=l;e<a;e++){if(Ee.fromBufferAttribute(c,e),me.fromBufferAttribute(h,e),Ee.w=1,me.w=1,Ee.applyMatrix4(Te),me.applyMatrix4(Te),Ee.z>d&&me.z>d)continue;if(Ee.z>d){const t=Ee.z-me.z,e=(Ee.z-d)/t;Ee.lerp(me,e)}else if(me.z>d){const t=me.z-Ee.z,e=(me.z-d)/t;me.lerp(Ee,e)}Ee.applyMatrix4(r),me.applyMatrix4(r),Ee.multiplyScalar(1/Ee.w),me.multiplyScalar(1/me.w),Ee.x*=n.x/2,Ee.y*=n.y/2,me.x*=n.x/2,me.y*=n.y/2,Ae.start.copy(Ee),Ae.start.z=0,Ae.end.copy(me),Ae.end.z=0;const a=Ae.closestPointToPointParameter(ge,!0);Ae.at(a,Fe);const l=f.lerp(Ee.z,me.z,a),b=l>=-1&&l<=1,u=ge.distanceTo(Fe)<.5*Se;if(b&&u){Ae.start.fromBufferAttribute(c,e),Ae.end.fromBufferAttribute(h,e),Ae.start.applyMatrix4(o),Ae.end.applyMatrix4(o);const r=new s,n=new s;we.distanceSqToSegment(Ae.start,Ae.end,n,r),i.push({point:n,pointOnLine:r,distance:we.origin.distanceTo(n),object:t,face:null,faceIndex:e,uv:null,uv1:null})}}}(this,r,e))}}onBeforeRender(t){const e=this.material.uniforms;e&&e.resolution&&(t.getViewport(Ie),this.material.uniforms.resolution.value.set(Ie.z,Ie.w))}}class ve extends ue{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(t){const e=t.length-3,s=new Float32Array(2*e);for(let i=0;i<e;i+=3)s[2*i]=t[i],s[2*i+1]=t[i+1],s[2*i+2]=t[i+2],s[2*i+3]=t[i+3],s[2*i+4]=t[i+4],s[2*i+5]=t[i+5];return super.setPositions(s),this}setColors(t){const e=t.length-3,s=new Float32Array(2*e);for(let i=0;i<e;i+=3)s[2*i]=t[i],s[2*i+1]=t[i+1],s[2*i+2]=t[i+2],s[2*i+3]=t[i+3],s[2*i+4]=t[i+4],s[2*i+5]=t[i+5];return super.setColors(s),this}setFromPoints(t){const e=t.length-1,s=new Float32Array(6*e);for(let i=0;i<e;i++)s[6*i]=t[i].x,s[6*i+1]=t[i].y,s[6*i+2]=t[i].z||0,s[6*i+3]=t[i+1].x,s[6*i+4]=t[i+1].y,s[6*i+5]=t[i+1].z||0;return super.setPositions(s),this}fromLine(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}}class xe extends Le{constructor(t=new ve,e=new fe({color:16777215*Math.random()})){super(t,e),this.isLine2=!0,this.type="Line2"}}class Pe{constructor(e){S(this,"model"),S(this,"_endpointsMaterials",{interior:new t.PointsMaterial({color:15658734,size:8,sizeAttenuation:!1,depthTest:!1}),exterior:new t.PointsMaterial({color:16777215,size:16,sizeAttenuation:!1,depthTest:!1})}),S(this,"_alignments",new t.Group),S(this,"_alignmentMaterials",{[nt.NONE]:new fe({color:16777215,linewidth:5,depthTest:!1}),[nt.LINES]:new fe({color:16711935,linewidth:5,depthTest:!1}),[nt.CLOTHOID]:new fe({color:16711680,linewidth:5,depthTest:!1}),[nt.ELLIPSE_ARC]:new fe({color:65535,linewidth:5,depthTest:!1}),[nt.PARABOLA]:new fe({color:255,linewidth:5,depthTest:!1})}),this.model=e}async getAlignments(){return this._alignments.children.length||await this.constructAlignments(),this._alignments}async getAlignmentStyles(){return{...this._alignmentMaterials,...this._endpointsMaterials}}async constructAlignments(){const e=await this.model.threads.invoke(this.model.modelId,"getAlignments");for(const s of e){const e=s.absolute,i=[],r=[],n=new t.Group;this._alignments.add(n);let o=null;const a=e[0].points,c=e[e.length-1].points;r.push(a[0],a[1],a[2]),r.push(c[c.length-3],c[c.length-2],c[c.length-1]);for(const t of e){let e=t.points;o&&(e=new Float32Array([...o,...e])),o=[t.points[t.points.length-3],t.points[t.points.length-2],t.points[t.points.length-1]],i.push(e[0],e[1],e[2]),i.push(e[e.length-3],e[e.length-2],e[e.length-1]);const s=new ve;s.setPositions(e);const r=this._alignmentMaterials[t.type],a=new xe(s,r);n.add(a),a.renderOrder=1,a.userData.points=e}const{interior:h,exterior:l}=this._endpointsMaterials;this.constructPoints(i,h,n),this.constructPoints(r,l,n)}}constructPoints(e,s,i){const r=new t.Points,n=new t.BufferGeometry,o=new Float32Array(e),a=new t.BufferAttribute(o,3);n.setAttribute("position",a),r.geometry=n,r.material=s,i.add(r),r.renderOrder=2}dispose(){this._alignments.removeFromParent();for(const t of this._alignments.children){const e=t;e.geometry.dispose(),e.geometry=void 0,e.material=void 0}for(const t of Object.values(this._alignmentMaterials))t.dispose();this._alignmentMaterials={}}}class Me{async setup(t,e,s,i,r){const n=this.getCreateModelMessage(t,s,i,r),o=this.formatModelData(s),a=await t.threads.fetch(n,o);this.updateBox(e,a)}formatModelData(t){if(t instanceof ArrayBuffer)return[t]}updateBox(t,e){t.min.copy(e.boundingBox.min),t.max.copy(e.boundingBox.max)}getCreateModelMessage(t,e,s,i){return{class:At.CREATE_MODEL,modelId:t.modelId,modelData:e,raw:s,config:i}}}class Ue{async getBoxes(t,e){const s=this.getIndividualBoxesIds(e),i=this.getBoxRequest(t,s),r=await t.threads.fetch(i);return this.getAllBoxes(r,t)}async getMergedBox(t,e){const s=this.getBoxRequest(t,[e]),[i]=await t.threads.fetch(s);return this.getAbsoluteBox(i,t)}getAbsoluteBox(e,s){const i=new t.Box3;return i.copy(e),i.applyMatrix4(s.object.matrixWorld),i}getIndividualBoxesIds(t){if(!t)return;const e=[];for(const s of t)e.push([s]);return e}getAllBoxes(e,s){const i=e.boxes,r=[];for(const e of i){const i=new t.Box3;i.copy(e),i.applyMatrix4(s.object.matrixWorld),r.push(i)}return r}getBoxRequest(t,e){return{class:At.FETCH_BOXES,modelId:t.modelId,localIds:e}}}class De{constructor(){S(this,"_coordinationMatrices",new Map)}async getCoordinationMatrix(e){let s=this._coordinationMatrices.get(e.modelId);if(s)return s;s=new t.Matrix4,this._coordinationMatrices.set(e.modelId,s);const[i,r,n,o,a,c,h,l,d]=await this.getCoordinates(e),b=new t.Vector3(o,a,c),u=new t.Vector3(h,l,d),f=(new t.Vector3).crossVectors(b,u);return s.set(o,h,f.x,i,a,l,f.y,r,c,d,f.z,n,0,0,0,1),s}async getCoordinates(t){const e=t.modelId;return t.threads.invoke(e,"getCoordinates")}async getPositions(t,e){const s=[e],i=await t.threads.invoke(t.modelId,"getPositions",s);return this.getAbsolutePositions(i,t)}getAbsolutePositions(e,s){const i=[];for(const r of e){const{x:e,y:n,z:o}=r,a=new t.Vector3(e,n,o);a.applyMatrix4(s.object.matrixWorld),i.push(a)}return i}}class Ve extends Map{constructor(t,e){super(e),S(this,"tracker",null),S(this,"localId"),S(this,"guard",(()=>!0)),this.localId=t}get object(){const t={};for(const[e,s]of this.entries())t[e]=s.value;return t}set(t,e){if(!(this.guard??(()=>!0))(t,e))return this;const s=void 0!==e.type?e:{value:e.value,type:this.getType(t)};if(!this.tracker)return super.set(t,s);if(null===this.localId)return console.warn("Item attributes are missing a valid localId. Changes can't be tracked."),super.set(t,s);let i=this.tracker.get(this.localId);return i||(i={type:"modified",added:{},deleted:[],modified:{}},this.tracker.set(this.localId,i)),"added"===i.type?i.data[t]=s:"modified"===i.type&&(this.has(t)?i.modified[t]=s:i.deleted.includes(t)?(i.deleted=i.deleted.filter((e=>e!==t)),i.modified[t]=s):i.added[t]=s),super.set(t,s)}setValue(t,e){return this.set(t,{value:e,type:this.getType(t)})}setType(t,e){const s=this.getValue(t);return s?this.set(t,{value:s,type:e}):this}delete(t){if(!this.tracker)return super.delete(t);const e=this.get("localId");if(void 0===e||"number"!=typeof e)return console.warn("Item attributes are missing a valid localId. Changes can't be tracked."),"localId"!==t&&super.delete(t);if("localId"===t)return!1;if(!this.has(t))return!1;let s=this.tracker.get(e);return s||(s={type:"modified",added:{},deleted:[],modified:{}},this.tracker.set(e,s)),"added"===s.type?delete s.data[t]:"modified"===s.type&&(t in s.added?delete s.added[t]:t in s.modified?(delete s.modified[t],s.deleted.push(t)):s.deleted.push(t)),super.delete(t)}getValue(t){const e=this.get(t);return e?e.value:null}getType(t){var e;return null==(e=this.get(t))?void 0:e.type}}class Be extends Map{constructor(t,e){super(e),S(this,"tracker",null),S(this,"localId"),S(this,"guard",(()=>!0)),S(this,"onItemsRequested",null),this.localId=t}get itemChanges(){if(!this.tracker)return null;if(!this.localId)return console.warn("Item relations can't be tracked."),null;let t=this.tracker.get(this.localId);return t||(t={type:"modified",added:{},deleted:new Set,removed:{},modified:{}},this.tracker.set(this.localId,t)),t}set(t,e){const s=this.has(t);if(!(this.guard??(()=>!0))(t,e))return this;const i=this.itemChanges;return i?(s?i.modified[t]=e:i.added[t]=e,super.set(t,e)):super.set(t,e)}add(t,e){var s;const i=this.has(t);let r=this.get(t);if(!r)return r=new Set([e]),this.set(t,r),!0;if(!r||r.has(e))return!1;const n=this.itemChanges;if(!n)return r.add(e),!0;if(i)if(null==(s=n.removed[t])?void 0:s.has(e))n.removed[t].delete(e),0===n.removed[t].size&&delete n.removed[t];else{let s=n.modified[t];s||(s=new Set,n.modified[t]=s),s.add(e)}else{let s=n.added[t];s||(s=new Set,n.added[t]=s),s.add(e)}return r.add(e),!0}remove(t,e){var s;const i=this.get(t);if(!i)return!1;if(!i.has(e))return!1;const r=this.itemChanges;if(!r)return i.delete(e);if(null==(s=r.modified[t])?void 0:s.has(e))r.modified[t].delete(e),0===r.modified[t].size&&delete r.modified[t];else{let s=r.removed[t];s||(s=new Set,r.removed[t]=s),s.add(e)}return i.delete(e)}delete(t){if(!this.has(t))return!1;const e=this.itemChanges;return e?(e.deleted.add(t),super.delete(t)):super.delete(t)}async getItems(t){if(!this.onItemsRequested)return null;const e=this.get(t);if(!e)return null;return await this.onItemsRequested([...e])}}class Ge{constructor(t,e){S(this,"model"),S(this,"localId"),S(this,"_indices",null),S(this,"_transform",null),S(this,"_normals",null),S(this,"_positions",null),S(this,"_vertices",null),S(this,"_triangles",null),S(this,"_position",null),S(this,"_box",null),this.model=t,this.localId=e}async getGeometry(){const[e]=await this.model.threads.invoke(this.model.modelId,"getGeometry",[[this.localId]]);for(const s of e){s.transform=(new t.Matrix4).fromArray(s.transform.elements);const{indices:e,normals:i,positions:r,transform:n}=s;this._indices||(this._indices=[]),this._normals||(this._normals=[]),this._positions||(this._positions=[]),this._transform||(this._transform=[]),this._indices.push(e),this._normals.push(i),this._positions.push(r),this._transform.push(n)}return e}async getIndices(){return null!==this._indices||await this.getGeometry(),this._indices}async getTransform(){return null!==this._transform||await this.getGeometry(),this._transform}async getNormals(){return null!==this._normals||await this.getGeometry(),this._normals}async getPositions(){return null!==this._positions||await this.getGeometry(),this._positions}async getVertices(){if(this._vertices)return this._vertices;const e=await this.getPositions(),s=await this.getTransform();if(!e||!s)return this._vertices;this._vertices=[];for(let i=0;i<e.length;i++){const r=e[i],n=s[i];if(!r||!n)continue;const o=[];this._vertices.push(o);const a=Object.keys(r).length/3,c=[];for(let e=0;e<a;e++){const s=r[3*e],i=r[3*e+1],a=r[3*e+2];if("number"!=typeof s||"number"!=typeof i||"number"!=typeof a)continue;const h=`${s},${i},${a}`;if(c.includes(h))continue;c.push(h);const l=new t.Vector3(s,i,a);l.applyMatrix4(n),o.push(l)}}return this._vertices}async getTriangles(){if(this._triangles)return this._triangles;const e=await this.getIndices(),s=await this.getPositions(),i=await this.getTransform();if(!e||!s||!i)return this._triangles;this._triangles=[];for(let r=0;r<e.length;r++){const n=e[r],o=s[r],a=i[r];if(!n||!o||!a)continue;const c=[];this._triangles.push(c);for(let e=0;e<n.length;e+=3){const s=n[e],i=n[e+1],r=n[e+2],h=new t.Vector3(o[3*s],o[3*s+1],o[3*s+2]),l=new t.Vector3(o[3*i],o[3*i+1],o[3*i+2]),d=new t.Vector3(o[3*r],o[3*r+1],o[3*r+2]);h.applyMatrix4(a),l.applyMatrix4(a),d.applyMatrix4(a),c.push(new t.Triangle(h,l,d))}}return this._triangles}async getPosition(){if(!this._position){if(null===this.localId)return null;this._position=await this.model.getPositions([this.localId])}return this._position}async getBox(){if(!this._box){if(null===this.localId)return null;this._box=await this.model.getBoxes([this.localId])}return this._box}async setVisibility(t){await this.model.setVisible([this.localId],t)}async getVisibility(){const[t]=await this.model.getVisible([this.localId]);return t}}class ze{constructor(t,e){S(this,"model"),S(this,"_localId",null),S(this,"_attributes",null),S(this,"_relations",null),S(this,"_guid",null),S(this,"_category",null),S(this,"_geometry",null),this.model=t,"number"==typeof e&&(this._localId=e),"string"==typeof e&&(this._guid=e)}async getLocalId(){if(!this._localId){if(!this._guid)throw new Error("Fragments: Item localId couldn't be get.");[this._localId]=await this.model.threads.invoke(this.model.modelId,"getLocalIdsByGuids",[[this._guid]])}return this._localId}async getAttributes(){if(this._attributes)return this._attributes;const t=await this.getLocalId();if(null===t)return null;const e=await this.model.threads.invoke(this.model.modelId,"getItemAttributes",[t]);if(this._attributes=new Ve(t),!e){const e=this.model.attrsChanges.get(t);if(!e||"added"!==e.type)return null;this._attributes.localId=t;for(const[t,s]of Object.entries(e.data))this._attributes.set(t,s);return this._attributes}const s=this.model.attrsChanges.get(t);if(s&&"modified"===s.type)for(const[t,e]of Object.entries(s.added))this._attributes.set(t,e);for(const t in e){const{value:i,type:r}=e[t];"modified"===(null==s?void 0:s.type)&&s.deleted.includes(t)||("modified"===(null==s?void 0:s.type)&&t in s.modified?this._attributes.set(t,s.modified[t]):this._attributes.set(t,{value:i,type:r}))}return this._attributes.tracker=this.model.attrsChanges,this._attributes}async getRelations(){if(this._relations)return this._relations;const t=await this.getLocalId();if(null===t)return null;const e=await this.model.threads.invoke(this.model.modelId,"getItemRelations",[t]);if(!e)return null;this._relations=new Be(t),this._relations.onItemsRequested=async t=>{const e=[];for(const s of t){const t=this.model.getItem(s);t&&e.push(t)}return e};const s=this.model.relsChanges.get(t);if(s&&"modified"===s.type)for(const[t,e]of Object.entries(s.added))this._relations.set(t,e);for(const[t,i]of Object.entries(e))if("modified"!==(null==s?void 0:s.type)||!s.deleted.has(t))if("modified"===(null==s?void 0:s.type)&&t in s.modified){const e=new Set([...s.modified[t],...i]);this._relations.set(t,new Set(e))}else this._relations.set(t,new Set(i));return this._relations.tracker=this.model.relsChanges,this._relations}async getGuid(){if(!this._guid){const t=await this.getLocalId();if(null===t)return null;[this._guid]=await this.model.threads.invoke(this.model.modelId,"getGuidsByLocalIds",[[t]])}return this._guid}async getCategory(){if(!this._category){const t=await this.getLocalId();if(null===t)return null;this._category=await this.model.threads.invoke(this.model.modelId,"getItemCategory",[t])}return this._category}async getGeometry(){if(this._geometry)return this._geometry;const t=await this.getLocalId();if(null===t)return null;return new Ge(this.model,t)}async getData(t=[]){var e;const s=await this.getLocalId();if(null==s)return{};t.push(s);const i=null==(e=await this.getAttributes())?void 0:e.object,r=await this.getRelations(),n={};if(r)for(const e of r.keys()){const s=[];n[e]=s;const i=await r.getItems(e);if(i)for(const e of i){const i=await e.getLocalId();if(!i)continue;if(void 0!==t.find((t=>t===i)))continue;t.push(i);const r=await e.getData(t);r&&s.push(r)}}return{...i,...n}}}class Ye{getItem(t,e){return new ze(t,e)}async getItemsData(t,e,s){return t.threads.invoke(t.modelId,"getItemsData",[e,s])}async getItemsChildren(t,e){return t.threads.invoke(t.modelId,"getItemsChildren",[e])}}class ke{constructor(){S(this,"getClippingPlanesEvent",(()=>[])),S(this,"_tempMatrix",new t.Matrix4),S(this,"_tempVec",new t.Vector3),S(this,"_tempFrustum",new t.Frustum),S(this,"_updateCameraPositionEvent",(()=>{})),S(this,"_updateCameraFrustumEvent",(()=>{})),S(this,"_updateFOVEvent",(()=>{})),S(this,"_updateOrthoSizeEvent",(()=>{}))}async refreshView(t,e){const s=this.setup(e,t),i=Ot.transform(this._tempFrustum,this._tempMatrix),r=this.newViewRequest(i,s,t);await t.threads.fetch(r)}useCamera(e){const s=new t.Matrix4;this.setCameraPosition(e),this.setCameraFrustum(e,s),this.setFov(e),this.setOrtho()}getOrthoSize(){let t=this._updateOrthoSizeEvent();if(t){t*=this._tempMatrix.getMaxScaleOnAxis()}return t}setup(t,e){t.requests.clean(e.modelId),this._tempMatrix.copy(e.object.matrixWorld).invert(),this._updateCameraPositionEvent(this._tempVec),this._updateCameraFrustumEvent(this._tempFrustum);return this._updateFOVEvent()}newViewRequest(t,e,s){const i=this.newView(t,e,s),r={};return r.class=At.REFRESH_VIEW,r.modelId=s.modelId,r.cameraFrustum=t,r.view=i,r}newView(t,e,s){const i={};return i.cameraFrustum=t,i.cameraPosition=this._tempVec.applyMatrix4(this._tempMatrix),i.fov=e,i.orthogonalDimension=this.getOrthoSize(),i.viewSize=Math.max(window.innerWidth,window.innerHeight),i.graphicThreshold=ce.estimateCapacity(),i.graphicQuality=-1.5*s.graphicsQuality+2,i.clippingPlanes=this.getPlanes(),i.modelPlacement=s.object.matrixWorld,i}setOrtho(){this._updateOrthoSizeEvent=()=>{}}setFov(e){this._updateFOVEvent=()=>{if(e instanceof t.PerspectiveCamera)return e.fov}}getPlanes(){const t=[],e=this.getClippingPlanesEvent();for(const s of e){const e=s.clone();e.applyMatrix4(this._tempMatrix),t.push(e)}return t}setCameraPosition(t){this._updateCameraPositionEvent=e=>{e.copy(t.position)}}setCameraFrustum(t,e){this._updateCameraFrustumEvent=s=>{t.updateProjectionMatrix(),t.updateWorldMatrix(!0,!0);const{projectionMatrix:i,matrixWorldInverse:r}=t;e.multiplyMatrices(i,r),s.setFromProjectionMatrix(e)}}}class He{constructor(){S(this,"_caster",new t.Raycaster),S(this,"_ray",new t.Ray),S(this,"_frustum",new t.Frustum),S(this,"_inverseTransform",new t.Matrix4),S(this,"_t",new t.Plane),S(this,"_r",new t.Plane),S(this,"_b",new t.Plane),S(this,"_l",new t.Plane),S(this,"_n",new t.Plane),S(this,"_f",new t.Plane),S(this,"_tl",new t.Vector3),S(this,"_tr",new t.Vector3),S(this,"_bl",new t.Vector3),S(this,"_br",new t.Vector3),S(this,"_tln",new t.Vector3),S(this,"_brn",new t.Vector3),S(this,"_tlp",new t.Vector2),S(this,"_brp",new t.Vector2),S(this,"distance",10)}async raycast(t,e){const{frustum:s,ray:i}=this.getRayAndFrustum(e),r=this.getRequest(t,s,i);if(!r)return null;const n=await t.threads.fetch(r);if(n.results&&n.results.length){const[e]=n.results;return this.getResult({hit:e,frustum:s,ray:i,model:t})}return null}async rectangleRaycast(t,e,s){const i=this.getFrustum(s),r=this.getRequest(t,i);if(!r)return null;r.fullyIncluded=s.fullyIncluded;const n=await t.threads.fetch(r);return n.localIds&&n.localIds.length?this.newRectangleCastResponse(n,e):null}async raycastWithSnapping(t,e){const{frustum:s,ray:i}=this.getRayAndFrustum(e),r=this.getRequest(t,s,i);if(!r)return null;r.snappingClass=e.snappingClasses;const n=await t.threads.fetch(r);return n.results?this.newRaycastSnapResult(n,s,i,t):null}screenRectToFrustum(t,e,s,i){return this.screenToCast(t,s,this._tlp),this.screenToCast(e,s,this._brp),this.setVectors(i),this.setPlanes(i),this.newFrustum()}screenToCasterPoint(t,e,s){const i=this.screenToCast(t,e);return this._caster.setFromCamera(i,s),this._caster.ray.clone()}setPlanes(t){this.setBasePoints(),t.getWorldDirection(this._n.normal),this.setEnds(t)}setVectors(t){this.setVector(this._tl,this._tlp,this._tlp,1,t),this.setVector(this._tr,this._brp,this._tlp,1,t),this.setVector(this._bl,this._tlp,this._brp,1,t),this.setVector(this._br,this._brp,this._brp,1,t),this.setVector(this._tln,this._tlp,this._tlp,0,t),this.setVector(this._brn,this._brp,this._brp,0,t)}newFrustum(){return new t.Frustum(this._t,this._b,this._l,this._r,this._f,this._n)}setEnds(t){this._n.constant=t.position.length(),this._f.normal=this._n.normal,this._f.constant=1/0}screenToCast(e,s,i=new t.Vector2){const r=s.getBoundingClientRect();return i.x=(e.x-r.left)/s.clientWidth*2-1,i.y=-(e.y-r.top)/s.clientHeight*2+1,i}setVector(t,e,s,i,r){t.set(e.x,s.y,i),t.unproject(r)}setPlane(t,e,s,i){t.setFromCoplanarPoints(e,s,i)}setBasePoints(){this.setPlane(this._t,this._tln,this._tl,this._tr),this.setPlane(this._r,this._brn,this._tr,this._br),this.setPlane(this._b,this._brn,this._br,this._bl),this.setPlane(this._l,this._tln,this._bl,this._tl)}setupRay(t,e){t&&(this._ray.copy(t),this._ray.applyMatrix4(this._inverseTransform),e.ray=this._ray)}setupMatrix(t){this._inverseTransform.copy(t.matrixWorld),this._inverseTransform.invert()}getRequest(t,e,s){const{object:i,box:r,modelId:n}=t;return e.intersectsBox(r)?this.newCastRequest(i,n,s,e):null}getRayAndFrustum(t){this.updateCamera(t.camera);const{bottomLeft:e,topRight:s}=this.getCorners(t.mouse);return{ray:this.screenToCasterPoint(t.mouse,t.dom,t.camera),frustum:this.screenRectToFrustum(e,s,t.dom,t.camera)}}getFrustum(t){return this.updateCamera(t.camera),this.screenRectToFrustum(t.topLeft,t.bottomRight,t.dom,t.camera)}getCorners(t){return{bottomLeft:t.clone().subScalar(this.distance),topRight:t.clone().addScalar(this.distance)}}getResult(t){const{hit:e,frustum:s,ray:i,model:r}=t,n={};return this.setPoint(r,e,n),this.setNormal(r,e,n),this.setDistance(r,e,n),this.setRayDistance(r,e,n),this.setBasicHitData(r,e,n,i,s),this.setSnapEdge(r,e,n,"snappedEdgeP1"),this.setSnapEdge(r,e,n,"snappedEdgeP2"),n}updateCamera(t){t.updateProjectionMatrix(),t.updateWorldMatrix(!0,!0)}newCastRequest(t,e,s,i){this.setupMatrix(t);const r={};return r.class=At.RAYCAST,r.modelId=e,this.setupRay(s,r),Ot.transform(i,this._inverseTransform,this._frustum),r.frustum=this._frustum,r}setSnapEdge(e,s,i,r){if(s[r]){const n=new t.Vector3;n.copy(s[r]),n.applyMatrix4(e.object.matrixWorld),i[r]=n}i[r]=void 0}setNormal(e,s,i){if(s.normal){const r=new t.Vector3;return r.copy(s.normal),r.transformDirection(e.object.matrixWorld),r.normalize(),void(i.normal=r)}i.normal=void 0}setDistance(t,e,s){const i=Math.sqrt(e.cameraSquaredDistance),r=t.object.matrixWorld.getMaxScaleOnAxis();s.distance=i*r}setPoint(e,s,i){const r=new t.Vector3;r.copy(s.point),r.applyMatrix4(e.object.matrixWorld),i.point=r}newRaycastSnapResult(t,e,s,i){const r=[];for(const n of t.results){const t=this.getResult({hit:n,frustum:e,ray:s,model:i});r.push(t)}return r}newRectangleCastResponse(t,e){return{localIds:t.localIds,fragments:e.list.get(t.modelId)}}setRayDistance(t,e,s){if(void 0===e.raySquaredDistance)s.rayDistance=void 0;else{const i=t.object.matrixWorld.getMaxScaleOnAxis(),r=Math.sqrt(e.raySquaredDistance);s.rayDistance=r*i}}setBasicHitData(t,e,s,i,r){s.itemId=e.itemId,s.localId=e.localId,s.object=t.object,s.fragments=t,s.ray=i,s.frustum=r,s.representationClass=e.representationClass,s.snappingClass=e.snappingClass}}class We{async resetVisible(t){await t.threads.invoke(t.modelId,"resetVisible")}async getItemsByVisibility(t,e){return t.threads.invoke(t.modelId,"getItemsByVisibility",[e])}async getVisible(t,e){return t.threads.invoke(t.modelId,"getVisible",[e])}}class je{}S(je,"vertex","\n            #include <common>\n            #include <clipping_planes_pars_vertex>\n\n            attribute float itemFilter;\n            uniform vec2 lodSize;\n            attribute vec3 itemFirst;\n            attribute vec3 itemLast;\n\n            float lodWidth = 2.0;\n            \n            void cutLodLine(const in vec4 first, inout vec4 second ) {\n                float projValue1 = projectionMatrix[2][2];\n                float projValue2 = projectionMatrix[3][2];\n                float approxResult = -(projValue2 / projValue1) / 2.0;\n                float diff1 = approxResult - first.z;\n                float diff2 = second.z - first.z;\n                float cutFilter = diff1 / diff2;\n                second.xyz = mix(first.xyz, second.xyz, cutFilter);\n            }\n                \n            void main() {\n                if (itemFilter == 0.0) {\n                    gl_Position = vec4(0,0,0,0);\n                    return;\n                }\n\n                vec4 rawFirst = vec4(itemFirst, 1.0);\n                vec4 rawLast = vec4(itemLast, 1.0);\n                vec4 first = modelViewMatrix * rawFirst;\n                vec4 last = modelViewMatrix * rawLast;\n                \n                bool lodPerspective = projectionMatrix[2][3] == -1.0;\n                if (lodPerspective) {\n                    bool firstCut = first.z < 0.0 && last.z >= 0.0;\n                    bool lastCut = last.z < 0.0 && first.z >= 0.0;\n                    if (firstCut) {\n                        cutLodLine( first, last );\n                    } else if (lastCut) {\n                        cutLodLine( last, first );\n                    }\n                }\n\n                vec4 firstCut = projectionMatrix * first;\n                vec4 lastCut = projectionMatrix * last;\n                vec3 firstNdc = firstCut.xyz / firstCut.w;\n                vec3 lastNdc = lastCut.xyz / lastCut.w;\n\n                vec2 lodOrientation = lastNdc.xy - firstNdc.xy;\n\n                float lodRatio = lodSize.x / lodSize.y;\n                lodOrientation.x *= lodRatio;\n                lodOrientation = normalize(lodOrientation);\n                \n                vec2 lodDistance = vec2(lodOrientation.y, - lodOrientation.x);\n                lodOrientation.x /= lodRatio;\n                lodDistance.x /= lodRatio;\n\n                if (position.x < 0.0) { \n                    lodDistance *= - 1.0;\n                }\n\n                if (position.y < 0.0) {\n                    lodDistance += -lodOrientation;\n                } else if (position.y > 1.0) {\n                    lodDistance += lodOrientation;\n                }\n\n                lodDistance *= lodWidth;\n                lodDistance /= lodSize.y;\n\n                bool isFirst = position.y < 0.5;\n                vec4 lodPosition = isFirst ? firstCut : lastCut;\n                lodDistance *= lodPosition.w;\n                lodPosition.xy += lodDistance;\n                gl_Position = lodPosition;\n\n                vec4 mvPosition = isFirst ? first : last;\n                #include <clipping_planes_vertex>\n            }\n    "),S(je,"fragment","\n            #include <common>\n            #include <clipping_planes_pars_fragment>\n\n            uniform vec3 lodColor;\n            uniform float lodOpacity;\n\n            void main() {\n                #include <clipping_planes_fragment>\n                gl_FragColor = vec4(lodColor, lodOpacity);\n                #include <colorspace_fragment>\n            }\n    ");const qe=class e{static setupLodMeshResize(t){t.onBeforeRender=e=>{e.getSize(t.material[0].lodSize)}}static setupLodAttributes(t){t.setIndex(e.indices),t.setAttribute("position",e.vertices)}static setLodBuffer(t,e,s){let i=t.getItemFirst(),r=t.getItemLast(),n=this.setItemFirst(t,i,e,r);const o=this.resetAttributes(i,n,e,r);({itemFirst:i,dataBuffer:n,itemLast:r}=o),this.setupFinish(s,n),t.setAttribute("itemFirst",i),t.setAttribute("itemLast",r)}static setLodVisibility(t,e){const s=this.setupItemFilter(t);this.applyVisibilityState(t,e,s),s.needsUpdate=!0}static getInterAttribute(t,e){return t.getAttribute(e)}static computeLodSphere(t){if(!t.boundingSphere)return;const s=t.getItemFirst();if(s){const i=e.getLodMidPoint(t,s),r=e.getLodRadius(i,s);t.boundingSphere.radius=r}}static newLodMaterialParams(e){const s={lodColor:{value:new t.Color(e.color)},lodSize:{value:new t.Vector2(1,1)},lodOpacity:{value:e.opacity??1}};return{uniforms:t.UniformsUtils.merge([t.UniformsLib.common,s]),transparent:e.transparent??!1,vertexShader:je.vertex,fragmentShader:je.fragment}}static setLodFilter(t,e){const s=t.getItemFilter(),i=s.array;for(let t=0;t<e.position.length;++t){const s=e.position[t]/2,r=e.size[t]/2;4294967295===r?i.fill(1,s):i.fill(1,s,s+r)}s.needsUpdate=!0}static getInstancedAttribute(t,e){return t.getAttribute(e)}static computeLodBox(t){if(!t.boundingBox)return;const e=t.getItemFirst();if(e){const s=e.data.array;t.boundingBox.setFromArray(s)}else t.boundingBox.makeEmpty()}static setDataBuffer(t,e,s){return(t=e.data).array=s,t.needsUpdate=!0,t}static disposeAllData(t){delete t.attributes.itemFilter,delete t.attributes.position,t.index=null,t.dispose(),e.setupLodAttributes(t)}static setItemFirst(t,e,s,i){let r=null;if(e){s.length===e.data.array.length?r=this.setDataBuffer(r,e,s):(e=void 0,this.disposeAllData(t))}return r}static setupFinish(t,e){t&&(e.onUploadCallback=t)}static resetAttributes(e,s,i,r){return e||(s=new t.InstancedInterleavedBuffer(i,6,1),e=new t.InterleavedBufferAttribute(s,3,0),r=new t.InterleavedBufferAttribute(s,3,3)),{itemFirst:e,dataBuffer:s,itemLast:r}}static setupItemFilter(e){const s=e.getItemFirst().count;let i=e.getItemFilter();return i?i.array.fill(0):(i=new t.InstancedBufferAttribute(new Uint8Array(s),1),e.setAttribute("itemFilter",i)),i}static applyVisibilityState(t,e,s){!0!==e?e&&this.setLodFilter(t,e):s.array.fill(1)}static getLodMidPoint(t,e){const s=t.boundingSphere.center;return this.tempBox.setFromArray(e.data.array),this.tempBox.getCenter(s),s}static getLodRadius(t,s){let i=0;const r=s.data.array.length;for(let n=0;n<r;n+=3){const r=s.data.array;e.tempVec.fromArray(r,n);const o=t.distanceToSquared(e.tempVec);i=Math.max(i,o)}return Math.sqrt(i)}};S(qe,"tempVec",new t.Vector3),S(qe,"tempBox",new t.Box3),S(qe,"vertices",new t.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),S(qe,"indices",new t.Uint8BufferAttribute([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5],1));let Xe=qe;class Ze extends t.Mesh{constructor(t,e){super(t,e),S(this,"geometry"),S(this,"material"),this.geometry=t,this.material=e,Xe.setupLodMeshResize(this)}}class Ke extends t.InstancedBufferGeometry{constructor(){super(),S(this,"isLODGeometry",!0),Xe.setupLodAttributes(this)}isFiltered(){const t=this.getItemFilter();return Boolean(t)}computeBoundingBox(){this.boundingBox||(this.boundingBox=new t.Box3),Xe.computeLodBox(this)}applyMatrix4(t){return this.applyTransformToBuffers(t),this.updateBounds(),this}computeBoundingSphere(){this.boundingSphere||(this.boundingSphere=new t.Sphere),Xe.computeLodSphere(this)}getItemFilter(){return Xe.getInstancedAttribute(this,"itemFilter")}getItemLast(){return Xe.getInterAttribute(this,"itemLast")}getItemFirst(){return Xe.getInterAttribute(this,"itemFirst")}applyTransformToBuffers(t){this.getItemFirst().applyMatrix4(t);this.getItemLast().applyMatrix4(t)}updateBounds(){this.boundingBox&&this.computeBoundingBox(),this.boundingSphere&&this.computeBoundingSphere()}}class $e extends t.ShaderMaterial{constructor(t){super(Xe.newLodMaterialParams(t)),S(this,"isLodMaterial",!0),S(this,"isLineMaterial",!0),this.clipping=!0,this.lights=!1,this.needsUpdate=!0}get lodSize(){return this.uniforms.lodSize.value}set lodColor(t){this.uniforms.lodColor.value=t}set lodSize(t){this.uniforms.lodSize.value.copy(t)}get lodColor(){return this.uniforms.lodColor.value}}class Qe{constructor(){S(this,"list",new P),S(this,"_modelMaterialMapping",new Map),S(this,"_definitions",new Map),S(this,"_idGenerator",new re),S(this,"white",4294967295)}static resetColors(e){for(const s of e){if(!s||!s.color)continue;const{color:e}=s;if(e.isColor)continue;const{r:i,g:r,b:n}=e;s.color=new t.Color(i,r,n)}}dispose(t){this._definitions.delete(t);const e=this._modelMaterialMapping.get(t);if(e){for(const t of e){const e=this.list.get(t);e&&(e.dispose(),this.list.delete(t))}this._modelMaterialMapping.delete(t)}}get(t,e){const{modelId:s,objectClass:i,currentLod:r,templateId:n}=e;if(!s||void 0===i||void 0===r)throw new Error("Fragments: material definition information is missing to create the material.");this._idGenerator.fromMaterialData({modelId:s,objectClass:i,currentLod:r,templateId:n,...t});const{value:o}=this._idGenerator;return this.getUniqueMaterial(o,t,e)}addDefinitions(t,e){const s=this._definitions.get(t);s?s.push(...e):this._definitions.set(t,e)}createHighlights(t,e){const{tileData:{highlightData:s,highlightIds:i},modelId:r,material:n}=e,{geometry:o}=t,a=t.material.slice(0,2),c=new Map,h=this._definitions.get(r);if(!h)return a;for(let t=0;t<s.position.length;t++){const r=i[t];this.processHighlight(c,r,h,n,e,a);const l=s.position[t],d=s.size[t],b=d===this.white?1/0:d;o.addGroup(l,b,c.get(i[t]))}return a}getFromRequest(t){const{material:e,modelId:s}=t,i=this._definitions.get(s),r=null==i?void 0:i[e];if(!r)throw new Error(`Fragments: Missing mesh material for index ${e}`);return this.get(r,t)}newLODMaterial(e,s){const{data:i}=e,r=new t.Color(i.color);s.currentLod===Tt.WIRES&&r.multiplyScalar(.85);const n={color:r,...this.getParameters(i)},o=new $e(n);return o.userData={customId:i.customId},o}getParameters(t){const{opacity:e,transparent:s}=t;return{opacity:e,transparent:s||e<1,clipIntersection:!1}}new(e,s){const{objectClass:i,templateId:r}=s;let n;if(i===Ct.SHELL)n=new t.MeshLambertMaterial({color:e.color,transparent:e.opacity<1,opacity:e.opacity,userData:{customId:e.customId}});else{if(i!==Ct.LINE)throw new Error("Fragments: Unsupported object class");n=this.newLODMaterial({data:e,instancing:void 0!==r},s)}return n}addMaterialToModel(t,e){let s=this._modelMaterialMapping.get(t);s||(s=new Set,this._modelMaterialMapping.set(t,s)),s.add(e)}processHighlight(t,e,s,i,r,n){if(!t.has(e)){const o={...s[i],...s[e]},a=this.get(o,r);n.push(a),t.set(e,n.length-1)}}getUniqueMaterial(t,e,s){const i=s.modelId;let r=this.list.get(t);return r||(r=this.new(e,s),this.list.set(t,r),this.addMaterialToModel(i,t),r)}}class Je{async getHighlight(t,e){const s=await t.threads.invoke(t.modelId,"getHighlight",[e]);return Qe.resetColors(s),s}async highlight(t,e,s){await t.threads.invoke(t.modelId,"highlight",[e,s])}async getHighlightItemIds(t){return t.threads.invoke(t.modelId,"getHighlightItemIds")}async resetHighlight(t,e){await t.threads.invoke(t.modelId,"resetHighlight",[e])}}class ts{async getSection(t,e){const s=[e];return await t.threads.invoke(t.modelId,"getSection",s)}}class es{async dispose(t,e,s){e.list.delete(t.modelId),await this.requestModelDelete(t),t.threads.delete(t.modelId),this.deleteAllTiles(t),e.materials.dispose(t.modelId),s.dispose()}async getBuffer(t,e){return t.threads.invoke(t.modelId,"getBuffer",[e])}async getCategories(t){return t.threads.invoke(t.modelId,"getCategories")}async getMaxLocalId(t){return t.threads.invoke(t.modelId,"getMaxLocalId")}async getLocalIdsByGuids(t,e){return t.threads.invoke(t.modelId,"getLocalIdsByGuids",[e])}async getSpatialStructure(t){return t.threads.invoke(t.modelId,"getSpatialStructure")}async getItemsWithGeometry(t){return(await t.threads.invoke(t.modelId,"getItemsWithGeometry",[])).map((e=>t.getItem(e)))}async getItemsOfCategory(t,e){const s=[e];return(await t.threads.invoke(t.modelId,"getItemsOfCategory",s)).map((e=>t.getItem(e)))}async getMetadata(t){return t.threads.invoke(t.modelId,"getMetadata",[])}async getGuidsByLocalIds(t,e){return t.threads.invoke(t.modelId,"getGuidsByLocalIds",[e])}async requestModelDelete(t){await t.threads.fetch({class:At.DELETE_MODEL,modelId:t.modelId})}deleteAllTiles(t){for(const[e]of t.tiles)t.tiles.delete(e)}}class ss{async getSequenced(t,e,s,i){const r=[e,s,i];return await t.threads.invoke(t.modelId,"getSequenced",r)}}class is{constructor(e,s,i){S(this,"attrsChanges",new Map),S(this,"relsChanges",new Map),S(this,"threads"),S(this,"tiles",new P),S(this,"object",new t.Object3D),S(this,"graphicsQuality",0),S(this,"_boxManager",new Ue),S(this,"_itemsManager",new Ye),S(this,"_coordinatesManager",new De),S(this,"_setupManager",new Me),S(this,"_viewManager",new ke),S(this,"_raycastManager",new He),S(this,"_visibilityManager",new We),S(this,"_highlightManager",new Je),S(this,"_sectionManager",new ts),S(this,"_dataManager",new es),S(this,"_sequenceManager",new ss),S(this,"_bbox",new t.Box3),S(this,"_alignmentsManager"),S(this,"_meshManager"),S(this,"_isProcessing",!1),S(this,"_isLoaded",!1),S(this,"_frozen",!1),S(this,"_isSetup",!1),this.object.name=e,this.object.up.set(0,0,1),this._meshManager=s,this.threads=i,this._alignmentsManager=new Pe(this),this.tiles.onItemSet.add((({value:t})=>this.object.add(t))),this.tiles.onBeforeDelete.add((({value:t})=>{this.object.remove(t),t.geometry.dispose(),ae.forEach(t.material,(t=>t.dispose()))}))}get modelId(){return this.object.name}get box(){return this._bbox.clone().applyMatrix4(this.object.matrixWorld)}get isBusy(){const t=this._meshManager.requests.arePending;return!this._isLoaded||this._isProcessing||t}get frozen(){return Boolean(this._frozen)}set frozen(t){t!==this._frozen&&(this._frozen=t,t||this._refreshView())}get getClippingPlanesEvent(){return this._viewManager.getClippingPlanesEvent}set getClippingPlanesEvent(t){this._viewManager.getClippingPlanesEvent=t}async dispose(){this._isLoaded=!1,await this._dataManager.dispose(this,this._meshManager,this._alignmentsManager)}async getSpatialStructure(){return this._dataManager.getSpatialStructure(this)}async getLocalIdsByGuids(t){return this._dataManager.getLocalIdsByGuids(this,t)}async getCategories(){return this._dataManager.getCategories(this)}async getItemsWithGeometry(){return this._dataManager.getItemsWithGeometry(this)}async getMetadata(){return this._dataManager.getMetadata(this)}async getGuidsByLocalIds(t){return this._dataManager.getGuidsByLocalIds(this,t)}async getBuffer(t=!1){return this._dataManager.getBuffer(this,t)}async getItemsOfCategory(t){return this._dataManager.getItemsOfCategory(this,t)}async getItemsGeometry(t){return await this.threads.invoke(this.modelId,"getItemsGeometry",[t])}async getMaxLocalId(){return this._dataManager.getMaxLocalId(this)}getItem(t){return this._itemsManager.getItem(this,t)}async getItemsChildren(t){return this._itemsManager.getItemsChildren(this,t)}async getItemsData(t,e){return this._itemsManager.getItemsData(this,t,e)}async getPositions(t){return this._coordinatesManager.getPositions(this,t)}async getCoordinates(){return this._coordinatesManager.getCoordinates(this)}async getCoordinationMatrix(){return this._coordinatesManager.getCoordinationMatrix(this)}async getMergedBox(t){return this._boxManager.getMergedBox(this,t)}async getBoxes(t){return this._boxManager.getBoxes(this,t)}async getAlignments(){return this._alignmentsManager.getAlignments()}getAlignmentStyles(){return this._alignmentsManager.getAlignmentStyles()}useCamera(t){this._viewManager.useCamera(t)}async rectangleRaycast(t){return this._raycastManager.rectangleRaycast(this,this._meshManager,t)}async raycast(t){return this._raycastManager.raycast(this,t)}async raycastWithSnapping(t){return this._raycastManager.raycastWithSnapping(this,t)}async setVisible(t,e){const s=[t,e];await this.threads.invoke(this.modelId,"setVisible",s)}async toggleVisible(t){const e=[t];await this.threads.invoke(this.modelId,"toggleVisible",e)}async getItemsByVisibility(t){return this._visibilityManager.getItemsByVisibility(this,t)}async getVisible(t){return this._visibilityManager.getVisible(this,t)}async resetVisible(){return this._visibilityManager.resetVisible(this)}async highlight(t,e){return this._highlightManager.highlight(this,t,e)}async getHighlight(t){return this._highlightManager.getHighlight(this,t)}async resetHighlight(t){return this._highlightManager.resetHighlight(this,t)}async getHighlightItemIds(){return this._highlightManager.getHighlightItemIds(this)}async getSection(t){return this._sectionManager.getSection(this,t)}async getSequenced(t,e,s){return this._sequenceManager.getSequenced(this,t,e,s)}async handleRequest(t){await this._meshManager.requests.handleRequest(this._meshManager,t)}_finishProcessing(){this._isProcessing=!1}async _refreshView(){this.frozen||(this._isProcessing=!0,await this._viewManager.refreshView(this,this._meshManager))}async _setup(t,e,s){this._isSetup||(this._setupManager.setup(this,this._bbox,t,e,s),this._isLoaded=!0,this._isProcessing=!0,this._isSetup=!0)}}class rs{constructor(){S(this,"list",[]),S(this,"onFinish",(()=>{}))}get arePending(){return this.list.length>0}async handleRequest(t,e){if(e.class===At.RECOMPUTE_MESHES)this.add(e.list),e.list=void 0;else if(e.class===At.CREATE_MATERIAL){const{materialDefinitions:s,modelId:i}=e;Qe.resetColors(s),t.materials.addDefinitions(i,s),e.materialDefinitions=void 0}else e.class===At.THROW_ERROR&&console.error(e)}add(t){for(const e of t)this.insert(e)||this.list.push(e),e.tileRequestClass===gt.FINISH&&this.onFinish()}clean(t){const e=this.list.filter((e=>e.modelId!==t||e.tileRequestClass!==gt.FINISH));this.list=e}insert(t){const{modelId:e,tileId:s,tileRequestClass:i,tileData:r}=t;if(void 0===s)return!1;if(i===gt.DELETE){const t=this.list.filter((t=>!((t.tileRequestClass===gt.CREATE||t.tileRequestClass===gt.DELETE)&&t.modelId===e&&t.tileId===s)));this.list=t}if(i===gt.CREATE){const t=this.list.filter((t=>!(t.tileRequestClass===gt.CREATE&&t.modelId===e&&t.tileId===s)));this.list=t}if(i===gt.UPDATE){const t=this.list.find((t=>t.modelId===e&&t.tileId===s));if(t)return t.tileRequestClass!==gt.CREATE&&t.tileRequestClass!==gt.UPDATE||(t.tileData=r),!0}return!1}}class ns{constructor(t){S(this,"_materials"),S(this,"white",4294967295),this._materials=t}createMesh(t,e){const s=this._materials.getFromRequest(e);if(!("isLodMaterial"in s)||!s.isLodMaterial)throw new Error("Fragments: material is not an instance of LodMaterial.");const{positions:i}=e;if(!i)throw new Error("Fragments: no positions provided to create the LOD mesh.");const r=new Ke,n=this.deleteAttributeEvent(t);Xe.setLodBuffer(r,i,n);return new Ze(r,[s])}updateVisibility(t,e){const{geometry:s}=t,{visibilityData:i,highlightData:r}=e;Xe.setLodVisibility(s,i),r?(Xe.setLodFilter(s,r),oe.getComplementary(r,((t,e)=>{s.addGroup(t,e,0)}))):s.addGroup(0,1/0,0)}processMesh(t,e){const{geometry:s}=t,{tileData:{visibilityData:i},currentLod:r}=e;if(r===Tt.WIRES&&t instanceof Ze)this.updateVisibility(t,e.tileData);else if(i&&i.position.length>0)for(let t=0;t<i.position.length;++t){const e=i.size[t]===this.white,r=i.position[t],n=e?1/0:i.size[t];s.addGroup(r,n,0)}}deleteAttributeEvent(t){return function(){delete this.array}}}class os{constructor(t){S(this,"list",new P),S(this,"materials",new Qe),S(this,"lod",new ns(this.materials)),S(this,"requests",new rs),S(this,"updateThreshold",4),S(this,"_updateFinished",!0),S(this,"_onUpdate"),this._onUpdate=t,this.requests.onFinish=()=>this._updateFinished=!0}forceUpdateFinish(t=200){return new Promise((e=>{this._updateFinished=!1;const s=setInterval((()=>{this.update(),this._updateFinished&&(clearInterval(s),e())}),t)}))}update(){const t=performance.now();for(;this.requests.arePending;){const e=this.requests.list.shift();if(e&&(this.processTileRequest(e),this._onUpdate(),performance.now()-t>this.updateThreshold))return}}setTileData(t,e){const{tileId:s,itemId:i,matrix:r,aabb:n}=e;this.setMeshData(t,s,i,r),this.setupBoundings(t,n),this.updateStatus(t,e)}processTileRequest(t){const{tileRequestClass:e,tileId:s,modelId:i}=t,r=this.list.get(i);if(r)if(e===gt.CREATE){const e=this.create(t);this.setTileData(e,t),r.tiles.set(e.userData.tileId,e)}else if(e===gt.DELETE)r.tiles.delete(s);else if(e===gt.UPDATE){const e=r.tiles.get(s);e&&this.updateStatus(e,t)}else e===gt.FINISH&&r._finishProcessing()}createMesh(e){const{indices:s,positions:i,normals:r,itemIds:n}=e,o=new t.BufferGeometry;this.setIndex(o,s),this.setPositions(i,o),this.setNormals(r,o),this.setItemIds(n,o);const a=this.materials.getFromRequest(e);return new t.Mesh(o,[a])}setupBoundings(e,s){const{geometry:i}=e,r=(new t.Box3).copy(s),n=new t.Sphere;r.getBoundingSphere(n),i.boundingBox=r,i.boundingSphere=n}create(e){if(e.objectClass===Ct.SHELL)return this.createMesh(e);if(e.objectClass===Ct.LINE){const s=new t.BufferGeometry;return this.lod.createMesh(s,e)}throw new Error(`Fragments: object class ${e.objectClass} is not supported.`)}updateStatus(t,e){const{tileData:{highlightData:s},currentLod:i}=e,{geometry:r}=t;if(r.clearGroups(),this.lod.processMesh(t,e),!s||i===Tt.WIRES)return;const n=this.materials.createHighlights(t,e);t.material=n}cleanAttributeMemory(t,e){t.attributes[e].onUpload(this.deleteAttribute(t))}setPositions(e,s){if(!e)throw new Error("Fragments: no positions provided to create the mesh.");s.setAttribute("position",new t.BufferAttribute(e,3)),this.cleanAttributeMemory(s,"position")}setIndex(e,s){if(!s)throw new Error("Fragments: no indices provided to create the mesh.");e.setIndex(new t.BufferAttribute(s,1)),e.index.onUpload(this.deleteAttribute(e))}setNormals(e,s){e&&s.setAttribute("normal",new t.BufferAttribute(e,3,!0)),this.cleanAttributeMemory(s,"normal")}setItemIds(e,s){e&&(s.setAttribute("id",new t.BufferAttribute(e,1,!1)),this.cleanAttributeMemory(s,"id"))}deleteAttribute(t){return function(){delete this.array}}setMeshData(t,e,s,i){t.userData={tileId:e,itemId:s},t.matrixAutoUpdate=!1,t.applyMatrix4(i),t.matrix.copy(i)}}class as{constructor(){S(this,"_list",new Map),S(this,"_communicationKey",0)}setupInput(t){t.requestId=this._communicationKey++}set(t,e,s){const i=this.newHandler(e,s);this._list.set(t,i)}run(t){const e=this._list.get(t.requestId);this._list.delete(t.requestId),e(t)}newHandler(t,e){return s=>{s.errorInfo?t(s.errorInfo):e(s)}}}class cs{static newThread(t){return new Worker(t,{type:"module"})}static newUpdater(t,e){return setInterval(t,e)}static getMeshComputeRequest(t,e){return{class:At.RECOMPUTE_MESHES,modelId:t,list:e}}static planeSet(e){const s=[];for(const i of e){const e=this.array(i.normal),r=i.constant,n=new t.Plane(e,r);s.push(n)}return s}static data(t){var e,s;if(void 0!==(null==t?void 0:t.elements))return cs.transform(t);if(void 0!==(null==t?void 0:t.origin)&&void 0!==(null==t?void 0:t.direction))return cs.beam(t);if(void 0!==(null==t?void 0:t.planes))return cs.frustum(t);const i=void 0!==(null==t?void 0:t.normal),r=void 0!==(null==t?void 0:t.constant);if(i&&r)return cs.plane(t);const n=void 0!==(null==(e=t[0])?void 0:e.normal),o=void 0!==(null==(s=t[0])?void 0:s.constant);if(n&&o)return cs.planeSet(t);const a=void 0!==(null==t?void 0:t.x),c=void 0!==(null==t?void 0:t.y),h=void 0!==(null==t?void 0:t.z);return a&&c&&h?cs.array(t):t}static getExecuteRequest(t,e,s){const i=Array.from(s);return{class:At.EXECUTE,modelId:t,function:e,parameters:i}}static plane(e){const s=this.array(e.normal),i=e.constant;return new t.Plane(s,i)}static getRequestContent(t){const e=[];for(const s of t.list)cs.setupCreateRequest(s,e),cs.setupUpdateRequest(s,e);return e}static array(e){const s=new t.Vector3;return s.set(e.x,e.y,e.z),s}static cleanRequests(t){const e=[],s=cs;for(const i of t){s.isFinishRequest(i)||e.push(i)}return e}static frustum(e){const s=this.planeSet(e.planes),[i,r,n,o,a,c]=s;return new t.Frustum(i,r,n,o,a,c)}static beam(e){const s=this.array(e.origin),i=this.array(e.direction);return new t.Ray(s,i)}static transform(e){const s=new t.Matrix4;return s.copy(e),s}static deleteUpdater(t){clearInterval(t)}static areCoresAvailable(t){const e=cs.getCpuCapacity();return t<Math.max(e,2)}static isFinishRequest(t){return t.tileRequestClass===gt.FINISH}static setupUpdateRequest(t,e){t.tileRequestClass===gt.UPDATE&&this.addAllTileData(t,e)}static getCpuCapacity(){return navigator.hardwareConcurrency?navigator.hardwareConcurrency-3:0}static addAllTileData(t,e){this.addRequestTileData(t,e,"visibilityData");this.addRequestTileData(t,e,"highlightData",["highlightIds"])}static addRequestContent(t,e,s){if(!e[t])return;const i=e[t].buffer;s.push(i)}static addRequestTileData(t,e,s,i=[]){const r=t.tileData[s];if(r){e.push(r.position.buffer),e.push(r.size.buffer);for(const s of i)e.push(t.tileData[s].buffer)}}static setupCreateRequest(t,e){if(t.tileRequestClass!==gt.CREATE)return;const s=this.getCreateRequestIds();for(const i of s)this.addRequestContent(i,t,e);this.addAllTileData(t,e)}static getCreateRequestIds(){return["positions","indices","normals","itemIds"]}}class hs{constructor(t){S(this,"_handlers",new as),S(this,"_handleInput"),S(this,"_port"),S(this,"onInput",(t=>{t.data.toMainThread?this._handlers.run(t.data):this.manageInput(t.data)})),this._handleInput=t}fetchMeshCompute(t,e){const s=cs,i=s.getMeshComputeRequest(t,e),r=s.getRequestContent(i);this.fetch(i,r)}fetch(t,e){return this._handlers.setupInput(t),new Promise(((s,i)=>{this._handlers.set(t.requestId,i,s),this.executeConnection(t,e)}))}init(t){this._port=t,this.initConnection(t)}initConnection(t){t.onmessage=this.onInput}async fetchConnection(t){if(!this._port)throw new Error("Fragments: Connection not initialized");return this._port}async executeConnection(t,e){(await this.fetchConnection(t)).postMessage(t,e)}async manageOutput(t){const e=await this.fetchConnection(t);t.toMainThread=!0,e.postMessage(t)}async manageConnection(t){try{await this._handleInput(t)}catch(e){t.errorInfo=e.toString(),console.error(e)}}async manageInput(t){await this.manageConnection(t),await this.manageOutput(t)}}class ls{constructor(t){S(this,"_modelThread",new Map),S(this,"_threadsModelAmount",new Map),S(this,"_threadPort",new Map),S(this,"_threadPath"),S(this,"_placeholder"),this._placeholder={},this._threadPath=t}get path(){return this._threadPath}usePlaceholder(t){this._modelThread.set(t,this._placeholder)}getAmount(t){return this._threadsModelAmount.get(t)}getThread(t){return this._modelThread.get(t)}getAndCheckThread(t){const e=this._modelThread.get(t);if(e===this._placeholder)throw new Error("Fragments: Error fetching thread!");return e}set(t,e){this._modelThread.set(t,e)}deleteModel(t){const e=this.getThreadSafe(t),s=this.getAmountSafe(e)-1;this.setAmount(e,s),this._modelThread.delete(t)}getThreadSafe(t){const e=this.getThread(t);if(!e)throw new Error(`Fragments: Thread for model ${t} not found`);return e}deleteThread(t){this._threadsModelAmount.delete(t),this._threadPort.delete(t),t.terminate()}getThreadAmount(){return this._threadsModelAmount.size}balanceThreadLoad(t){const{lessBusyThread:e,modelAmount:s}=this.getLessBusyThread();return this._threadsModelAmount.set(e,s+1),this._modelThread.set(t.modelId,e),this._threadPort.get(e)}getAmountSafe(t){const e=this.getAmount(t);if(!e)throw new Error(`Fragments: Amount for thread ${t} not found`);return e}setPort(t,e){this._threadPort.set(t,e)}setAmount(t,e){this._threadsModelAmount.set(t,e)}getPort(t){return this._threadPort.get(t)}getLessBusyThread(){let t=Number.MAX_VALUE,e=this._threadsModelAmount.keys().next().value;for(const[s,i]of this._threadsModelAmount)i<t&&(t=i,e=s);return{lessBusyThread:e,modelAmount:t}}}class ds extends hs{constructor(t,e){super(t),S(this,"_data"),this._data=new ls(e)}delete(t){const e=this._data.getThreadSafe(t),s=this._data.getAmountSafe(e)-1;this._data.deleteModel(t),0===s&&this._data.deleteThread(e)}async invoke(t,e,s=[]){const i=cs.getExecuteRequest(t,e,s);return(await this.fetch(i)).result}async fetchConnection(t){const e=this._data.getAndCheckThread(t.modelId);return e?this._data.getPort(e):this.setupNewThread(t)}setupNewThread(t){const e=cs;this._data.usePlaceholder(t.modelId);const s=this._data.getThreadAmount();return e.areCoresAvailable(s)?this.newThread(t,this._data.path):this._data.balanceThreadLoad(t)}setupThread(t){const e=new MessageChannel,s=e.port1,i=e.port2;this.initConnection(s),this._data.setPort(t,s),t.postMessage(i,[i])}newThread(t,e){const s=cs.newThread(e);return this.setupThread(s),this._data.setAmount(s,1),this._data.set(t.modelId,s),this._data.getPort(s)}}class bs{constructor(t){S(this,"onModelLoaded",new v),S(this,"models"),S(this,"settings",{autoCoordinate:!0,maxUpdateRate:100,graphicsQuality:0}),S(this,"baseCoordinates",null),S(this,"_connection"),S(this,"_isDisposed",!1),S(this,"_autoRedrawInterval",null),S(this,"_lastUpdate",0);const e=this.newRequestEvent(),s=this.newUpdateEvent();this._connection=new ds(e,t),this.models=new os(s)}async load(e,s){const i=new is(s.modelId,this.models,this._connection);s.userData&&(i.object.userData=s.userData),i.frozen=!0,i.graphicsQuality=this.settings.graphicsQuality;try{if(this.models.list.set(i.modelId,i),await i._setup(e,s.raw,s.virtualModelConfig),this.settings.autoCoordinate){const e=await i.getCoordinates();if(null===this.baseCoordinates)this.baseCoordinates=e;else{const[s,r,n]=e,[o,a,c]=this.baseCoordinates,h=new t.Vector3(o-s,a-r,c-n);i.object.position.add(h)}}}catch(e){throw this.models.list.delete(i.modelId),e}const{camera:r}=s;return r&&i.useCamera(r),i.frozen=!1,this.onModelLoaded.trigger(i),i}async dispose(){this._isDisposed=!0;const t=Array.from(this.models.list.values()),e=[];for(const s of t)e.push(s.dispose());await Promise.all(e),this.onModelLoaded.reset()}async disposeModel(t){const e=this.models.list.get(t);e&&await e.dispose()}async update(t=!1){if(this._isDisposed)return;const e=performance.now();if(e-this._lastUpdate<this.settings.maxUpdateRate)return;this._lastUpdate=e;const s=[];for(const t of this.models.list.values())s.push(t._refreshView());await Promise.all(s),t?await this.models.forceUpdateFinish():this.models.update()}async manageRequest(t){const e=this.models.list.get(t.modelId);e&&await e.handleRequest(t)}newUpdateEvent(){return()=>{this._autoRedrawInterval&&clearTimeout(this._autoRedrawInterval);const t=this.settings.maxUpdateRate+1;this._autoRedrawInterval=setTimeout((()=>{this.update()}),t)}}newRequestEvent(){return t=>{this.manageRequest(t)}}}
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */function us(t){let e=t.length;for(;--e>=0;)t[e]=0}const fs=256,Is=286,_s=30,ps=15,Es=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),ms=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),Cs=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),gs=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Ts=new Array(576);us(Ts);const As=new Array(60);us(As);const Fs=new Array(512);us(Fs);const Rs=new Array(256);us(Rs);const ys=new Array(29);us(ys);const Os=new Array(_s);function ws(t,e,s,i,r){this.static_tree=t,this.extra_bits=e,this.extra_base=s,this.elems=i,this.max_length=r,this.has_stree=t&&t.length}let Ss,Ns,Ls;function vs(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}us(Os);const xs=t=>t<256?Fs[t]:Fs[256+(t>>>7)],Ps=(t,e)=>{t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255},Ms=(t,e,s)=>{t.bi_valid>16-s?(t.bi_buf|=e<<t.bi_valid&65535,Ps(t,t.bi_buf),t.bi_buf=e>>16-t.bi_valid,t.bi_valid+=s-16):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=s)},Us=(t,e,s)=>{Ms(t,s[2*e],s[2*e+1])},Ds=(t,e)=>{let s=0;do{s|=1&t,t>>>=1,s<<=1}while(--e>0);return s>>>1},Vs=(t,e,s)=>{const i=new Array(16);let r,n,o=0;for(r=1;r<=ps;r++)o=o+s[r-1]<<1,i[r]=o;for(n=0;n<=e;n++){let e=t[2*n+1];0!==e&&(t[2*n]=Ds(i[e]++,e))}},Bs=t=>{let e;for(e=0;e<Is;e++)t.dyn_ltree[2*e]=0;for(e=0;e<_s;e++)t.dyn_dtree[2*e]=0;for(e=0;e<19;e++)t.bl_tree[2*e]=0;t.dyn_ltree[512]=1,t.opt_len=t.static_len=0,t.sym_next=t.matches=0},Gs=t=>{t.bi_valid>8?Ps(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0},zs=(t,e,s,i)=>{const r=2*e,n=2*s;return t[r]<t[n]||t[r]===t[n]&&i[e]<=i[s]},Ys=(t,e,s)=>{const i=t.heap[s];let r=s<<1;for(;r<=t.heap_len&&(r<t.heap_len&&zs(e,t.heap[r+1],t.heap[r],t.depth)&&r++,!zs(e,i,t.heap[r],t.depth));)t.heap[s]=t.heap[r],s=r,r<<=1;t.heap[s]=i},ks=(t,e,s)=>{let i,r,n,o,a=0;if(0!==t.sym_next)do{i=255&t.pending_buf[t.sym_buf+a++],i+=(255&t.pending_buf[t.sym_buf+a++])<<8,r=t.pending_buf[t.sym_buf+a++],0===i?Us(t,r,e):(n=Rs[r],Us(t,n+fs+1,e),o=Es[n],0!==o&&(r-=ys[n],Ms(t,r,o)),i--,n=xs(i),Us(t,n,s),o=ms[n],0!==o&&(i-=Os[n],Ms(t,i,o)))}while(a<t.sym_next);Us(t,256,e)},Hs=(t,e)=>{const s=e.dyn_tree,i=e.stat_desc.static_tree,r=e.stat_desc.has_stree,n=e.stat_desc.elems;let o,a,c,h=-1;for(t.heap_len=0,t.heap_max=573,o=0;o<n;o++)0!==s[2*o]?(t.heap[++t.heap_len]=h=o,t.depth[o]=0):s[2*o+1]=0;for(;t.heap_len<2;)c=t.heap[++t.heap_len]=h<2?++h:0,s[2*c]=1,t.depth[c]=0,t.opt_len--,r&&(t.static_len-=i[2*c+1]);for(e.max_code=h,o=t.heap_len>>1;o>=1;o--)Ys(t,s,o);c=n;do{o=t.heap[1],t.heap[1]=t.heap[t.heap_len--],Ys(t,s,1),a=t.heap[1],t.heap[--t.heap_max]=o,t.heap[--t.heap_max]=a,s[2*c]=s[2*o]+s[2*a],t.depth[c]=(t.depth[o]>=t.depth[a]?t.depth[o]:t.depth[a])+1,s[2*o+1]=s[2*a+1]=c,t.heap[1]=c++,Ys(t,s,1)}while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],((t,e)=>{const s=e.dyn_tree,i=e.max_code,r=e.stat_desc.static_tree,n=e.stat_desc.has_stree,o=e.stat_desc.extra_bits,a=e.stat_desc.extra_base,c=e.stat_desc.max_length;let h,l,d,b,u,f,I=0;for(b=0;b<=ps;b++)t.bl_count[b]=0;for(s[2*t.heap[t.heap_max]+1]=0,h=t.heap_max+1;h<573;h++)l=t.heap[h],b=s[2*s[2*l+1]+1]+1,b>c&&(b=c,I++),s[2*l+1]=b,l>i||(t.bl_count[b]++,u=0,l>=a&&(u=o[l-a]),f=s[2*l],t.opt_len+=f*(b+u),n&&(t.static_len+=f*(r[2*l+1]+u)));if(0!==I){do{for(b=c-1;0===t.bl_count[b];)b--;t.bl_count[b]--,t.bl_count[b+1]+=2,t.bl_count[c]--,I-=2}while(I>0);for(b=c;0!==b;b--)for(l=t.bl_count[b];0!==l;)d=t.heap[--h],d>i||(s[2*d+1]!==b&&(t.opt_len+=(b-s[2*d+1])*s[2*d],s[2*d+1]=b),l--)}})(t,e),Vs(s,h,t.bl_count)},Ws=(t,e,s)=>{let i,r,n=-1,o=e[1],a=0,c=7,h=4;for(0===o&&(c=138,h=3),e[2*(s+1)+1]=65535,i=0;i<=s;i++)r=o,o=e[2*(i+1)+1],++a<c&&r===o||(a<h?t.bl_tree[2*r]+=a:0!==r?(r!==n&&t.bl_tree[2*r]++,t.bl_tree[32]++):a<=10?t.bl_tree[34]++:t.bl_tree[36]++,a=0,n=r,0===o?(c=138,h=3):r===o?(c=6,h=3):(c=7,h=4))},js=(t,e,s)=>{let i,r,n=-1,o=e[1],a=0,c=7,h=4;for(0===o&&(c=138,h=3),i=0;i<=s;i++)if(r=o,o=e[2*(i+1)+1],!(++a<c&&r===o)){if(a<h)do{Us(t,r,t.bl_tree)}while(0!=--a);else 0!==r?(r!==n&&(Us(t,r,t.bl_tree),a--),Us(t,16,t.bl_tree),Ms(t,a-3,2)):a<=10?(Us(t,17,t.bl_tree),Ms(t,a-3,3)):(Us(t,18,t.bl_tree),Ms(t,a-11,7));a=0,n=r,0===o?(c=138,h=3):r===o?(c=6,h=3):(c=7,h=4)}};let qs=!1;const Xs=(t,e,s,i)=>{Ms(t,0+(i?1:0),3),Gs(t),Ps(t,s),Ps(t,~s),s&&t.pending_buf.set(t.window.subarray(e,e+s),t.pending),t.pending+=s};var Zs={_tr_init:t=>{qs||((()=>{let t,e,s,i,r;const n=new Array(16);for(s=0,i=0;i<28;i++)for(ys[i]=s,t=0;t<1<<Es[i];t++)Rs[s++]=i;for(Rs[s-1]=i,r=0,i=0;i<16;i++)for(Os[i]=r,t=0;t<1<<ms[i];t++)Fs[r++]=i;for(r>>=7;i<_s;i++)for(Os[i]=r<<7,t=0;t<1<<ms[i]-7;t++)Fs[256+r++]=i;for(e=0;e<=ps;e++)n[e]=0;for(t=0;t<=143;)Ts[2*t+1]=8,t++,n[8]++;for(;t<=255;)Ts[2*t+1]=9,t++,n[9]++;for(;t<=279;)Ts[2*t+1]=7,t++,n[7]++;for(;t<=287;)Ts[2*t+1]=8,t++,n[8]++;for(Vs(Ts,287,n),t=0;t<_s;t++)As[2*t+1]=5,As[2*t]=Ds(t,5);Ss=new ws(Ts,Es,257,Is,ps),Ns=new ws(As,ms,0,_s,ps),Ls=new ws(new Array(0),Cs,0,19,7)})(),qs=!0),t.l_desc=new vs(t.dyn_ltree,Ss),t.d_desc=new vs(t.dyn_dtree,Ns),t.bl_desc=new vs(t.bl_tree,Ls),t.bi_buf=0,t.bi_valid=0,Bs(t)},_tr_stored_block:Xs,_tr_flush_block:(t,e,s,i)=>{let r,n,o=0;t.level>0?(2===t.strm.data_type&&(t.strm.data_type=(t=>{let e,s=4093624447;for(e=0;e<=31;e++,s>>>=1)if(1&s&&0!==t.dyn_ltree[2*e])return 0;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return 1;for(e=32;e<fs;e++)if(0!==t.dyn_ltree[2*e])return 1;return 0})(t)),Hs(t,t.l_desc),Hs(t,t.d_desc),o=(t=>{let e;for(Ws(t,t.dyn_ltree,t.l_desc.max_code),Ws(t,t.dyn_dtree,t.d_desc.max_code),Hs(t,t.bl_desc),e=18;e>=3&&0===t.bl_tree[2*gs[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e})(t),r=t.opt_len+3+7>>>3,n=t.static_len+3+7>>>3,n<=r&&(r=n)):r=n=s+5,s+4<=r&&-1!==e?Xs(t,e,s,i):4===t.strategy||n===r?(Ms(t,2+(i?1:0),3),ks(t,Ts,As)):(Ms(t,4+(i?1:0),3),((t,e,s,i)=>{let r;for(Ms(t,e-257,5),Ms(t,s-1,5),Ms(t,i-4,4),r=0;r<i;r++)Ms(t,t.bl_tree[2*gs[r]+1],3);js(t,t.dyn_ltree,e-1),js(t,t.dyn_dtree,s-1)})(t,t.l_desc.max_code+1,t.d_desc.max_code+1,o+1),ks(t,t.dyn_ltree,t.dyn_dtree)),Bs(t),i&&Gs(t)},_tr_tally:(t,e,s)=>(t.pending_buf[t.sym_buf+t.sym_next++]=e,t.pending_buf[t.sym_buf+t.sym_next++]=e>>8,t.pending_buf[t.sym_buf+t.sym_next++]=s,0===e?t.dyn_ltree[2*s]++:(t.matches++,e--,t.dyn_ltree[2*(Rs[s]+fs+1)]++,t.dyn_dtree[2*xs(e)]++),t.sym_next===t.sym_end),_tr_align:t=>{Ms(t,2,3),Us(t,256,Ts),(t=>{16===t.bi_valid?(Ps(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)})(t)}};var Ks=(t,e,s,i)=>{let r=65535&t,n=t>>>16&65535,o=0;for(;0!==s;){o=s>2e3?2e3:s,s-=o;do{r=r+e[i++]|0,n=n+r|0}while(--o);r%=65521,n%=65521}return r|n<<16};const $s=new Uint32Array((()=>{let t,e=[];for(var s=0;s<256;s++){t=s;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[s]=t}return e})());var Qs=(t,e,s,i)=>{const r=$s,n=i+s;t^=-1;for(let s=i;s<n;s++)t=t>>>8^r[255&(t^e[s])];return~t},Js={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},ti={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:ei,_tr_stored_block:si,_tr_flush_block:ii,_tr_tally:ri,_tr_align:ni}=Zs,{Z_NO_FLUSH:oi,Z_PARTIAL_FLUSH:ai,Z_FULL_FLUSH:ci,Z_FINISH:hi,Z_BLOCK:li,Z_OK:di,Z_STREAM_END:bi,Z_STREAM_ERROR:ui,Z_DATA_ERROR:fi,Z_BUF_ERROR:Ii,Z_DEFAULT_COMPRESSION:_i,Z_FILTERED:pi,Z_HUFFMAN_ONLY:Ei,Z_RLE:mi,Z_FIXED:Ci,Z_DEFAULT_STRATEGY:gi,Z_UNKNOWN:Ti,Z_DEFLATED:Ai}=ti,Fi=258,Ri=262,yi=42,Oi=113,wi=666,Si=(t,e)=>(t.msg=Js[e],e),Ni=t=>2*t-(t>4?9:0),Li=t=>{let e=t.length;for(;--e>=0;)t[e]=0},vi=t=>{let e,s,i,r=t.w_size;e=t.hash_size,i=e;do{s=t.head[--i],t.head[i]=s>=r?s-r:0}while(--e);e=r,i=e;do{s=t.prev[--i],t.prev[i]=s>=r?s-r:0}while(--e)};let xi=(t,e,s)=>(e<<t.hash_shift^s)&t.hash_mask;const Pi=t=>{const e=t.state;let s=e.pending;s>t.avail_out&&(s=t.avail_out),0!==s&&(t.output.set(e.pending_buf.subarray(e.pending_out,e.pending_out+s),t.next_out),t.next_out+=s,e.pending_out+=s,t.total_out+=s,t.avail_out-=s,e.pending-=s,0===e.pending&&(e.pending_out=0))},Mi=(t,e)=>{ii(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,Pi(t.strm)},Ui=(t,e)=>{t.pending_buf[t.pending++]=e},Di=(t,e)=>{t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e},Vi=(t,e,s,i)=>{let r=t.avail_in;return r>i&&(r=i),0===r?0:(t.avail_in-=r,e.set(t.input.subarray(t.next_in,t.next_in+r),s),1===t.state.wrap?t.adler=Ks(t.adler,e,r,s):2===t.state.wrap&&(t.adler=Qs(t.adler,e,r,s)),t.next_in+=r,t.total_in+=r,r)},Bi=(t,e)=>{let s,i,r=t.max_chain_length,n=t.strstart,o=t.prev_length,a=t.nice_match;const c=t.strstart>t.w_size-Ri?t.strstart-(t.w_size-Ri):0,h=t.window,l=t.w_mask,d=t.prev,b=t.strstart+Fi;let u=h[n+o-1],f=h[n+o];t.prev_length>=t.good_match&&(r>>=2),a>t.lookahead&&(a=t.lookahead);do{if(s=e,h[s+o]===f&&h[s+o-1]===u&&h[s]===h[n]&&h[++s]===h[n+1]){n+=2,s++;do{}while(h[++n]===h[++s]&&h[++n]===h[++s]&&h[++n]===h[++s]&&h[++n]===h[++s]&&h[++n]===h[++s]&&h[++n]===h[++s]&&h[++n]===h[++s]&&h[++n]===h[++s]&&n<b);if(i=Fi-(b-n),n=b-Fi,i>o){if(t.match_start=e,o=i,i>=a)break;u=h[n+o-1],f=h[n+o]}}}while((e=d[e&l])>c&&0!=--r);return o<=t.lookahead?o:t.lookahead},Gi=t=>{const e=t.w_size;let s,i,r;do{if(i=t.window_size-t.lookahead-t.strstart,t.strstart>=e+(e-Ri)&&(t.window.set(t.window.subarray(e,e+e-i),0),t.match_start-=e,t.strstart-=e,t.block_start-=e,t.insert>t.strstart&&(t.insert=t.strstart),vi(t),i+=e),0===t.strm.avail_in)break;if(s=Vi(t.strm,t.window,t.strstart+t.lookahead,i),t.lookahead+=s,t.lookahead+t.insert>=3)for(r=t.strstart-t.insert,t.ins_h=t.window[r],t.ins_h=xi(t,t.ins_h,t.window[r+1]);t.insert&&(t.ins_h=xi(t,t.ins_h,t.window[r+3-1]),t.prev[r&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=r,r++,t.insert--,!(t.lookahead+t.insert<3)););}while(t.lookahead<Ri&&0!==t.strm.avail_in)},zi=(t,e)=>{let s,i,r,n=t.pending_buf_size-5>t.w_size?t.w_size:t.pending_buf_size-5,o=0,a=t.strm.avail_in;do{if(s=65535,r=t.bi_valid+42>>3,t.strm.avail_out<r)break;if(r=t.strm.avail_out-r,i=t.strstart-t.block_start,s>i+t.strm.avail_in&&(s=i+t.strm.avail_in),s>r&&(s=r),s<n&&(0===s&&e!==hi||e===oi||s!==i+t.strm.avail_in))break;o=e===hi&&s===i+t.strm.avail_in?1:0,si(t,0,0,o),t.pending_buf[t.pending-4]=s,t.pending_buf[t.pending-3]=s>>8,t.pending_buf[t.pending-2]=~s,t.pending_buf[t.pending-1]=~s>>8,Pi(t.strm),i&&(i>s&&(i=s),t.strm.output.set(t.window.subarray(t.block_start,t.block_start+i),t.strm.next_out),t.strm.next_out+=i,t.strm.avail_out-=i,t.strm.total_out+=i,t.block_start+=i,s-=i),s&&(Vi(t.strm,t.strm.output,t.strm.next_out,s),t.strm.next_out+=s,t.strm.avail_out-=s,t.strm.total_out+=s)}while(0===o);return a-=t.strm.avail_in,a&&(a>=t.w_size?(t.matches=2,t.window.set(t.strm.input.subarray(t.strm.next_in-t.w_size,t.strm.next_in),0),t.strstart=t.w_size,t.insert=t.strstart):(t.window_size-t.strstart<=a&&(t.strstart-=t.w_size,t.window.set(t.window.subarray(t.w_size,t.w_size+t.strstart),0),t.matches<2&&t.matches++,t.insert>t.strstart&&(t.insert=t.strstart)),t.window.set(t.strm.input.subarray(t.strm.next_in-a,t.strm.next_in),t.strstart),t.strstart+=a,t.insert+=a>t.w_size-t.insert?t.w_size-t.insert:a),t.block_start=t.strstart),t.high_water<t.strstart&&(t.high_water=t.strstart),o?4:e!==oi&&e!==hi&&0===t.strm.avail_in&&t.strstart===t.block_start?2:(r=t.window_size-t.strstart,t.strm.avail_in>r&&t.block_start>=t.w_size&&(t.block_start-=t.w_size,t.strstart-=t.w_size,t.window.set(t.window.subarray(t.w_size,t.w_size+t.strstart),0),t.matches<2&&t.matches++,r+=t.w_size,t.insert>t.strstart&&(t.insert=t.strstart)),r>t.strm.avail_in&&(r=t.strm.avail_in),r&&(Vi(t.strm,t.window,t.strstart,r),t.strstart+=r,t.insert+=r>t.w_size-t.insert?t.w_size-t.insert:r),t.high_water<t.strstart&&(t.high_water=t.strstart),r=t.bi_valid+42>>3,r=t.pending_buf_size-r>65535?65535:t.pending_buf_size-r,n=r>t.w_size?t.w_size:r,i=t.strstart-t.block_start,(i>=n||(i||e===hi)&&e!==oi&&0===t.strm.avail_in&&i<=r)&&(s=i>r?r:i,o=e===hi&&0===t.strm.avail_in&&s===i?1:0,si(t,t.block_start,s,o),t.block_start+=s,Pi(t.strm)),o?3:1)},Yi=(t,e)=>{let s,i;for(;;){if(t.lookahead<Ri){if(Gi(t),t.lookahead<Ri&&e===oi)return 1;if(0===t.lookahead)break}if(s=0,t.lookahead>=3&&(t.ins_h=xi(t,t.ins_h,t.window[t.strstart+3-1]),s=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==s&&t.strstart-s<=t.w_size-Ri&&(t.match_length=Bi(t,s)),t.match_length>=3)if(i=ri(t,t.strstart-t.match_start,t.match_length-3),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=3){t.match_length--;do{t.strstart++,t.ins_h=xi(t,t.ins_h,t.window[t.strstart+3-1]),s=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart}while(0!=--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=xi(t,t.ins_h,t.window[t.strstart+1]);else i=ri(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(Mi(t,!1),0===t.strm.avail_out))return 1}return t.insert=t.strstart<2?t.strstart:2,e===hi?(Mi(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(Mi(t,!1),0===t.strm.avail_out)?1:2},ki=(t,e)=>{let s,i,r;for(;;){if(t.lookahead<Ri){if(Gi(t),t.lookahead<Ri&&e===oi)return 1;if(0===t.lookahead)break}if(s=0,t.lookahead>=3&&(t.ins_h=xi(t,t.ins_h,t.window[t.strstart+3-1]),s=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=2,0!==s&&t.prev_length<t.max_lazy_match&&t.strstart-s<=t.w_size-Ri&&(t.match_length=Bi(t,s),t.match_length<=5&&(t.strategy===pi||3===t.match_length&&t.strstart-t.match_start>4096)&&(t.match_length=2)),t.prev_length>=3&&t.match_length<=t.prev_length){r=t.strstart+t.lookahead-3,i=ri(t,t.strstart-1-t.prev_match,t.prev_length-3),t.lookahead-=t.prev_length-1,t.prev_length-=2;do{++t.strstart<=r&&(t.ins_h=xi(t,t.ins_h,t.window[t.strstart+3-1]),s=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart)}while(0!=--t.prev_length);if(t.match_available=0,t.match_length=2,t.strstart++,i&&(Mi(t,!1),0===t.strm.avail_out))return 1}else if(t.match_available){if(i=ri(t,0,t.window[t.strstart-1]),i&&Mi(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return 1}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=ri(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<2?t.strstart:2,e===hi?(Mi(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(Mi(t,!1),0===t.strm.avail_out)?1:2};function Hi(t,e,s,i,r){this.good_length=t,this.max_lazy=e,this.nice_length=s,this.max_chain=i,this.func=r}const Wi=[new Hi(0,0,0,0,zi),new Hi(4,4,8,4,Yi),new Hi(4,5,16,8,Yi),new Hi(4,6,32,32,Yi),new Hi(4,4,16,16,ki),new Hi(8,16,32,32,ki),new Hi(8,16,128,128,ki),new Hi(8,32,128,256,ki),new Hi(32,128,258,1024,ki),new Hi(32,258,258,4096,ki)];function ji(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Ai,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),Li(this.dyn_ltree),Li(this.dyn_dtree),Li(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),Li(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),Li(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const qi=t=>{if(!t)return 1;const e=t.state;return!e||e.strm!==t||e.status!==yi&&57!==e.status&&69!==e.status&&73!==e.status&&91!==e.status&&103!==e.status&&e.status!==Oi&&e.status!==wi?1:0},Xi=t=>{if(qi(t))return Si(t,ui);t.total_in=t.total_out=0,t.data_type=Ti;const e=t.state;return e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=2===e.wrap?57:e.wrap?yi:Oi,t.adler=2===e.wrap?0:1,e.last_flush=-2,ei(e),di},Zi=t=>{const e=Xi(t);var s;return e===di&&((s=t.state).window_size=2*s.w_size,Li(s.head),s.max_lazy_match=Wi[s.level].max_lazy,s.good_match=Wi[s.level].good_length,s.nice_match=Wi[s.level].nice_length,s.max_chain_length=Wi[s.level].max_chain,s.strstart=0,s.block_start=0,s.lookahead=0,s.insert=0,s.match_length=s.prev_length=2,s.match_available=0,s.ins_h=0),e},Ki=(t,e,s,i,r,n)=>{if(!t)return ui;let o=1;if(e===_i&&(e=6),i<0?(o=0,i=-i):i>15&&(o=2,i-=16),r<1||r>9||s!==Ai||i<8||i>15||e<0||e>9||n<0||n>Ci||8===i&&1!==o)return Si(t,ui);8===i&&(i=9);const a=new ji;return t.state=a,a.strm=t,a.status=yi,a.wrap=o,a.gzhead=null,a.w_bits=i,a.w_size=1<<a.w_bits,a.w_mask=a.w_size-1,a.hash_bits=r+7,a.hash_size=1<<a.hash_bits,a.hash_mask=a.hash_size-1,a.hash_shift=~~((a.hash_bits+3-1)/3),a.window=new Uint8Array(2*a.w_size),a.head=new Uint16Array(a.hash_size),a.prev=new Uint16Array(a.w_size),a.lit_bufsize=1<<r+6,a.pending_buf_size=4*a.lit_bufsize,a.pending_buf=new Uint8Array(a.pending_buf_size),a.sym_buf=a.lit_bufsize,a.sym_end=3*(a.lit_bufsize-1),a.level=e,a.strategy=n,a.method=s,Zi(t)};var $i={deflateInit:(t,e)=>Ki(t,e,Ai,15,8,gi),deflateInit2:Ki,deflateReset:Zi,deflateResetKeep:Xi,deflateSetHeader:(t,e)=>qi(t)||2!==t.state.wrap?ui:(t.state.gzhead=e,di),deflate:(t,e)=>{if(qi(t)||e>li||e<0)return t?Si(t,ui):ui;const s=t.state;if(!t.output||0!==t.avail_in&&!t.input||s.status===wi&&e!==hi)return Si(t,0===t.avail_out?Ii:ui);const i=s.last_flush;if(s.last_flush=e,0!==s.pending){if(Pi(t),0===t.avail_out)return s.last_flush=-1,di}else if(0===t.avail_in&&Ni(e)<=Ni(i)&&e!==hi)return Si(t,Ii);if(s.status===wi&&0!==t.avail_in)return Si(t,Ii);if(s.status===yi&&0===s.wrap&&(s.status=Oi),s.status===yi){let e=Ai+(s.w_bits-8<<4)<<8,i=-1;if(i=s.strategy>=Ei||s.level<2?0:s.level<6?1:6===s.level?2:3,e|=i<<6,0!==s.strstart&&(e|=32),e+=31-e%31,Di(s,e),0!==s.strstart&&(Di(s,t.adler>>>16),Di(s,65535&t.adler)),t.adler=1,s.status=Oi,Pi(t),0!==s.pending)return s.last_flush=-1,di}if(57===s.status)if(t.adler=0,Ui(s,31),Ui(s,139),Ui(s,8),s.gzhead)Ui(s,(s.gzhead.text?1:0)+(s.gzhead.hcrc?2:0)+(s.gzhead.extra?4:0)+(s.gzhead.name?8:0)+(s.gzhead.comment?16:0)),Ui(s,255&s.gzhead.time),Ui(s,s.gzhead.time>>8&255),Ui(s,s.gzhead.time>>16&255),Ui(s,s.gzhead.time>>24&255),Ui(s,9===s.level?2:s.strategy>=Ei||s.level<2?4:0),Ui(s,255&s.gzhead.os),s.gzhead.extra&&s.gzhead.extra.length&&(Ui(s,255&s.gzhead.extra.length),Ui(s,s.gzhead.extra.length>>8&255)),s.gzhead.hcrc&&(t.adler=Qs(t.adler,s.pending_buf,s.pending,0)),s.gzindex=0,s.status=69;else if(Ui(s,0),Ui(s,0),Ui(s,0),Ui(s,0),Ui(s,0),Ui(s,9===s.level?2:s.strategy>=Ei||s.level<2?4:0),Ui(s,3),s.status=Oi,Pi(t),0!==s.pending)return s.last_flush=-1,di;if(69===s.status){if(s.gzhead.extra){let e=s.pending,i=(65535&s.gzhead.extra.length)-s.gzindex;for(;s.pending+i>s.pending_buf_size;){let r=s.pending_buf_size-s.pending;if(s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex,s.gzindex+r),s.pending),s.pending=s.pending_buf_size,s.gzhead.hcrc&&s.pending>e&&(t.adler=Qs(t.adler,s.pending_buf,s.pending-e,e)),s.gzindex+=r,Pi(t),0!==s.pending)return s.last_flush=-1,di;e=0,i-=r}let r=new Uint8Array(s.gzhead.extra);s.pending_buf.set(r.subarray(s.gzindex,s.gzindex+i),s.pending),s.pending+=i,s.gzhead.hcrc&&s.pending>e&&(t.adler=Qs(t.adler,s.pending_buf,s.pending-e,e)),s.gzindex=0}s.status=73}if(73===s.status){if(s.gzhead.name){let e,i=s.pending;do{if(s.pending===s.pending_buf_size){if(s.gzhead.hcrc&&s.pending>i&&(t.adler=Qs(t.adler,s.pending_buf,s.pending-i,i)),Pi(t),0!==s.pending)return s.last_flush=-1,di;i=0}e=s.gzindex<s.gzhead.name.length?255&s.gzhead.name.charCodeAt(s.gzindex++):0,Ui(s,e)}while(0!==e);s.gzhead.hcrc&&s.pending>i&&(t.adler=Qs(t.adler,s.pending_buf,s.pending-i,i)),s.gzindex=0}s.status=91}if(91===s.status){if(s.gzhead.comment){let e,i=s.pending;do{if(s.pending===s.pending_buf_size){if(s.gzhead.hcrc&&s.pending>i&&(t.adler=Qs(t.adler,s.pending_buf,s.pending-i,i)),Pi(t),0!==s.pending)return s.last_flush=-1,di;i=0}e=s.gzindex<s.gzhead.comment.length?255&s.gzhead.comment.charCodeAt(s.gzindex++):0,Ui(s,e)}while(0!==e);s.gzhead.hcrc&&s.pending>i&&(t.adler=Qs(t.adler,s.pending_buf,s.pending-i,i))}s.status=103}if(103===s.status){if(s.gzhead.hcrc){if(s.pending+2>s.pending_buf_size&&(Pi(t),0!==s.pending))return s.last_flush=-1,di;Ui(s,255&t.adler),Ui(s,t.adler>>8&255),t.adler=0}if(s.status=Oi,Pi(t),0!==s.pending)return s.last_flush=-1,di}if(0!==t.avail_in||0!==s.lookahead||e!==oi&&s.status!==wi){let i=0===s.level?zi(s,e):s.strategy===Ei?((t,e)=>{let s;for(;;){if(0===t.lookahead&&(Gi(t),0===t.lookahead)){if(e===oi)return 1;break}if(t.match_length=0,s=ri(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,s&&(Mi(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===hi?(Mi(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(Mi(t,!1),0===t.strm.avail_out)?1:2})(s,e):s.strategy===mi?((t,e)=>{let s,i,r,n;const o=t.window;for(;;){if(t.lookahead<=Fi){if(Gi(t),t.lookahead<=Fi&&e===oi)return 1;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=3&&t.strstart>0&&(r=t.strstart-1,i=o[r],i===o[++r]&&i===o[++r]&&i===o[++r])){n=t.strstart+Fi;do{}while(i===o[++r]&&i===o[++r]&&i===o[++r]&&i===o[++r]&&i===o[++r]&&i===o[++r]&&i===o[++r]&&i===o[++r]&&r<n);t.match_length=Fi-(n-r),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=3?(s=ri(t,1,t.match_length-3),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(s=ri(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),s&&(Mi(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===hi?(Mi(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(Mi(t,!1),0===t.strm.avail_out)?1:2})(s,e):Wi[s.level].func(s,e);if(3!==i&&4!==i||(s.status=wi),1===i||3===i)return 0===t.avail_out&&(s.last_flush=-1),di;if(2===i&&(e===ai?ni(s):e!==li&&(si(s,0,0,!1),e===ci&&(Li(s.head),0===s.lookahead&&(s.strstart=0,s.block_start=0,s.insert=0))),Pi(t),0===t.avail_out))return s.last_flush=-1,di}return e!==hi?di:s.wrap<=0?bi:(2===s.wrap?(Ui(s,255&t.adler),Ui(s,t.adler>>8&255),Ui(s,t.adler>>16&255),Ui(s,t.adler>>24&255),Ui(s,255&t.total_in),Ui(s,t.total_in>>8&255),Ui(s,t.total_in>>16&255),Ui(s,t.total_in>>24&255)):(Di(s,t.adler>>>16),Di(s,65535&t.adler)),Pi(t),s.wrap>0&&(s.wrap=-s.wrap),0!==s.pending?di:bi)},deflateEnd:t=>{if(qi(t))return ui;const e=t.state.status;return t.state=null,e===Oi?Si(t,fi):di},deflateSetDictionary:(t,e)=>{let s=e.length;if(qi(t))return ui;const i=t.state,r=i.wrap;if(2===r||1===r&&i.status!==yi||i.lookahead)return ui;if(1===r&&(t.adler=Ks(t.adler,e,s,0)),i.wrap=0,s>=i.w_size){0===r&&(Li(i.head),i.strstart=0,i.block_start=0,i.insert=0);let t=new Uint8Array(i.w_size);t.set(e.subarray(s-i.w_size,s),0),e=t,s=i.w_size}const n=t.avail_in,o=t.next_in,a=t.input;for(t.avail_in=s,t.next_in=0,t.input=e,Gi(i);i.lookahead>=3;){let t=i.strstart,e=i.lookahead-2;do{i.ins_h=xi(i,i.ins_h,i.window[t+3-1]),i.prev[t&i.w_mask]=i.head[i.ins_h],i.head[i.ins_h]=t,t++}while(--e);i.strstart=t,i.lookahead=2,Gi(i)}return i.strstart+=i.lookahead,i.block_start=i.strstart,i.insert=i.lookahead,i.lookahead=0,i.match_length=i.prev_length=2,i.match_available=0,t.next_in=o,t.input=a,t.avail_in=n,i.wrap=r,di},deflateInfo:"pako deflate (from Nodeca project)"};const Qi=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var Ji=function(t){const e=Array.prototype.slice.call(arguments,1);for(;e.length;){const s=e.shift();if(s){if("object"!=typeof s)throw new TypeError(s+"must be non-object");for(const e in s)Qi(s,e)&&(t[e]=s[e])}}return t},tr=t=>{let e=0;for(let s=0,i=t.length;s<i;s++)e+=t[s].length;const s=new Uint8Array(e);for(let e=0,i=0,r=t.length;e<r;e++){let r=t[e];s.set(r,i),i+=r.length}return s};let er=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(w){er=!1}const sr=new Uint8Array(256);for(let t=0;t<256;t++)sr[t]=t>=252?6:t>=248?5:t>=240?4:t>=224?3:t>=192?2:1;sr[254]=sr[254]=1;var ir=t=>{if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(t);let e,s,i,r,n,o=t.length,a=0;for(r=0;r<o;r++)s=t.charCodeAt(r),55296==(64512&s)&&r+1<o&&(i=t.charCodeAt(r+1),56320==(64512&i)&&(s=65536+(s-55296<<10)+(i-56320),r++)),a+=s<128?1:s<2048?2:s<65536?3:4;for(e=new Uint8Array(a),n=0,r=0;n<a;r++)s=t.charCodeAt(r),55296==(64512&s)&&r+1<o&&(i=t.charCodeAt(r+1),56320==(64512&i)&&(s=65536+(s-55296<<10)+(i-56320),r++)),s<128?e[n++]=s:s<2048?(e[n++]=192|s>>>6,e[n++]=128|63&s):s<65536?(e[n++]=224|s>>>12,e[n++]=128|s>>>6&63,e[n++]=128|63&s):(e[n++]=240|s>>>18,e[n++]=128|s>>>12&63,e[n++]=128|s>>>6&63,e[n++]=128|63&s);return e},rr=(t,e)=>{const s=e||t.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(t.subarray(0,e));let i,r;const n=new Array(2*s);for(r=0,i=0;i<s;){let e=t[i++];if(e<128){n[r++]=e;continue}let o=sr[e];if(o>4)n[r++]=65533,i+=o-1;else{for(e&=2===o?31:3===o?15:7;o>1&&i<s;)e=e<<6|63&t[i++],o--;o>1?n[r++]=65533:e<65536?n[r++]=e:(e-=65536,n[r++]=55296|e>>10&1023,n[r++]=56320|1023&e)}}return((t,e)=>{if(e<65534&&t.subarray&&er)return String.fromCharCode.apply(null,t.length===e?t:t.subarray(0,e));let s="";for(let i=0;i<e;i++)s+=String.fromCharCode(t[i]);return s})(n,r)},nr=(t,e)=>{(e=e||t.length)>t.length&&(e=t.length);let s=e-1;for(;s>=0&&128==(192&t[s]);)s--;return s<0||0===s?e:s+sr[t[s]]>e?s:e};var or=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0};const ar=Object.prototype.toString,{Z_NO_FLUSH:cr,Z_SYNC_FLUSH:hr,Z_FULL_FLUSH:lr,Z_FINISH:dr,Z_OK:br,Z_STREAM_END:ur,Z_DEFAULT_COMPRESSION:fr,Z_DEFAULT_STRATEGY:Ir,Z_DEFLATED:_r}=ti;function pr(t){this.options=Ji({level:fr,method:_r,chunkSize:16384,windowBits:15,memLevel:8,strategy:Ir},t||{});let e=this.options;e.raw&&e.windowBits>0?e.windowBits=-e.windowBits:e.gzip&&e.windowBits>0&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new or,this.strm.avail_out=0;let s=$i.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(s!==br)throw new Error(Js[s]);if(e.header&&$i.deflateSetHeader(this.strm,e.header),e.dictionary){let t;if(t="string"==typeof e.dictionary?ir(e.dictionary):"[object ArrayBuffer]"===ar.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,s=$i.deflateSetDictionary(this.strm,t),s!==br)throw new Error(Js[s]);this._dict_set=!0}}function Er(t,e){const s=new pr(e);if(s.push(t,!0),s.err)throw s.msg||Js[s.err];return s.result}pr.prototype.push=function(t,e){const s=this.strm,i=this.options.chunkSize;let r,n;if(this.ended)return!1;for(n=e===~~e?e:!0===e?dr:cr,"string"==typeof t?s.input=ir(t):"[object ArrayBuffer]"===ar.call(t)?s.input=new Uint8Array(t):s.input=t,s.next_in=0,s.avail_in=s.input.length;;)if(0===s.avail_out&&(s.output=new Uint8Array(i),s.next_out=0,s.avail_out=i),(n===hr||n===lr)&&s.avail_out<=6)this.onData(s.output.subarray(0,s.next_out)),s.avail_out=0;else{if(r=$i.deflate(s,n),r===ur)return s.next_out>0&&this.onData(s.output.subarray(0,s.next_out)),r=$i.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===br;if(0!==s.avail_out){if(n>0&&s.next_out>0)this.onData(s.output.subarray(0,s.next_out)),s.avail_out=0;else if(0===s.avail_in)break}else this.onData(s.output)}return!0},pr.prototype.onData=function(t){this.chunks.push(t)},pr.prototype.onEnd=function(t){t===br&&(this.result=tr(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg};var mr={Deflate:pr,deflate:Er,deflateRaw:function(t,e){return(e=e||{}).raw=!0,Er(t,e)},gzip:function(t,e){return(e=e||{}).gzip=!0,Er(t,e)}};const Cr=16209;var gr=function(t,e){let s,i,r,n,o,a,c,h,l,d,b,u,f,I,_,p,E,m,C,g,T,A,F,R;const y=t.state;s=t.next_in,F=t.input,i=s+(t.avail_in-5),r=t.next_out,R=t.output,n=r-(e-t.avail_out),o=r+(t.avail_out-257),a=y.dmax,c=y.wsize,h=y.whave,l=y.wnext,d=y.window,b=y.hold,u=y.bits,f=y.lencode,I=y.distcode,_=(1<<y.lenbits)-1,p=(1<<y.distbits)-1;t:do{u<15&&(b+=F[s++]<<u,u+=8,b+=F[s++]<<u,u+=8),E=f[b&_];e:for(;;){if(m=E>>>24,b>>>=m,u-=m,m=E>>>16&255,0===m)R[r++]=65535&E;else{if(!(16&m)){if(64&m){if(32&m){y.mode=16191;break t}t.msg="invalid literal/length code",y.mode=Cr;break t}E=f[(65535&E)+(b&(1<<m)-1)];continue e}for(C=65535&E,m&=15,m&&(u<m&&(b+=F[s++]<<u,u+=8),C+=b&(1<<m)-1,b>>>=m,u-=m),u<15&&(b+=F[s++]<<u,u+=8,b+=F[s++]<<u,u+=8),E=I[b&p];;){if(m=E>>>24,b>>>=m,u-=m,m=E>>>16&255,16&m){if(g=65535&E,m&=15,u<m&&(b+=F[s++]<<u,u+=8,u<m&&(b+=F[s++]<<u,u+=8)),g+=b&(1<<m)-1,g>a){t.msg="invalid distance too far back",y.mode=Cr;break t}if(b>>>=m,u-=m,m=r-n,g>m){if(m=g-m,m>h&&y.sane){t.msg="invalid distance too far back",y.mode=Cr;break t}if(T=0,A=d,0===l){if(T+=c-m,m<C){C-=m;do{R[r++]=d[T++]}while(--m);T=r-g,A=R}}else if(l<m){if(T+=c+l-m,m-=l,m<C){C-=m;do{R[r++]=d[T++]}while(--m);if(T=0,l<C){m=l,C-=m;do{R[r++]=d[T++]}while(--m);T=r-g,A=R}}}else if(T+=l-m,m<C){C-=m;do{R[r++]=d[T++]}while(--m);T=r-g,A=R}for(;C>2;)R[r++]=A[T++],R[r++]=A[T++],R[r++]=A[T++],C-=3;C&&(R[r++]=A[T++],C>1&&(R[r++]=A[T++]))}else{T=r-g;do{R[r++]=R[T++],R[r++]=R[T++],R[r++]=R[T++],C-=3}while(C>2);C&&(R[r++]=R[T++],C>1&&(R[r++]=R[T++]))}break}if(64&m){t.msg="invalid distance code",y.mode=Cr;break t}E=I[(65535&E)+(b&(1<<m)-1)]}}break}}while(s<i&&r<o);C=u>>3,s-=C,u-=C<<3,b&=(1<<u)-1,t.next_in=s,t.next_out=r,t.avail_in=s<i?i-s+5:5-(s-i),t.avail_out=r<o?o-r+257:257-(r-o),y.hold=b,y.bits=u};const Tr=15,Ar=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),Fr=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),Rr=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),yr=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);var Or=(t,e,s,i,r,n,o,a)=>{const c=a.bits;let h,l,d,b,u,f,I=0,_=0,p=0,E=0,m=0,C=0,g=0,T=0,A=0,F=0,R=null;const y=new Uint16Array(16),O=new Uint16Array(16);let w,S,N,L=null;for(I=0;I<=Tr;I++)y[I]=0;for(_=0;_<i;_++)y[e[s+_]]++;for(m=c,E=Tr;E>=1&&0===y[E];E--);if(m>E&&(m=E),0===E)return r[n++]=20971520,r[n++]=20971520,a.bits=1,0;for(p=1;p<E&&0===y[p];p++);for(m<p&&(m=p),T=1,I=1;I<=Tr;I++)if(T<<=1,T-=y[I],T<0)return-1;if(T>0&&(0===t||1!==E))return-1;for(O[1]=0,I=1;I<Tr;I++)O[I+1]=O[I]+y[I];for(_=0;_<i;_++)0!==e[s+_]&&(o[O[e[s+_]]++]=_);if(0===t?(R=L=o,f=20):1===t?(R=Ar,L=Fr,f=257):(R=Rr,L=yr,f=0),F=0,_=0,I=p,u=n,C=m,g=0,d=-1,A=1<<m,b=A-1,1===t&&A>852||2===t&&A>592)return 1;for(;;){w=I-g,o[_]+1<f?(S=0,N=o[_]):o[_]>=f?(S=L[o[_]-f],N=R[o[_]-f]):(S=96,N=0),h=1<<I-g,l=1<<C,p=l;do{l-=h,r[u+(F>>g)+l]=w<<24|S<<16|N}while(0!==l);for(h=1<<I-1;F&h;)h>>=1;if(0!==h?(F&=h-1,F+=h):F=0,_++,0==--y[I]){if(I===E)break;I=e[s+o[_]]}if(I>m&&(F&b)!==d){for(0===g&&(g=m),u+=p,C=I-g,T=1<<C;C+g<E&&(T-=y[C+g],!(T<=0));)C++,T<<=1;if(A+=1<<C,1===t&&A>852||2===t&&A>592)return 1;d=F&b,r[d]=m<<24|C<<16|u-n}}return 0!==F&&(r[u+F]=I-g<<24|64<<16),a.bits=m,0};const{Z_FINISH:wr,Z_BLOCK:Sr,Z_TREES:Nr,Z_OK:Lr,Z_STREAM_END:vr,Z_NEED_DICT:xr,Z_STREAM_ERROR:Pr,Z_DATA_ERROR:Mr,Z_MEM_ERROR:Ur,Z_BUF_ERROR:Dr,Z_DEFLATED:Vr}=ti,Br=16180,Gr=16190,zr=16191,Yr=16192,kr=16194,Hr=16199,Wr=16200,jr=16206,qr=16209,Xr=t=>(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24);function Zr(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const Kr=t=>{if(!t)return 1;const e=t.state;return!e||e.strm!==t||e.mode<Br||e.mode>16211?1:0},$r=t=>{if(Kr(t))return Pr;const e=t.state;return t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=1&e.wrap),e.mode=Br,e.last=0,e.havedict=0,e.flags=-1,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new Int32Array(852),e.distcode=e.distdyn=new Int32Array(592),e.sane=1,e.back=-1,Lr},Qr=t=>{if(Kr(t))return Pr;const e=t.state;return e.wsize=0,e.whave=0,e.wnext=0,$r(t)},Jr=(t,e)=>{let s;if(Kr(t))return Pr;const i=t.state;return e<0?(s=0,e=-e):(s=5+(e>>4),e<48&&(e&=15)),e&&(e<8||e>15)?Pr:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=s,i.wbits=e,Qr(t))},tn=(t,e)=>{if(!t)return Pr;const s=new Zr;t.state=s,s.strm=t,s.window=null,s.mode=Br;const i=Jr(t,e);return i!==Lr&&(t.state=null),i};let en,sn,rn=!0;const nn=t=>{if(rn){en=new Int32Array(512),sn=new Int32Array(32);let e=0;for(;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(Or(1,t.lens,0,288,en,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;Or(2,t.lens,0,32,sn,0,t.work,{bits:5}),rn=!1}t.lencode=en,t.lenbits=9,t.distcode=sn,t.distbits=5},on=(t,e,s,i)=>{let r;const n=t.state;return null===n.window&&(n.wsize=1<<n.wbits,n.wnext=0,n.whave=0,n.window=new Uint8Array(n.wsize)),i>=n.wsize?(n.window.set(e.subarray(s-n.wsize,s),0),n.wnext=0,n.whave=n.wsize):(r=n.wsize-n.wnext,r>i&&(r=i),n.window.set(e.subarray(s-i,s-i+r),n.wnext),(i-=r)?(n.window.set(e.subarray(s-i,s),0),n.wnext=i,n.whave=n.wsize):(n.wnext+=r,n.wnext===n.wsize&&(n.wnext=0),n.whave<n.wsize&&(n.whave+=r))),0};var an={inflateReset:Qr,inflateReset2:Jr,inflateResetKeep:$r,inflateInit:t=>tn(t,15),inflateInit2:tn,inflate:(t,e)=>{let s,i,r,n,o,a,c,h,l,d,b,u,f,I,_,p,E,m,C,g,T,A,F=0;const R=new Uint8Array(4);let y,O;const w=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(Kr(t)||!t.output||!t.input&&0!==t.avail_in)return Pr;s=t.state,s.mode===zr&&(s.mode=Yr),o=t.next_out,r=t.output,c=t.avail_out,n=t.next_in,i=t.input,a=t.avail_in,h=s.hold,l=s.bits,d=a,b=c,A=Lr;t:for(;;)switch(s.mode){case Br:if(0===s.wrap){s.mode=Yr;break}for(;l<16;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}if(2&s.wrap&&35615===h){0===s.wbits&&(s.wbits=15),s.check=0,R[0]=255&h,R[1]=h>>>8&255,s.check=Qs(s.check,R,2,0),h=0,l=0,s.mode=16181;break}if(s.head&&(s.head.done=!1),!(1&s.wrap)||(((255&h)<<8)+(h>>8))%31){t.msg="incorrect header check",s.mode=qr;break}if((15&h)!==Vr){t.msg="unknown compression method",s.mode=qr;break}if(h>>>=4,l-=4,T=8+(15&h),0===s.wbits&&(s.wbits=T),T>15||T>s.wbits){t.msg="invalid window size",s.mode=qr;break}s.dmax=1<<s.wbits,s.flags=0,t.adler=s.check=1,s.mode=512&h?16189:zr,h=0,l=0;break;case 16181:for(;l<16;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}if(s.flags=h,(255&s.flags)!==Vr){t.msg="unknown compression method",s.mode=qr;break}if(57344&s.flags){t.msg="unknown header flags set",s.mode=qr;break}s.head&&(s.head.text=h>>8&1),512&s.flags&&4&s.wrap&&(R[0]=255&h,R[1]=h>>>8&255,s.check=Qs(s.check,R,2,0)),h=0,l=0,s.mode=16182;case 16182:for(;l<32;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}s.head&&(s.head.time=h),512&s.flags&&4&s.wrap&&(R[0]=255&h,R[1]=h>>>8&255,R[2]=h>>>16&255,R[3]=h>>>24&255,s.check=Qs(s.check,R,4,0)),h=0,l=0,s.mode=16183;case 16183:for(;l<16;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}s.head&&(s.head.xflags=255&h,s.head.os=h>>8),512&s.flags&&4&s.wrap&&(R[0]=255&h,R[1]=h>>>8&255,s.check=Qs(s.check,R,2,0)),h=0,l=0,s.mode=16184;case 16184:if(1024&s.flags){for(;l<16;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}s.length=h,s.head&&(s.head.extra_len=h),512&s.flags&&4&s.wrap&&(R[0]=255&h,R[1]=h>>>8&255,s.check=Qs(s.check,R,2,0)),h=0,l=0}else s.head&&(s.head.extra=null);s.mode=16185;case 16185:if(1024&s.flags&&(u=s.length,u>a&&(u=a),u&&(s.head&&(T=s.head.extra_len-s.length,s.head.extra||(s.head.extra=new Uint8Array(s.head.extra_len)),s.head.extra.set(i.subarray(n,n+u),T)),512&s.flags&&4&s.wrap&&(s.check=Qs(s.check,i,u,n)),a-=u,n+=u,s.length-=u),s.length))break t;s.length=0,s.mode=16186;case 16186:if(2048&s.flags){if(0===a)break t;u=0;do{T=i[n+u++],s.head&&T&&s.length<65536&&(s.head.name+=String.fromCharCode(T))}while(T&&u<a);if(512&s.flags&&4&s.wrap&&(s.check=Qs(s.check,i,u,n)),a-=u,n+=u,T)break t}else s.head&&(s.head.name=null);s.length=0,s.mode=16187;case 16187:if(4096&s.flags){if(0===a)break t;u=0;do{T=i[n+u++],s.head&&T&&s.length<65536&&(s.head.comment+=String.fromCharCode(T))}while(T&&u<a);if(512&s.flags&&4&s.wrap&&(s.check=Qs(s.check,i,u,n)),a-=u,n+=u,T)break t}else s.head&&(s.head.comment=null);s.mode=16188;case 16188:if(512&s.flags){for(;l<16;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}if(4&s.wrap&&h!==(65535&s.check)){t.msg="header crc mismatch",s.mode=qr;break}h=0,l=0}s.head&&(s.head.hcrc=s.flags>>9&1,s.head.done=!0),t.adler=s.check=0,s.mode=zr;break;case 16189:for(;l<32;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}t.adler=s.check=Xr(h),h=0,l=0,s.mode=Gr;case Gr:if(0===s.havedict)return t.next_out=o,t.avail_out=c,t.next_in=n,t.avail_in=a,s.hold=h,s.bits=l,xr;t.adler=s.check=1,s.mode=zr;case zr:if(e===Sr||e===Nr)break t;case Yr:if(s.last){h>>>=7&l,l-=7&l,s.mode=jr;break}for(;l<3;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}switch(s.last=1&h,h>>>=1,l-=1,3&h){case 0:s.mode=16193;break;case 1:if(nn(s),s.mode=Hr,e===Nr){h>>>=2,l-=2;break t}break;case 2:s.mode=16196;break;case 3:t.msg="invalid block type",s.mode=qr}h>>>=2,l-=2;break;case 16193:for(h>>>=7&l,l-=7&l;l<32;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}if((65535&h)!=(h>>>16^65535)){t.msg="invalid stored block lengths",s.mode=qr;break}if(s.length=65535&h,h=0,l=0,s.mode=kr,e===Nr)break t;case kr:s.mode=16195;case 16195:if(u=s.length,u){if(u>a&&(u=a),u>c&&(u=c),0===u)break t;r.set(i.subarray(n,n+u),o),a-=u,n+=u,c-=u,o+=u,s.length-=u;break}s.mode=zr;break;case 16196:for(;l<14;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}if(s.nlen=257+(31&h),h>>>=5,l-=5,s.ndist=1+(31&h),h>>>=5,l-=5,s.ncode=4+(15&h),h>>>=4,l-=4,s.nlen>286||s.ndist>30){t.msg="too many length or distance symbols",s.mode=qr;break}s.have=0,s.mode=16197;case 16197:for(;s.have<s.ncode;){for(;l<3;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}s.lens[w[s.have++]]=7&h,h>>>=3,l-=3}for(;s.have<19;)s.lens[w[s.have++]]=0;if(s.lencode=s.lendyn,s.lenbits=7,y={bits:s.lenbits},A=Or(0,s.lens,0,19,s.lencode,0,s.work,y),s.lenbits=y.bits,A){t.msg="invalid code lengths set",s.mode=qr;break}s.have=0,s.mode=16198;case 16198:for(;s.have<s.nlen+s.ndist;){for(;F=s.lencode[h&(1<<s.lenbits)-1],_=F>>>24,p=F>>>16&255,E=65535&F,!(_<=l);){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}if(E<16)h>>>=_,l-=_,s.lens[s.have++]=E;else{if(16===E){for(O=_+2;l<O;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}if(h>>>=_,l-=_,0===s.have){t.msg="invalid bit length repeat",s.mode=qr;break}T=s.lens[s.have-1],u=3+(3&h),h>>>=2,l-=2}else if(17===E){for(O=_+3;l<O;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}h>>>=_,l-=_,T=0,u=3+(7&h),h>>>=3,l-=3}else{for(O=_+7;l<O;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}h>>>=_,l-=_,T=0,u=11+(127&h),h>>>=7,l-=7}if(s.have+u>s.nlen+s.ndist){t.msg="invalid bit length repeat",s.mode=qr;break}for(;u--;)s.lens[s.have++]=T}}if(s.mode===qr)break;if(0===s.lens[256]){t.msg="invalid code -- missing end-of-block",s.mode=qr;break}if(s.lenbits=9,y={bits:s.lenbits},A=Or(1,s.lens,0,s.nlen,s.lencode,0,s.work,y),s.lenbits=y.bits,A){t.msg="invalid literal/lengths set",s.mode=qr;break}if(s.distbits=6,s.distcode=s.distdyn,y={bits:s.distbits},A=Or(2,s.lens,s.nlen,s.ndist,s.distcode,0,s.work,y),s.distbits=y.bits,A){t.msg="invalid distances set",s.mode=qr;break}if(s.mode=Hr,e===Nr)break t;case Hr:s.mode=Wr;case Wr:if(a>=6&&c>=258){t.next_out=o,t.avail_out=c,t.next_in=n,t.avail_in=a,s.hold=h,s.bits=l,gr(t,b),o=t.next_out,r=t.output,c=t.avail_out,n=t.next_in,i=t.input,a=t.avail_in,h=s.hold,l=s.bits,s.mode===zr&&(s.back=-1);break}for(s.back=0;F=s.lencode[h&(1<<s.lenbits)-1],_=F>>>24,p=F>>>16&255,E=65535&F,!(_<=l);){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}if(p&&!(240&p)){for(m=_,C=p,g=E;F=s.lencode[g+((h&(1<<m+C)-1)>>m)],_=F>>>24,p=F>>>16&255,E=65535&F,!(m+_<=l);){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}h>>>=m,l-=m,s.back+=m}if(h>>>=_,l-=_,s.back+=_,s.length=E,0===p){s.mode=16205;break}if(32&p){s.back=-1,s.mode=zr;break}if(64&p){t.msg="invalid literal/length code",s.mode=qr;break}s.extra=15&p,s.mode=16201;case 16201:if(s.extra){for(O=s.extra;l<O;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}s.length+=h&(1<<s.extra)-1,h>>>=s.extra,l-=s.extra,s.back+=s.extra}s.was=s.length,s.mode=16202;case 16202:for(;F=s.distcode[h&(1<<s.distbits)-1],_=F>>>24,p=F>>>16&255,E=65535&F,!(_<=l);){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}if(!(240&p)){for(m=_,C=p,g=E;F=s.distcode[g+((h&(1<<m+C)-1)>>m)],_=F>>>24,p=F>>>16&255,E=65535&F,!(m+_<=l);){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}h>>>=m,l-=m,s.back+=m}if(h>>>=_,l-=_,s.back+=_,64&p){t.msg="invalid distance code",s.mode=qr;break}s.offset=E,s.extra=15&p,s.mode=16203;case 16203:if(s.extra){for(O=s.extra;l<O;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}s.offset+=h&(1<<s.extra)-1,h>>>=s.extra,l-=s.extra,s.back+=s.extra}if(s.offset>s.dmax){t.msg="invalid distance too far back",s.mode=qr;break}s.mode=16204;case 16204:if(0===c)break t;if(u=b-c,s.offset>u){if(u=s.offset-u,u>s.whave&&s.sane){t.msg="invalid distance too far back",s.mode=qr;break}u>s.wnext?(u-=s.wnext,f=s.wsize-u):f=s.wnext-u,u>s.length&&(u=s.length),I=s.window}else I=r,f=o-s.offset,u=s.length;u>c&&(u=c),c-=u,s.length-=u;do{r[o++]=I[f++]}while(--u);0===s.length&&(s.mode=Wr);break;case 16205:if(0===c)break t;r[o++]=s.length,c--,s.mode=Wr;break;case jr:if(s.wrap){for(;l<32;){if(0===a)break t;a--,h|=i[n++]<<l,l+=8}if(b-=c,t.total_out+=b,s.total+=b,4&s.wrap&&b&&(t.adler=s.check=s.flags?Qs(s.check,r,b,o-b):Ks(s.check,r,b,o-b)),b=c,4&s.wrap&&(s.flags?h:Xr(h))!==s.check){t.msg="incorrect data check",s.mode=qr;break}h=0,l=0}s.mode=16207;case 16207:if(s.wrap&&s.flags){for(;l<32;){if(0===a)break t;a--,h+=i[n++]<<l,l+=8}if(4&s.wrap&&h!==(4294967295&s.total)){t.msg="incorrect length check",s.mode=qr;break}h=0,l=0}s.mode=16208;case 16208:A=vr;break t;case qr:A=Mr;break t;case 16210:return Ur;default:return Pr}return t.next_out=o,t.avail_out=c,t.next_in=n,t.avail_in=a,s.hold=h,s.bits=l,(s.wsize||b!==t.avail_out&&s.mode<qr&&(s.mode<jr||e!==wr))&&on(t,t.output,t.next_out,b-t.avail_out),d-=t.avail_in,b-=t.avail_out,t.total_in+=d,t.total_out+=b,s.total+=b,4&s.wrap&&b&&(t.adler=s.check=s.flags?Qs(s.check,r,b,t.next_out-b):Ks(s.check,r,b,t.next_out-b)),t.data_type=s.bits+(s.last?64:0)+(s.mode===zr?128:0)+(s.mode===Hr||s.mode===kr?256:0),(0===d&&0===b||e===wr)&&A===Lr&&(A=Dr),A},inflateEnd:t=>{if(Kr(t))return Pr;let e=t.state;return e.window&&(e.window=null),t.state=null,Lr},inflateGetHeader:(t,e)=>{if(Kr(t))return Pr;const s=t.state;return 2&s.wrap?(s.head=e,e.done=!1,Lr):Pr},inflateSetDictionary:(t,e)=>{const s=e.length;let i,r,n;return Kr(t)?Pr:(i=t.state,0!==i.wrap&&i.mode!==Gr?Pr:i.mode===Gr&&(r=1,r=Ks(r,e,s,0),r!==i.check)?Mr:(n=on(t,e,s,s),n?(i.mode=16210,Ur):(i.havedict=1,Lr)))},inflateInfo:"pako inflate (from Nodeca project)"};var cn=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1};const hn=Object.prototype.toString,{Z_NO_FLUSH:ln,Z_FINISH:dn,Z_OK:bn,Z_STREAM_END:un,Z_NEED_DICT:fn,Z_STREAM_ERROR:In,Z_DATA_ERROR:_n,Z_MEM_ERROR:pn}=ti;function En(t){this.options=Ji({chunkSize:65536,windowBits:15,to:""},t||{});const e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(e.windowBits>=0&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&(15&e.windowBits||(e.windowBits|=15)),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new or,this.strm.avail_out=0;let s=an.inflateInit2(this.strm,e.windowBits);if(s!==bn)throw new Error(Js[s]);if(this.header=new cn,an.inflateGetHeader(this.strm,this.header),e.dictionary&&("string"==typeof e.dictionary?e.dictionary=ir(e.dictionary):"[object ArrayBuffer]"===hn.call(e.dictionary)&&(e.dictionary=new Uint8Array(e.dictionary)),e.raw&&(s=an.inflateSetDictionary(this.strm,e.dictionary),s!==bn)))throw new Error(Js[s])}function mn(t,e){const s=new En(e);if(s.push(t),s.err)throw s.msg||Js[s.err];return s.result}En.prototype.push=function(t,e){const s=this.strm,i=this.options.chunkSize,r=this.options.dictionary;let n,o,a;if(this.ended)return!1;for(o=e===~~e?e:!0===e?dn:ln,"[object ArrayBuffer]"===hn.call(t)?s.input=new Uint8Array(t):s.input=t,s.next_in=0,s.avail_in=s.input.length;;){for(0===s.avail_out&&(s.output=new Uint8Array(i),s.next_out=0,s.avail_out=i),n=an.inflate(s,o),n===fn&&r&&(n=an.inflateSetDictionary(s,r),n===bn?n=an.inflate(s,o):n===_n&&(n=fn));s.avail_in>0&&n===un&&s.state.wrap>0&&0!==t[s.next_in];)an.inflateReset(s),n=an.inflate(s,o);switch(n){case In:case _n:case fn:case pn:return this.onEnd(n),this.ended=!0,!1}if(a=s.avail_out,s.next_out&&(0===s.avail_out||n===un))if("string"===this.options.to){let t=nr(s.output,s.next_out),e=s.next_out-t,r=rr(s.output,t);s.next_out=e,s.avail_out=i-e,e&&s.output.set(s.output.subarray(t,t+e),0),this.onData(r)}else this.onData(s.output.length===s.next_out?s.output:s.output.subarray(0,s.next_out));if(n!==bn||0!==a){if(n===un)return n=an.inflateEnd(this.strm),this.onEnd(n),this.ended=!0,!0;if(0===s.avail_in)break}}return!0},En.prototype.onData=function(t){this.chunks.push(t)},En.prototype.onEnd=function(t){t===bn&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=tr(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg};var Cn={Inflate:En,inflate:mn,inflateRaw:function(t,e){return(e=e||{}).raw=!0,mn(t,e)},ungzip:mn};const{Deflate:gn,deflate:Tn,deflateRaw:An,gzip:Fn}=mr,{Inflate:Rn,inflate:yn,inflateRaw:On,ungzip:wn}=Cn;var Sn={Deflate:gn,deflate:Tn,deflateRaw:An,gzip:Fn,Inflate:Rn,inflate:yn,inflateRaw:On,ungzip:wn,constants:ti};class Nn{constructor(t,e){S(this,"_attributesOffsets",[]),S(this,"_relationsMap",{}),S(this,"_guids",[]),S(this,"_guidsItems",[]),S(this,"_ifcApi",null),S(this,"wasm",{path:"/node_modules/web-ifc/",absolute:!1}),S(this,"expressIDs",[]),S(this,"classes",[]),this._serializer=t,this._builder=e}async getIfcApi(){if(!this._ifcApi){const t=new O.IfcAPI;t.SetWasmPath(this.wasm.path,this.wasm.absolute),await t.Init(),t.SetLogLevel(O.LogLevel.LOG_LEVEL_OFF),this._ifcApi=t}return this._ifcApi}async getSchema(t=0){const e=(await this.getIfcApi()).GetModelSchema(t);if(!e)throw new Error("Fragments: IFC Schema not found");return e.startsWith("IFC2X3")?"IFC2X3":e.startsWith("IFC4")&&""===e.replace("IFC4","")?"IFC4":e.startsWith("IFC4X3")?"IFC4X3":e}async process(t){const e=await this.getIfcApi();if(t.readFromCallback)e.OpenModelFromCallback(t.readCallback,{COORDINATE_TO_ORIGIN:!0});else{if(!t.bytes)throw new Error("Fragments: No data provided");await e.OpenModel(t.bytes,{COORDINATE_TO_ORIGIN:!0})}const s=e.GetAllTypesOfModel(0).map((t=>t.typeID)),i=await this.getSchema();if(!O[i])throw new Error("Fragments: Model schema not recognized.");const r=t.geometryProcessedLocalIDs;await this.processItems(r);const n=new Set(r),o=new Set([...this._serializer.classes.abstract,...this._serializer.classes.elements]),a=s.filter((t=>o.has(t)));for(const t of a){const s=e.GetLineIDsWithType(0,t);if(0===s.size())continue;const i=[];for(let t=0;t<s.size();t++){const e=s.get(t);n.has(e)||i.push(e)}await this.processItems(i)}const c=new Set([...this._serializer.relations.keys()]),h=s.filter((t=>c.has(t)));await this.processRelations(h);const{relIndicesVector:l,relsVector:d}=this.getRelationsVector(),{guidsVector:b,guidsItemsVector:u}=this.getGuidsVector(),f=await this.getMetadataOffset(),I=this.getAttributesVector(),_=It.createLocalIdsVector(this._builder,this.expressIDs),p=this.getCategoriesVector(),E=await this.getSpatialStructureOffset();return this.clean(),{relIndicesVector:l,relsVector:d,guidsVector:b,guidsItemsVector:u,metadataOffset:f,attributesVector:I,localIdsVector:_,categoriesVector:p,spatialStrutureOffset:E}}async processItems(t){const e=await this.getIfcApi();for(let s=0;s<t.length;s++){const i=t[s];try{const t=await e.properties.getItemProperties(0,i);if(!t)continue;const s=L[t.type];this.classes.push(s),this.expressIDs.push(i),this.serializeAttributes(i,t)}catch(t){console.log(`Problem reading properties for ${i}`),console.log(t),await new Promise((t=>{setTimeout(t,100)}));continue}}}addRelation(t,e,s){this._relationsMap[t]||(this._relationsMap[t]={}),this._relationsMap[t][e]||(this._relationsMap[t][e]=[]);for(const i of s)this._relationsMap[t][e].push(i)}serializeAttributes(t,e){const s=[];let i=null;for(const[r,n]of Object.entries(e)){if("number"==typeof n)continue;if(this._serializer.attributesToExclude.has(r)||null==n)continue;if(Array.isArray(n)){const e=n.filter((t=>5===t.type)).map((t=>t.value));this.addRelation(t,r,e);continue}const{value:e,type:o}=n;if(5===o){if("number"!=typeof e)continue;this.addRelation(t,r,[e])}else{if("GlobalId"===r&&"string"==typeof e){i=e;continue}const t=[r,e],o="name"in n&&n.name?n.name:n.constructor.name.toUpperCase();t.push("OBJECT"!==o?o:"UNDEFINED");const a=JSON.stringify(t),c=this._builder.createSharedString(a);s.push(c)}}const r=W.createDataVector(this._builder,s),n=W.createAttribute(this._builder,r);this._attributesOffsets.push(n),i&&(this._guids.push(i),this._guidsItems.push(t))}getAttributesVector(){return It.createAttributesVector(this._builder,this._attributesOffsets)}getGuidsVector(){const t=[];for(const e of this._guids){const s=this._builder.createString(e);t.push(s)}return{guidsVector:It.createGuidsVector(this._builder,t),guidsItemsVector:It.createGuidsItemsVector(this._builder,this._guidsItems)}}async processRelations(t){const e=await this.getIfcApi();for(const s of t){const t=this._serializer.relations.get(s);if(!t)continue;const{forRelating:i,forRelated:r}=t,n=e.GetLineIDsWithType(0,s);if(0!==n.size())for(let t=0;t<n.size();t++){const s=n.get(t),o=await e.properties.getItemProperties(0,s);if(!o)continue;const a=Object.keys(o),c=a.find((t=>t.startsWith("Relating"))),h=a.find((t=>t.startsWith("Related")));if(!c||!h)continue;const l=o[c].value,d=o[h].map((({value:t})=>t));this.addRelation(l,i,d);for(const t of d)this.addRelation(t,r,[l])}}}getRelationsVector(t=!1){const e=[],s=[];for(const[i,r]of Object.entries(this._relationsMap)){if(t&&!this.expressIDs.includes(Number(i)))continue;const n=[];for(const[e,s]of Object.entries(r)){let i=s;if(t&&(i=s.filter((t=>this.expressIDs.includes(t))),0===i.length))continue;const r=JSON.stringify([e,...i]),o=this._builder.createSharedString(r);n.push(o)}if(t&&0===n.length)continue;s.push(Number(i));const o=ut.createDataVector(this._builder,n),a=ut.createRelation(this._builder,o);e.push(a)}const i=It.createRelationsVector(this._builder,e);return{relIndicesVector:It.createRelationsItemsVector(this._builder,s),relsVector:i}}getCategoriesVector(){const t=this.classes.map((t=>this._builder.createSharedString(t)));return It.createCategoriesVector(this._builder,t)}async getMetadataOffset(){const t={schema:(await this.getIfcApi()).GetModelSchema(0)};return this._builder.createString(JSON.stringify(t))}getEntityDecomposition(t,e){var s;const i=[];for(const r of e){const n=null==(s=this._relationsMap[t])?void 0:s[r];if(!n)continue;const o={};for(const t of n){const e=this.expressIDs.indexOf(t);if(-1===e)continue;const s=this.classes[e];s&&(o[s]||(o[s]=[]),o[s].push(t))}for(const t in o){const s=o[t].map((t=>this.getEntityDecomposition(t,e))),r=ft.createChildrenVector(this._builder,s),n=this._builder.createSharedString(t);ft.startSpatialStructure(this._builder),ft.addCategory(this._builder,n),ft.addChildren(this._builder,r);const a=ft.endSpatialStructure(this._builder);i.push(a)}}const r=ft.createChildrenVector(this._builder,i);ft.startSpatialStructure(this._builder),ft.addLocalId(this._builder,t),ft.addChildren(this._builder,r);return ft.endSpatialStructure(this._builder)}async getSpatialStructureOffset(){const t=await this.getIfcApi(),e=O.IFCPROJECT,s=[...t.GetLineIDsWithType(0,e)].map((t=>this.getEntityDecomposition(t,["IsDecomposedBy","ContainsElements"]))),i=this._builder.createSharedString("IFCPROJECT"),r=ft.createChildrenVector(this._builder,s);ft.startSpatialStructure(this._builder),ft.addCategory(this._builder,i),ft.addChildren(this._builder,r);return ft.endSpatialStructure(this._builder)}clean(){var t;null==(t=this._ifcApi)||t.Dispose(),this._ifcApi=null,this._guids=[],this._guidsItems=[],this._attributesOffsets=[],this._relationsMap={},this.expressIDs=[],this.classes=[]}}function Ln(t,e){return Math.round(t*e)/e}class vn{constructor(t,e,s,i){S(this,"x"),S(this,"y"),S(this,"z"),S(this,"hash"),S(this,"id"),this.x=Ln(t[3*e],i),this.y=Ln(t[3*e+1],i),this.z=Ln(t[3*e+2],i),this.hash=`${this.x}/${this.y}/${this.z}`,this.id=s}}class xn{constructor(e){S(this,"list",new Map),S(this,"tempV1",new t.Vector3),S(this,"tempV2",new t.Vector3),S(this,"tempV3",new t.Vector3),S(this,"precission"),this.precission=e}create(t,e){const s=new vn(t,e,this.list.size,this.precission);return this.list.has(s.hash)||this.list.set(s.hash,s),this.list.get(s.hash)}get(){return Array.from(this.list.values()).map((t=>[t.x,t.y,t.z]))}isValidTriangle(t,e,s,i){this.tempV1.set(t[3*e],t[3*e+1],t[3*e+2]),this.tempV2.set(t[3*s],t[3*s+1],t[3*s+2]),this.tempV3.set(t[3*i],t[3*i+1],t[3*i+2]);const r=1/this.precission*10,n=this.tempV1.distanceTo(this.tempV2)>r,o=this.tempV1.distanceTo(this.tempV3)>r,a=this.tempV2.distanceTo(this.tempV3)>r;return n&&o&&a}}class Pn{constructor(t,e){S(this,"p1"),S(this,"p2"),S(this,"hash"),this.p1=t,this.p2=e;const s=[this.p1,this.p2];s.sort(((t,e)=>t.x-e.x||t.y-e.y||t.z-e.z)),this.hash=`${s[0].hash}_${s[1].hash}`}}class Mn{constructor(t,e){S(this,"edges",new Map),S(this,"openEdges",new Set),S(this,"id"),S(this,"plane"),this.id=t,this.plane=e}add(t){if(0!==this.edges.size)for(const e of t)this.openEdges.has(e.hash)?this.openEdges.delete(e.hash):this.openEdges.add(e.hash),this.edges.set(e.hash,e);else for(const e of t)this.openEdges.add(e.hash),this.edges.set(e.hash,e)}match(t,e){if(e.id!==this.plane.id)return!1;for(const e of t)if(this.openEdges.has(e.hash))return!0;return!1}getOpenEdges(){const t=[];for(const e of this.openEdges)t.push(this.edges.get(e));return t}merge(t){for(const[e,s]of t.edges)this.edges.set(e,s);for(const e of t.openEdges)this.openEdges.has(e)?this.openEdges.delete(e):this.openEdges.add(e)}}class Un{constructor(){S(this,"list",new Map),S(this,"nextFaceID",0)}add(t,e){const s=this.match(t,e);if(0===s.length){const s=this.nextFaceID++,i=new Mn(s,e);return i.add(t),void this.list.set(i.id,i)}if(1!==s.length){if(s.length>1){const e=this.list.get(s[0]);e.add(t);for(let t=1;t<s.length;t++){const i=s[t],r=this.list.get(i);e.merge(r),this.list.delete(i)}}}else{this.list.get(s[0]).add(t)}}match(t,e){let s=[];for(const i of this.list.values())i.match(t,e)&&s.push(i.id);return s}}class Dn{constructor(t){S(this,"closed",!1),S(this,"openStartPoint",null),S(this,"openEndPoint",null),S(this,"plane"),S(this,"orderedPoints",[]),this.plane=t}getEdges(t=!1){const e=[];if(t)for(let t=this.orderedPoints.length-1;t>0;t--)e.push(new Pn(this.orderedPoints[t],this.orderedPoints[t-1]));else for(let t=0;t<this.orderedPoints.length-1;t++)e.push(new Pn(this.orderedPoints[t],this.orderedPoints[t+1]));return e}getIndices(){return this.orderedPoints.map((t=>t.id))}add(t){if(0===this.orderedPoints.length)return this.openStartPoint=t.p1.hash,this.openEndPoint=t.p2.hash,void this.orderedPoints.push(t.p1,t.p2);const e=this.match(t);if(0===e)throw new Error("Fragments: Edge doesn't match with any open point");if(e>2)throw new Error("Fragments: Edge matches with more than 2 open points");if(2===e)return this.closed=!0,this.openEndPoint=null,void(this.openStartPoint=null);this.openStartPoint===t.p1.hash?(this.orderedPoints.unshift(t.p2),this.openStartPoint=t.p2.hash):this.openEndPoint===t.p1.hash?(this.orderedPoints.push(t.p2),this.openEndPoint=t.p2.hash):this.openStartPoint===t.p2.hash?(this.orderedPoints.unshift(t.p1),this.openStartPoint=t.p1.hash):this.openEndPoint===t.p2.hash&&(this.orderedPoints.push(t.p1),this.openEndPoint=t.p1.hash)}match(t){if(this.closed)return 0;let e=0;return this.openStartPoint===t.p1.hash&&e++,this.openStartPoint===t.p2.hash&&e++,this.openEndPoint===t.p1.hash&&e++,this.openEndPoint===t.p2.hash&&e++,e}merge(t){if(t.closed||this.closed)throw new Error("Fragments: Cannot merge closed profiles");if(t.openStartPoint===this.openEndPoint&&t.openEndPoint===this.openStartPoint)throw new Error("Fragments: Cannot merge profiles that close each other");if(t.openEndPoint===this.openEndPoint&&t.openStartPoint===this.openStartPoint)throw new Error("Fragments: Cannot merge profiles that close each other");let e=!1;t.openEndPoint!==this.openStartPoint&&t.openEndPoint!==this.openEndPoint||(e=!0);const s=t.getEdges(e);for(const t of s)this.add(t)}getArea(){const e=this.orderedPoints.map((t=>[t.x,t.y,t.z]));let s=0,i=1;const r=Math.abs(this.plane.normal.x),n=Math.abs(this.plane.normal.y),o=Math.abs(this.plane.normal.z);r>=n&&r>=o?(s=1,i=2):n>=r&&n>=o?(s=0,i=2):(s=0,i=1);const a=[];for(const r of e)a.push(new t.Vector2(r[s],r[i]));let c=0;for(let t=0,e=a.length;t<e;t++){c+=a[t].x*a[t===a.length-1?0:t+1].y*.5,c-=a[t===a.length-1?0:t+1].x*a[t].y*.5}return Math.abs(c)}}class Vn{constructor(t){S(this,"list",new Map),S(this,"plane"),S(this,"nextProfileID",0),this.plane=t}add(t){const e=this.match(t);if(0===e.length){const e=this.nextProfileID++,s=new Dn(this.plane);return s.add(t),void this.list.set(e,s)}if(1!==e.length){if(e.length>1){const s=this.list.get(e[0]);s.add(t);const i=this.list.get(e[1]);s.merge(i),this.list.delete(e[1])}}else{this.list.get(e[0]).add(t)}}getProfiles(){let t=null,e=0;for(const[s,i]of this.list){const r=i.getArea();r>e&&(e=r,t=s)}if(null===t)return null;const s=this.list.get(t).getIndices(),i=[];for(const[e,s]of this.list)e!==t&&i.push(s.getIndices());return{profile:s,holes:i}}match(t){const e=[];for(const[s,i]of this.list)i.match(t)>0&&e.push(s);return e}}function Bn(t){let e=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let a=0;a<t.length;a+=3){const c=t[a],h=t[a+1],l=t[a+2];c<e&&(e=c),h<s&&(s=h),l<i&&(i=l),c>r&&(r=c),h>n&&(n=h),l>o&&(o=l)}return{min:{x:e,y:s,z:i},max:{x:r,y:n,z:o}}}class Gn{constructor(e,s,i){S(this,"normal"),S(this,"constant"),S(this,"id"),S(this,"faces",[]);const r=Ln(e.normal.x,i),n=Ln(e.normal.y,i),o=Ln(e.normal.z,i),a=Ln(e.constant,s);this.normal=new t.Vector3(r,n,o),this.constant=a;const c="||";this.id=`${r}${c}${n}${c}${o}${c}${a}`}}function zn(e){const{position:s,normals:i,index:r,raw:n}=e,o=Bn(s);if(n)return function(t,e,s){const i=new Map,r=new Map,n=(t,e,s)=>{const r=`${t},${e},${s}`;if(i.has(r))return i.get(r)[0];const n=i.size;return i.set(r,[n,t,e,s]),n};for(let s=0;s<t.length-2;s+=3){const i=t[s],o=t[s+1],a=t[s+2],c=e[3*i],h=e[3*i+1],l=e[3*i+2],d=e[3*o],b=e[3*o+1],u=e[3*o+2],f=e[3*a],I=e[3*a+1],_=e[3*a+2],p=n(c,h,l),E=n(d,b,u),m=n(f,I,_);r.set(r.size,[p,E,m])}const o=[];for(const[,[,t,e,s]]of i)o.push([t,e,s]);return{bbox:s,type:pt.SHELL,profiles:r,holes:new Map,points:o}}(r,s,o);const a=new t.Plane,c=new t.Vector3,h=new t.Vector3,l=new Map;for(let t=0;t<r.length-2;t+=3){const e=r[t];c.set(i[3*e],i[3*e+1],i[3*e+2]),h.set(s[3*e],s[3*e+1],s[3*e+2]),a.setFromNormalAndCoplanarPoint(c,h);const n=new Gn(a,1e3,1e7);l.has(n.id)||l.set(n.id,n),l.get(n.id).faces.push(t)}const d=new xn(1e6),b=new Un;for(const[,t]of l)for(const e of t.faces){const i=r[e],n=r[e+1],o=r[e+2];if(!d.isValidTriangle(s,i,n,o))continue;const a=d.create(s,i),c=d.create(s,n),h=d.create(s,o),l=[new Pn(a,c),new Pn(c,h),new Pn(h,a)];b.add(l,t)}const u=new Map,f=new Map;let I=0;for(const[,t]of b.list){const e=new Vn(t.plane),s=t.getOpenEdges();for(const t of s)e.add(t);const i=e.getProfiles();u.set(I,(null==i?void 0:i.profile)||[]),f.set(I,(null==i?void 0:i.holes)||[]),I++}return{bbox:o,type:pt.SHELL,profiles:u,holes:f,points:d.get()}}class Yn{read(t){try{const e=t.GetAllAlignments(0),s=[];for(const t of e){const e=t.curve3D[0].points;let i=0;const r={absolute:[]};s.push(r);for(let s=0;s<t.horizontal.length;s++){const n=t.horizontal[s],o=this.getCurveType(n.data[1]),a=[];for(const t of n.points){const{x:t,y:s,z:r}=e[i++];a.push(t,s,r)}const c=new Float32Array(a);r.absolute.push({points:c,type:o})}}return s}catch(t){return console.error(t),[]}}getCurveType(t){if(t.includes("CIRCULARARC"))return nt.ELLIPSE_ARC;if(t.includes("LINE")||t.includes("GRADIENT"))return nt.LINES;if(t.includes("CLOTHOID"))return nt.CLOTHOID;if(t.includes("PARABOLICARC"))return nt.PARABOLA;throw new Error(`Fragments: Unknown curve type: ${t}`)}}class kn{constructor(e){S(this,"_ifcAPI",null),S(this,"wasm",{path:"../../../../node_modules/web-ifc/",absolute:!1}),S(this,"_tempObject1",new t.Object3D),S(this,"_tempObject2",new t.Object3D),S(this,"_tempMatrix1",new t.Matrix4),S(this,"_previousGeometries",new Map),S(this,"_previousGeometriesIDs",new Map),S(this,"_previousLocalTransforms",new Map),S(this,"_problematicGeometries",new Set),S(this,"_problematicGeometriesHashes",new Set),S(this,"_coordinatesInitialized",!1),S(this,"_civilReader",new Yn),S(this,"_rawCategories",new Set([O.IFCEARTHWORKSFILL,O.IFCEARTHWORKSCUT])),S(this,"scene",null),S(this,"isolatedMeshes",null),S(this,"onElementLoaded",(()=>{})),S(this,"onGeometryLoaded",(()=>{})),S(this,"onLocalTransformLoaded",(()=>{})),S(this,"onMaxIdFound",(()=>{})),S(this,"onCoordinatesLoaded",(()=>{})),S(this,"onAlignmentsLoaded",(()=>{})),this._serializer=e}async load(t){var e;this._previousGeometriesIDs.clear(),this._ifcAPI=new O.IfcAPI,this._ifcAPI.SetWasmPath(this.wasm.path,this.wasm.absolute),await this._ifcAPI.Init();let s=0;if(t.readFromCallback&&t.readCallback)s=this._ifcAPI.OpenModelFromCallback(t.readCallback,{COORDINATE_TO_ORIGIN:!0});else{if(!t.bytes)throw new Error("Fragments: No data provided");s=await this._ifcAPI.OpenModel(t.bytes,{COORDINATE_TO_ORIGIN:!0})}this._ifcAPI.SetLogLevel(O.LogLevel.LOG_LEVEL_OFF);const i=this._ifcAPI.GetMaxExpressID(s);this.onMaxIdFound(i),this.onLocalTransformLoaded({id:0,data:[0,0,0,1,0,0,0,1,0]});const r=t=>{if(null===this._ifcAPI)throw new Error("Fragments: IfcAPI not initialized");if(!this._coordinatesInitialized){const t=this._ifcAPI.GetCoordinationMatrix(s);this._tempMatrix1.fromArray(t);const e=this.decompose(this._tempMatrix1);this.onCoordinatesLoaded(e),this._coordinatesInitialized=!0}const e=this._ifcAPI.GetLine(0,t.expressID),i={id:t.expressID,type:e.type,guid:e.GlobalId.value,geometries:[]},r=t.geometries.size(),n=t.geometries.get(0).flatTransformation,{transformWithoutScale:o}=this.removeScale(n);for(let e=0;e<r;e++)i.type===O.IFCREINFORCINGBAR?this.loadCircleExtrusionGeometry(s,i,t,e,o.elements):this.loadShellGeometry(s,i,t,e,o.elements);const{dxx:a,dxy:c,dxz:h,dyx:l,dyy:d,dyz:b,px:u,py:f,pz:I}=this.decompose(o);i.geometries.length>0&&this.onElementLoaded({element:i,position:[u,f,I],xDirection:[a,c,h],yDirection:[l,d,b]})};if(null==(e=this.isolatedMeshes)?void 0:e.size)this._ifcAPI.StreamMeshes(s,Array.from(this.isolatedMeshes),r);else for(const t of this._serializer.classes.elements){const e=this._ifcAPI.GetLineIDsWithType(s,t),i=[];for(let t=0;t<e.size();t++)i.push(e.get(t));i.length>0&&(console.log(`${L[t]}: ${i.length}`),this._ifcAPI.StreamMeshes(s,i,r))}const n=this._civilReader.read(this._ifcAPI);this.onAlignmentsLoaded(n),this._ifcAPI.Dispose(),this._ifcAPI=null,this._ifcAPI=new O.IfcAPI,this._ifcAPI.SetWasmPath(this.wasm.path,this.wasm.absolute),await this._ifcAPI.Init(),this._previousGeometries.clear(),this._previousGeometriesIDs.clear(),this._previousLocalTransforms.clear(),this._problematicGeometries.clear(),this._problematicGeometriesHashes.clear()}loadCircleExtrusionGeometry(t,e,s,i,r){if(null===this._ifcAPI)throw new Error("Fragments: IfcAPI not initialized");const n=s.geometries.get(i),o=n.flatTransformation,{units:a}=this.removeScale(o),{x:c,y:h,z:l,w:d}=n.color,b={id:n.geometryExpressID,color:[c,h,l,d],localTransformID:null};e.geometries.push(b);const{transformWithoutScale:u}=this.removeScale(n.flatTransformation);if(this._previousGeometriesIDs.has(b.id))return this.getLocalTransform(r,u,b),void(b.id=this._previousGeometriesIDs.get(b.id));this.getLocalTransform(r,u,b);const f=this._ifcAPI.GetGeometry(t,b.id),I=f.GetSweptDiskSolid(),_=[],p=[],E=I.axis.size();for(let t=0;t<E;t++){const e=I.axis.get(t),s=[];for(let t=0;t<e.arcSegments.size();t++)s.push(e.arcSegments.get(t));_.push(s);const i=[];for(let t=0;t<e.points.size();t++){const s=e.points.get(t);i.push({x:s.x*a,y:s.y*a,z:s.z*a})}p.push(i)}const m=[],C=[],g=[],T=[];for(let t=0;t<p.length;t++){const e=p[t],s=_[t],i=e.length;for(let t=0;t<i-1;t++){let i=-1,r=-1;for(let e=0;e<s.length;e+=2)if(s[e]===t){i=t,r=s[e+1];break}if(-1===i){const s=[],i=e[t],r=e[t+1],n=i.x,o=i.y,a=i.z,c=r.x,h=r.y,l=r.z;m.push(g.length),s.push(n,o,a,c,h,l),g.push(s),C.push($.WIRE)}else{const s=[],n=i,o=Math.round((i+r)/2),a=r,c=e[n],h=e[o],l=e[a],d=this.computeCircleCurveProperties(c,h,l),b=c.x-d.center.x,u=c.y-d.center.y,f=c.z-d.center.z;let I=Math.sqrt(b*b+u*u+f*f);0===I&&(I=1);const _=b/I,p=u/I,E=f/I,g=h.x-d.center.x,A=h.y-d.center.y,F=h.z-d.center.z;let R=Math.sqrt(g*g+A*A+F*F);0===R&&(R=1);const y=g/R,O=A/R,w=F/R;let S=this.crossProduct({x:_,y:p,z:E},{x:y,y:O,z:w});I=Math.sqrt(S.x*S.x+S.y*S.y+S.z*S.z),0===I&&(I=1),S={x:S.x/I,y:S.y/I,z:S.z/I},m.push(T.length),s.push(d.center.x,d.center.y,d.center.z,d.radius,d.angle,_,p,E,S.x,S.y,S.z),T.push(s),C.push($.CIRCLE_CURVE),t=a-1}}}const A=this.getGeometryBuffers(t,n);if(null===A)return console.log(`Zero length geometry: ${b.id}`),e.geometries.pop(),void this._problematicGeometries.add(b.id);const{position:F}=A;for(let t=0;t<F.length;t++)F[t]*=a;const R=Bn(F),y=I.profileRadius*a;this._previousGeometriesIDs.set(b.id,b.id),this.onGeometryLoaded({id:b.id,geometry:{type:pt.CIRCLE_EXTRUSION,units:a,indicesArray:m,typesArray:C,segments:g,circleCurveData:T,radius:y,bbox:R}}),f.delete()}loadShellGeometry(e,s,i,r,n){if(null===this._ifcAPI)throw new Error("Fragments: IfcAPI not initialized");const o=i.geometries.get(r),a=o.flatTransformation,{units:c}=this.removeScale(a);if(this._problematicGeometries.has(o.geometryExpressID))return void console.log(` Problematic geometry: ${o.geometryExpressID}`);const{x:h,y:l,z:d,w:b}=o.color,u={id:o.geometryExpressID,color:[h,l,d,b],localTransformID:null};s.geometries.push(u);const{transformWithoutScale:f}=this.removeScale(o.flatTransformation);if(this._previousGeometriesIDs.has(u.id))return this.getLocalTransform(n,f,u),void(u.id=this._previousGeometriesIDs.get(u.id));const I=this.getGeometryBuffers(e,o);if(null===I)return console.log(`Zero length geometry: ${u.id}`),s.geometries.pop(),void this._problematicGeometries.add(u.id);const{position:_,normals:p,index:E}=I;for(let t=0;t<_.length;t++)_[t]*=c;const m=_.length/3,C=E.length/3;let g=0,T=0;const A=new t.Triangle,F=new t.Vector3,R=new t.Vector3,y=new t.Vector3,O=this.getVolume(E,_),w=new t.Vector3;for(let t=0;t<E.length-2;t+=3){const e=E[t],s=E[t+1],i=E[t+2];F.set(_[3*e],_[3*e+1],_[3*e+2]),R.set(_[3*s],_[3*s+1],_[3*s+2]),y.set(_[3*i],_[3*i+1],_[3*i+2]),w.add(F),w.add(R),w.add(y),A.set(F,R,y);const r=A.getArea();r>g&&(g=r),T+=r}w.divideScalar(E.length),F.set(_[0],_[1],_[2]),R.set(_[3],_[4],_[5]),y.set(_[6],_[7],_[8]);const S=1e4,N=Ln(T,S),L=Ln(g,S),v=Ln(O,S),x=Ln(F.x,S),P=Ln(F.y,S),M=Ln(F.z,S),U=`${m}-${C}-${N}-${L}-${v}-${Ln(w.x,S)}-${Ln(w.x,S)}-${Ln(w.x,S)}-${x}-${P}-${M}`;if(this._problematicGeometriesHashes.has(U))return console.log(`Problematic geometry: ${u.id}`),s.geometries.pop(),this._problematicGeometries.add(u.id),void this._problematicGeometriesHashes.add(U);const D=!this._previousGeometries.has(U),V=o.geometryExpressID;if(D)this._previousGeometries.set(U,o.geometryExpressID),this._previousGeometriesIDs.set(V,V);else{const t=this._previousGeometries.get(U);if(void 0===t)throw new Error("Fragments: Previous geometry not found");this._previousGeometriesIDs.set(V,t),u.id=t}this.getLocalTransform(n,f,u);const B=this._rawCategories.has(s.type);if(D)try{const t=zn({position:_,normals:p,index:E,raw:B});this.onGeometryLoaded({id:u.id,geometry:t})}catch(e){console.error(`Fragments: Problematic geometry: ${u.id}`),s.geometries.pop(),this._problematicGeometries.add(u.id),this._problematicGeometriesHashes.add(U)}}getLocalTransform(t,e,s){this._tempObject1.position.set(0,0,0),this._tempObject1.rotation.set(0,0,0),this._tempObject1.scale.set(1,1,1),this._tempObject1.updateMatrix(),this._tempMatrix1.fromArray(t),this._tempObject1.applyMatrix4(this._tempMatrix1),this._tempObject2.position.set(0,0,0),this._tempObject2.rotation.set(0,0,0),this._tempObject2.scale.set(1,1,1),this._tempObject2.updateMatrix(),this._tempObject2.applyMatrix4(e),this._tempObject1.attach(this._tempObject2);const{px:i,py:r,pz:n,dxx:o,dxy:a,dxz:c,dyx:h,dyy:l,dyz:d}=this.decompose(this._tempObject2.matrix);this._tempObject2.removeFromParent();if(!(0===i&&0===r&&0===n&&1===o&&0===a&&0===c&&0===h&&1===l&&0===d)){const t=`${i}-${r}-${n}-${o}-${a}-${c}-${h}-${l}-${d}`,e=this._previousLocalTransforms.get(t);if(e)s.localTransformID=e.id;else{const e={id:this._previousLocalTransforms.size+1,data:[i,r,n,o,a,c,h,l,d]};this._previousLocalTransforms.set(t,e),s.localTransformID=e.id,this.onLocalTransformLoaded(e)}}}removeScale(e){const s=(new t.Matrix4).fromArray(e),i=new t.Vector3,r=new t.Quaternion,n=new t.Vector3;s.decompose(i,r,n);const o=n.x,a=new t.Matrix4;return a.compose(i,r,new t.Vector3(1,1,1)),{units:o,transformWithoutScale:a}}decompose(t){const e=1e3,s=1e5;return{dxx:Ln(t.elements[0],e),dxy:Ln(t.elements[1],e),dxz:Ln(t.elements[2],e),dyx:Ln(t.elements[4],s),dyy:Ln(t.elements[5],s),dyz:Ln(t.elements[6],s),dzx:Ln(t.elements[8],s),dzy:Ln(t.elements[9],s),dzz:Ln(t.elements[10],s),px:Ln(t.elements[12],s),py:Ln(t.elements[13],s),pz:Ln(t.elements[14],s)}}getVolume(e,s){let i=0;const r=new t.Vector3,n=new t.Vector3,o=new t.Vector3;for(let t=0;t<e.length-2;t+=3){const a=3*e[t],c=3*e[t+1],h=3*e[t+2];r.set(s[a],s[a+1],s[a+2]),n.set(s[c],s[c+1],s[c+2]),o.set(s[h],s[h+1],s[h+2]),i+=this.getSignedVolumeOfTriangle(r,n,o)}return Math.abs(i)}getSignedVolumeOfTriangle(t,e,s){return 1/6*(-(s.x*e.y*t.z)+e.x*s.y*t.z+s.x*t.y*e.z-t.x*s.y*e.z-e.x*t.y*s.z+t.x*e.y*s.z)}getGeometryBuffers(t,e){if(!this._ifcAPI)throw new Error("Fragments: IfcAPI not initialized");const s=this._ifcAPI.GetGeometry(t,e.geometryExpressID),i=this._ifcAPI.GetIndexArray(s.GetIndexData(),s.GetIndexDataSize()),r=this._ifcAPI.GetVertexArray(s.GetVertexData(),s.GetVertexDataSize());if(0===i.length||0===r.length)return s.delete(),null;const n=new Float32Array(r.length/2),o=new Float32Array(r.length/2);for(let t=0;t<r.length;t+=6)n[t/2]=r[t],n[t/2+1]=r[t+1],n[t/2+2]=r[t+2],o[t/2]=r[t+3],o[t/2+1]=r[t+4],o[t/2+2]=r[t+5];return s.delete(),{position:n,normals:o,index:i}}crossProduct(t,e){return{x:t.y*e.z-t.z*e.y,y:t.z*e.x-t.x*e.z,z:t.x*e.y-t.y*e.x}}computeCircleCurveProperties(t,e,s){function i(t,e){return{x:t.x-e.x,y:t.y-e.y,z:t.z-e.z}}function r(t){return Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z)}const n=i(e,t),o=i(s,e),a=this.crossProduct(n,o),c=function(t,e,s){const i=e.x-t.x,r=e.y-t.y,n=e.z-t.z,o=s.x-t.x,a=s.y-t.y,c=s.z-t.z,h=.5*(i**2+r**2+n**2),l=.5*(o**2+a**2+c**2),d=i*a-r*o,b=r*c-n*a,u=n*o-i*c,f=h*o-l*i,I=h*a-l*r,_=h*c-l*n,p=d**2+b**2+u**2;if(0===p)throw new Error("Fragments: Points are collinear, no unique circle exists.");return{x:t.x+(d*I-u*_)/p,y:t.y+(b*_-d*f)/p,z:t.z+(u*f-b*I)/p}}(t,e,s),h=i(t,c),l=i(s,c),d=r(i(c,t)),b=i(t,c),u=r(b);b.x/=u,b.y/=u,b.z/=u;return{center:c,radius:d,normal:a,initialTangent:b,angle:180*Math.acos((h.x*l.x+h.y*l.y+h.z*l.z)/(r(h)*r(l)))/Math.PI}}}class Hn{constructor(t){S(this,"wasm",{path:"../../../../node_modules/web-ifc/",absolute:!1}),this._serializer=t}async process(e){const{builder:s}=e;let i=0;const r=[];let n={dxx:1,dxy:0,dxz:0,dyx:0,dyy:1,dyz:0,px:0,py:0,pz:0};const o=[],a=[],c=[],h=[],l=new Map,d=new Map,b=new Map,u=new kn(this._serializer);u.wasm=this.wasm,u.onGeometryLoaded=t=>{o.push(t)},u.onElementLoaded=t=>{c.push(t)},u.onLocalTransformLoaded=t=>{h.push(t)},u.onCoordinatesLoaded=t=>{n=t},u.onMaxIdFound=t=>{i=t},u.onAlignmentsLoaded=t=>{for(const e of t)a.push(e)},await u.load(e);const f=[];let I=0;bt.startGlobalTransformsVector(s,c.length);const _=new Map,p=[];for(let t=0;t<c.length;t++){const e=c[c.length-1-t];f.push(I++);const{position:i,xDirection:n,yDirection:o}=e,[a,h,d]=i,[b,u,E]=n,[m,C,g]=o;r.push(c[t].element.id);const T=c.length-1-t,A=e.element.type,F=L[A];_.has(F)||_.set(F,_.size),it.createTransform(s,a,h,d,b,u,E,m,C,g),_.get(F),p.unshift(e.element.id),l.set(e.element.id,T)}const E=s.endVector(),m=[];for(let t=0;t<o.length;t++){const e=o[t];if(e.geometry.type!==pt.SHELL)continue;const{points:i,profiles:r,holes:n}=e.geometry;dt.startPointsVector(s,i.length);for(let t=0;t<i.length;t++){const[e,r,n]=i[i.length-1-t];j.createFloatVector(s,e,r,n)}const a=s.endVector(),c=[];for(const[,t]of r){const e=lt.createIndicesVector(s,t),i=lt.createShellProfile(s,e);c.push(i)}const h=dt.createProfilesVector(s,c),l=[];for(const[t,e]of n)for(const i of e){const e=ht.createIndicesVector(s,i),r=ht.createShellHole(s,e,t);l.push(r)}const d=dt.createHolesVector(s,l),b=dt.createShell(s,h,d,a);m.push(b)}const C=bt.createShellsVector(s,m),g=[];for(let t=0;t<o.length;t++){const e=o[t];if(e.geometry.type!==pt.CIRCLE_EXTRUSION)continue;const i=[],{radius:r,indicesArray:n,typesArray:a,segments:c,circleCurveData:h}=e.geometry;K.startCircleCurvesVector(s,h.length);for(let t=0;t<h.length;t++){const[e,i,r,n,o,a,c,l,d,b,u]=h[t];q.createCircleCurve(s,o/360*2*Math.PI,e,i,r,n,d,b,u,a,c,l)}const l=s.endVector();K.startWiresVector(s,c.length);for(let t=0;t<c.length;t++){const[e,i,r,n,o,a]=c[t];X.createWire(s,e,i,r,n,o,a)}const d=s.endVector(),b=K.createOrderVector(s,n),u=K.createPartsVector(s,a);K.startWireSetsVector(s,0);const f=s.endVector();K.startAxis(s),K.addCircleCurves(s,l),K.addOrder(s,b),K.addWires(s,d),K.addWireSets(s,f),K.addParts(s,u);const I=K.endAxis(s);i.push(I);const _=J.createAxesVector(s,i),p=J.createRadiusVector(s,[r]);J.startCircleExtrusion(s),J.addAxes(s,_),J.addRadius(s,p);const E=J.endCircleExtrusion(s);g.push(E)}const T=bt.createCircleExtrusionsVector(s,g);bt.startRepresentationsVector(s,o.length);const A=new Map;for(let t=0;t<o.length;t++){const e=o.length-1-t,s=o[e].geometry.type;let i=A.get(s);void 0===i&&(i=-1),A.set(s,i+1)}const F=new t.Vector3,R=new t.Vector3;for(let t=0;t<o.length;t++){const e=o.length-1-t,i=o[e],{bbox:r}=i.geometry;d.set(i.id,e);const n=i.geometry.type,a=A.get(n);if(void 0===a)throw new Error("Fragments: Malformed geometry definition");A.set(n,a-1),F.set(r.min.x,r.min.y,r.min.z),R.set(r.max.x,r.max.y,r.max.z);F.distanceTo(R)>999999&&(console.log(`Infinity bounding box: ${i.id}`),r.min.x=0,r.min.y=0,r.min.z=0,r.max.x=.1,r.max.y=.1,r.max.z=.1),at.createRepresentation(s,a,r.min.x,r.min.y,r.min.z,r.max.x,r.max.y,r.max.z,i.geometry.type)}const y=s.endVector();let O=0;for(const t of c)for(const e of t.element.geometries){const t=e.color.toString();if(!b.has(t)){const s=e.color.map((t=>255*t));b.set(t,{id:O++,color:s})}}bt.startMaterialsVector(s,b.size);const w=Array.from(b.keys());for(let t=0;t<w.length;t++){const e=w[w.length-1-t],{color:i}=b.get(e),[r,n,o,a]=i;ot.createMaterial(s,r,n,o,a,_t.ONE,0)}const S=s.endVector();let N=0;for(const t of c)N+=t.element.geometries.length;bt.startSamplesVector(s,N);for(let t=0;t<c.length;t++){const e=c[c.length-1-t],i=l.get(e.element.id),r=e.element.geometries;for(let t=0;t<r.length;t++){const e=r[r.length-t-1],n=d.get(e.id),o=b.get(e.color.toString()).id,a=e.localTransformID||0;ct.createSample(s,i,o,n,a)}}const v=s.endVector();bt.startLocalTransformsVector(s,h.length);for(let t=0;t<h.length;t++){const e=h[h.length-1-t],[i,r,n,o,a,c,l,d,b]=e.data;it.createTransform(s,i,r,n,o,a,c,l,d,b)}const x=s.endVector(),P=bt.createMeshesItemsVector(s,f),M=it.createTransform(s,n.px,n.py,n.pz,n.dxx,n.dxy,n.dxz,n.dyx,n.dyy,n.dyz);bt.startMeshes(s),bt.addCoordinates(s,M),bt.addGlobalTransforms(s,E),bt.addShells(s,C),bt.addRepresentations(s,y),bt.addSamples(s,v),bt.addLocalTransforms(s,x),bt.addMaterials(s,S),bt.addCircleExtrusions(s,T),bt.addMeshesItems(s,P);const U=bt.endMeshes(s),D=[],V=new Map;let B=0;for(let t=0;t<a.length;t++){const e=t,i=a[e],r=[];V.set(e,r);for(let t=0;t<i.absolute.length;t++){const e=i.absolute[i.absolute.length-1-t],{points:n}=e;et.startPointsVector(s,n.length/3);for(let t=0;t<n.length-2;t+=3){const e=n[t],i=n[t+1],r=n[t+2];j.createFloatVector(s,e,i,r)}const o=s.endVector();et.startGeometryLines(s),et.addPoints(s,o);const a=et.endGeometryLines(s);D.push(a),r.push(B++)}}const G=rt.createLinesVector(s,D);rt.startSamplesVector(s,B),B--;for(let t=0;t<a.length;t++){const e=a.length-1-t,i=a[e];for(let t=0;t<i.absolute.length;t++){const e=i.absolute[i.absolute.length-1-t],{type:r}=e,n=B--;st.createGeometrySample(s,r,n,0)}}const z=s.endVector();rt.startTransformsVector(s,0);const Y=s.endVector();rt.startGeometries(s),rt.addSamples(s,z),rt.addTransforms(s,Y),rt.addLines(s,G);const k=rt.endGeometries(s),W=[];for(let t=0;t<a.length;t++){const e=V.get(t);if(void 0===e)throw new Error("Fragments: Malformed alignment definition");const i=H.createAbsoluteVector(s,e),r=H.createAlignment(s,i);W.push(r)}const Z=It.createAlignmentsVector(s,W);return{modelMesh:U,localIDs:r,maxLocalID:i,modelGeometries:k,modelAlignments:Z}}}const Wn={base:new Set([O.IFCPROJECT,O.IFCSITE,O.IFCBUILDING,O.IFCBUILDINGSTOREY]),materials:new Set([O.IFCMATERIAL,O.IFCMATERIALCONSTITUENT,O.IFCMATERIALCONSTITUENTSET,O.IFCMATERIALLAYER,O.IFCMATERIALLAYERSET,O.IFCMATERIALLAYERSETUSAGE,O.IFCMATERIALPROFILE,O.IFCMATERIALPROFILESET,O.IFCMATERIALPROFILESETUSAGE]),properties:new Set([O.IFCPROPERTYSET,O.IFCPROPERTYSINGLEVALUE,O.IFCELEMENTQUANTITY,O.IFCQUANTITYAREA,O.IFCQUANTITYCOUNT,O.IFCQUANTITYLENGTH,O.IFCQUANTITYNUMBER,O.IFCQUANTITYTIME,O.IFCQUANTITYVOLUME,O.IFCQUANTITYWEIGHT]),types:new Set([O.IFCBEAMTYPE,O.IFCBEARINGTYPE,O.IFCBUILDINGELEMENTPROXYTYPE,O.IFCCHIMNEYTYPE,O.IFCCOLUMNTYPE,O.IFCCOURSETYPE,O.IFCCOVERINGTYPE,O.IFCCURTAINWALLTYPE,O.IFCDEEPFOUNDATIONTYPE,O.IFCDOORTYPE,O.IFCFOOTINGTYPE,O.IFCKERBTYPE,O.IFCMEMBERTYPE,O.IFCMOORINGDEVICETYPE,O.IFCNAVIGATIONELEMENTTYPE,O.IFCPAVEMENTTYPE,O.IFCPLATETYPE,O.IFCRAILTYPE,O.IFCRAILINGTYPE,O.IFCRAMPFLIGHTTYPE,O.IFCRAMPTYPE,O.IFCROOFTYPE,O.IFCSHADINGDEVICETYPE,O.IFCSLABTYPE,O.IFCSTAIRFLIGHTTYPE,O.IFCSTAIRTYPE,O.IFCTRACKELEMENTTYPE,O.IFCWALLTYPE,O.IFCWINDOWTYPE]),elements:new Set([O.IFCPROJECT,O.IFCSITE,O.IFCBUILDING,O.IFCBUILDINGSTOREY,O.IFCSPACE,O.IFCANNOTATION,O.IFCCONTROLLER,O.IFCBOILER,O.IFCLAMP,O.IFCPUMP,O.IFCAIRTERMINALBOX,O.IFCFLOWINSTRUMENT,O.IFCFURNISHINGELEMENT,O.IFCELECTRICGENERATOR,O.IFCAUDIOVISUALAPPLIANCE,O.IFCPIPEFITTING,O.IFCSTAIR,O.IFCDUCTFITTING,O.IFCMECHANICALFASTENER,O.IFCDOOR,O.IFCELECTRICMOTOR,O.IFCSYSTEMFURNITUREELEMENT,O.IFCEVAPORATOR,O.IFCWINDOWSTANDARDCASE,O.IFCLIGHTFIXTURE,O.IFCUNITARYCONTROLELEMENT,O.IFCCABLECARRIERFITTING,O.IFCCOIL,O.IFCFASTENER,O.IFCFLOWSTORAGEDEVICE,O.IFCPROTECTIVEDEVICE,O.IFCBEAM,O.IFCTANK,O.IFCFILTER,O.IFCCOLUMN,O.IFCELECTRICDISTRIBUTIONBOARD,O.IFCFOOTING,O.IFCCOLUMNSTANDARDCASE,O.IFCVOIDINGFEATURE,O.IFCREINFORCINGBAR,O.IFCFLOWSEGMENT,O.IFCELECTRICTIMECONTROL,O.IFCCABLEFITTING,O.IFCDISTRIBUTIONCHAMBERELEMENT,O.IFCDISTRIBUTIONCONTROLELEMENT,O.IFCMEMBER,O.IFCBUILDINGELEMENTPROXY,O.IFCPLATESTANDARDCASE,O.IFCSWITCHINGDEVICE,O.IFCSHADINGDEVICE,O.IFCDISCRETEACCESSORY,O.IFCDUCTSILENCER,O.IFCSTACKTERMINAL,O.IFCFIRESUPPRESSIONTERMINAL,O.IFCMEDICALDEVICE,O.IFCFURNITURE,O.IFCSLAB,O.IFCTRANSPORTELEMENT,O.IFCAIRTERMINAL,O.IFCENERGYCONVERSIONDEVICE,O.IFCCIVILELEMENT,O.IFCPILE,O.IFCELECTRICAPPLIANCE,O.IFCMEMBERSTANDARDCASE,O.IFCDISTRIBUTIONELEMENT,O.IFCCOVERING,O.IFCSPACEHEATER,O.IFCROOF,O.IFCAIRTOAIRHEATRECOVERY,O.IFCFLOWCONTROLLER,O.IFCHUMIDIFIER,O.IFCJUNCTIONBOX,O.IFCFLOWMETER,O.IFCFLOWTERMINAL,O.IFCRAILING,O.IFCCONDENSER,O.IFCPROTECTIVEDEVICETRIPPINGUNIT,O.IFCREINFORCINGMESH,O.IFCTENDONANCHOR,O.IFCVIBRATIONISOLATOR,O.IFCWALL,O.IFCMOTORCONNECTION,O.IFCVIRTUALELEMENT,O.IFCENGINE,O.IFCBEAMSTANDARDCASE,O.IFCBURNER,O.IFCBUILDINGELEMENTPART,O.IFCRAMP,O.IFCTUBEBUNDLE,O.IFCSLABSTANDARDCASE,O.IFCDISTRIBUTIONFLOWELEMENT,O.IFCSANITARYTERMINAL,O.IFCOPENINGSTANDARDCASE,O.IFCALARM,O.IFCSURFACEFEATURE,O.IFCSLABELEMENTEDCASE,O.IFCFLOWMOVINGDEVICE,O.IFCPLATE,O.IFCCOMMUNICATIONSAPPLIANCE,O.IFCDOORSTANDARDCASE,O.IFCRAMPFLIGHT,O.IFCCHIMNEY,O.IFCWINDOW,O.IFCELECTRICFLOWSTORAGEDEVICE,O.IFCHEATEXCHANGER,O.IFCFAN,O.IFCSOLARDEVICE,O.IFCGEOGRAPHICELEMENT,O.IFCCURTAINWALL,O.IFCFLOWTREATMENTDEVICE,O.IFCWALLSTANDARDCASE,O.IFCDUCTSEGMENT,O.IFCCOMPRESSOR,O.IFCPIPESEGMENT,O.IFCCOOLINGTOWER,O.IFCPROJECTIONELEMENT,O.IFCOUTLET,O.IFCEVAPORATIVECOOLER,O.IFCCABLECARRIERSEGMENT,O.IFCTENDON,O.IFCTRANSFORMER,O.IFCCHILLER,O.IFCDAMPER,O.IFCSENSOR,O.IFCELEMENTASSEMBLY,O.IFCCOOLEDBEAM,O.IFCWALLELEMENTEDCASE,O.IFCINTERCEPTOR,O.IFCVALVE,O.IFCCABLESEGMENT,O.IFCWASTETERMINAL,O.IFCSTAIRFLIGHT,O.IFCFLOWFITTING,O.IFCACTUATOR,O.IFCUNITARYEQUIPMENT,O.IFCGRID,O.IFCBUILTELEMENT,O.IFCCOURSE,O.IFCEARTHWORKSCUT,O.IFCEARTHWORKSFILL,O.IFCTRACKELEMENT,O.IFCRAIL,O.IFCSIGN,O.IFCPAVEMENT])};class jn{constructor(){S(this,"_builder",null),S(this,"wasm",{path:"/node_modules/web-ifc/",absolute:!1}),S(this,"attributesToExclude",new Set(["Representation","ObjectPlacement","CompositionType","OwnerHistory"])),S(this,"relations",new Map([[O.IFCRELDEFINESBYPROPERTIES,{forRelating:"DefinesOcurrence",forRelated:"IsDefinedBy"}],[O.IFCRELASSOCIATESMATERIAL,{forRelated:"HasAssociations",forRelating:"AssociatedTo"}],[O.IFCRELAGGREGATES,{forRelated:"Decomposes",forRelating:"IsDecomposedBy"}],[O.IFCRELCONTAINEDINSPATIALSTRUCTURE,{forRelated:"ContainedInStructure",forRelating:"ContainsElements"}]])),S(this,"classes",{elements:new M([...Wn.elements]),abstract:new M([...Wn.base,...Wn.materials,...Wn.properties])})}get builder(){if(!this._builder)throw new Error("Fragments: Builder not initialized");return this._builder}async process(t){this._builder=new k(1024);const e=new Hn(this);e.wasm=this.wasm;const s={...t,builder:this.builder},i=await e.process(s),{modelMesh:r,maxLocalID:n,localIDs:o,modelGeometries:a,modelAlignments:c}=i,h=new Nn(this,this.builder);h.wasm=this.wasm;const l={...t,geometryProcessedLocalIDs:o},d=await h.process(l),{relIndicesVector:b,relsVector:u,guidsVector:I,guidsItemsVector:_,metadataOffset:p,localIdsVector:E,spatialStrutureOffset:m,attributesVector:C,categoriesVector:g}=d,T=f.generateUUID(),A=this.builder.createString(T);It.startModel(this.builder),It.addMeshes(this.builder,r),It.addMetadata(this.builder,p),It.addAttributes(this.builder,C),It.addLocalIds(this.builder,E),It.addCategories(this.builder,g),It.addRelationsItems(this.builder,b),It.addRelations(this.builder,u),It.addGuidsItems(this.builder,_),It.addGuids(this.builder,I),It.addSpatialStructure(this.builder,m),It.addGuid(this.builder,A),It.addMaxLocalId(this.builder,n),It.addGeometries(this.builder,a),It.addAlignments(this.builder,c);const F=It.endModel(this.builder);this.builder.finish(F);const R=this.builder.asUint8Array();this.clean();return t.raw?R:Sn.deflate(R)}clean(){var t;null==(t=this._builder)||t.clear(),this._builder=null}}class qn extends t.InstancedMesh{constructor(t,e,s,i){if(super(t,e,s),S(this,"fragment"),S(this,"material"),S(this,"geometry"),Array.isArray(e)||(e=[e]),this.material=e,!t.index)throw new Error("The geometry for fragments must be indexed!");this.geometry=t,this.fragment=i;const r=t.index.count;t.groups.length||t.groups.push({start:0,count:r,materialIndex:0})}exportData(){const e=this.geometry.attributes.position.array,s=this.geometry.attributes.normal.array,i=Array.from(this.geometry.index.array),r=[];for(const t of this.geometry.groups){const e=t.materialIndex||0,{start:s,count:i}=t;r.push(s,i,e)}const n=[];if(Array.isArray(this.material))for(const e of this.material){const s=e.opacity,i=e.transparent?1:0,r=new t.Color(e.color).toArray();n.push(s,i,...r)}const o=Array.from(this.instanceMatrix.array);let a;return a=null!==this.instanceColor?Array.from(this.instanceColor.array):[],{position:e,normal:s,index:i,groups:r,materials:n,matrices:o,colors:a}}clone(t){throw new Error("Fragment meshes can't be cloned directly. Use mesh.fragment.clone instead!")}}const Xn=1.25,Zn=65535,Kn=Math.pow(2,-24),$n=Symbol("SKIP_GENERATION");function Qn(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}function Jn(t,e){if(!t.index){const s=t.attributes.position.count,i=function(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(s,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new A(i,1));for(let t=0;t<s;t++)i[t]=t}}function to(t){const e=Qn(t),s=t.drawRange,i=s.start/3,r=(s.start+s.count)/3,n=Math.max(0,i),o=Math.min(e,r)-n;return[{offset:Math.floor(n),count:Math.floor(o)}]}function eo(t){if(!t.groups||!t.groups.length)return to(t);const e=[],s=new Set,i=t.drawRange,r=i.start/3,n=(i.start+i.count)/3;for(const e of t.groups){const t=e.start/3,i=(e.start+e.count)/3;s.add(Math.max(r,t)),s.add(Math.min(n,i))}const o=Array.from(s.values()).sort(((t,e)=>t-e));for(let t=0;t<o.length-1;t++){const s=o[t],i=o[t+1];e.push({offset:Math.floor(s),count:Math.floor(i-s)})}return e}function so(t,e,s){return s.min.x=e[t],s.min.y=e[t+1],s.min.z=e[t+2],s.max.x=e[t+3],s.max.y=e[t+4],s.max.z=e[t+5],s}function io(t){let e=-1,s=-1/0;for(let i=0;i<3;i++){const r=t[i+3]-t[i];r>s&&(s=r,e=i)}return e}function ro(t,e){e.set(t)}function no(t,e,s){let i,r;for(let n=0;n<3;n++){const o=n+3;i=t[n],r=e[n],s[n]=i<r?i:r,i=t[o],r=e[o],s[o]=i>r?i:r}}function oo(t,e,s){for(let i=0;i<3;i++){const r=e[t+2*i],n=e[t+2*i+1],o=r-n,a=r+n;o<s[i]&&(s[i]=o),a>s[i+3]&&(s[i+3]=a)}}function ao(t){const e=t[3]-t[0],s=t[4]-t[1],i=t[5]-t[2];return 2*(e*s+s*i+i*e)}function co(t,e,s,i,r=null){let n=1/0,o=1/0,a=1/0,c=-1/0,h=-1/0,l=-1/0,d=1/0,b=1/0,u=1/0,f=-1/0,I=-1/0,_=-1/0;const p=null!==r;for(let i=6*e,r=6*(e+s);i<r;i+=6){const e=t[i+0],s=t[i+1],r=e-s,E=e+s;r<n&&(n=r),E>c&&(c=E),p&&e<d&&(d=e),p&&e>f&&(f=e);const m=t[i+2],C=t[i+3],g=m-C,T=m+C;g<o&&(o=g),T>h&&(h=T),p&&m<b&&(b=m),p&&m>I&&(I=m);const A=t[i+4],F=t[i+5],R=A-F,y=A+F;R<a&&(a=R),y>l&&(l=y),p&&A<u&&(u=A),p&&A>_&&(_=A)}i[0]=n,i[1]=o,i[2]=a,i[3]=c,i[4]=h,i[5]=l,p&&(r[0]=d,r[1]=b,r[2]=u,r[3]=f,r[4]=I,r[5]=_)}const ho=32,lo=(t,e)=>t.candidate-e.candidate,bo=new Array(ho).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),uo=new Float32Array(6);class fo{constructor(){}}function Io(t,e,s,i,r,n){let o=i,a=i+r-1;const c=n.pos,h=2*n.axis;for(;;){for(;o<=a&&s[6*o+h]<c;)o++;for(;o<=a&&s[6*a+h]>=c;)a--;if(!(o<a))return o;for(let t=0;t<3;t++){let s=e[3*o+t];e[3*o+t]=e[3*a+t],e[3*a+t]=s}for(let t=0;t<6;t++){let e=s[6*o+t];s[6*o+t]=s[6*a+t],s[6*a+t]=e}o++,a--}}function _o(t,e,s,i,r,n){let o=i,a=i+r-1;const c=n.pos,h=2*n.axis;for(;;){for(;o<=a&&s[6*o+h]<c;)o++;for(;o<=a&&s[6*a+h]>=c;)a--;if(!(o<a))return o;{let e=t[o];t[o]=t[a],t[a]=e;for(let t=0;t<6;t++){let e=s[6*o+t];s[6*o+t]=s[6*a+t],s[6*a+t]=e}o++,a--}}}function po(t,e){const s=t.geometry,i=s.index?s.index.array:null,r=e.maxDepth,n=e.verbose,o=e.maxLeafTris,a=e.strategy,c=e.onProgress,h=Qn(s),l=t._indirectBuffer;let d=!1;const b=new Float32Array(6),u=new Float32Array(6),f=function(t,e){var s;(s=e)[0]=s[1]=s[2]=1/0,s[3]=s[4]=s[5]=-1/0;const i=t.attributes.position,r=t.index?t.index.array:null,n=Qn(t),o=new Float32Array(6*n),a=i.normalized,c=i.array,h=i.offset||0;let l=3;i.isInterleavedBufferAttribute&&(l=i.data.stride);const d=["getX","getY","getZ"];for(let t=0;t<n;t++){const s=3*t,n=6*t;let b=s+0,u=s+1,f=s+2;r&&(b=r[b],u=r[u],f=r[f]),a||(b=b*l+h,u=u*l+h,f=f*l+h);for(let t=0;t<3;t++){let s,r,h;a?(s=i[d[t]](b),r=i[d[t]](u),h=i[d[t]](f)):(s=c[b+t],r=c[u+t],h=c[f+t]);let l=s;r<l&&(l=r),h<l&&(l=h);let I=s;r>I&&(I=r),h>I&&(I=h);const _=(I-l)/2,p=2*t;o[n+p+0]=l+_,o[n+p+1]=_+(Math.abs(l)+_)*Kn,l<e[t]&&(e[t]=l),I>e[t+3]&&(e[t+3]=I)}}return o}(s,b),I=e.indirect?_o:Io,_=[],p=e.indirect?to(s):eo(s);if(1===p.length){const t=p[0],e=new fo;e.boundingData=b,function(t,e,s,i){let r=1/0,n=1/0,o=1/0,a=-1/0,c=-1/0,h=-1/0;for(let i=6*e,l=6*(e+s);i<l;i+=6){const e=t[i+0];e<r&&(r=e),e>a&&(a=e);const s=t[i+2];s<n&&(n=s),s>c&&(c=s);const l=t[i+4];l<o&&(o=l),l>h&&(h=l)}i[0]=r,i[1]=n,i[2]=o,i[3]=a,i[4]=c,i[5]=h}(f,t.offset,t.count,u),m(e,t.offset,t.count,u),_.push(e)}else for(let t of p){const e=new fo;e.boundingData=new Float32Array(6),co(f,t.offset,t.count,e.boundingData,u),m(e,t.offset,t.count,u),_.push(e)}return _;function E(t){c&&c(t/h)}function m(t,e,c,h=null,b=0){if(!d&&b>=r&&(d=!0,n&&(console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`),console.warn(s))),c<=o||b>=r)return E(e+c),t.offset=e,t.count=c,t;const _=function(t,e,s,i,r,n){let o=-1,a=0;if(0===n)o=io(e),-1!==o&&(a=(e[o]+e[o+3])/2);else if(1===n)o=io(t),-1!==o&&(a=function(t,e,s,i){let r=0;for(let n=e,o=e+s;n<o;n++)r+=t[6*n+2*i];return r/s}(s,i,r,o));else if(2===n){const n=ao(t);let c=Xn*r;const h=6*i,l=6*(i+r);for(let t=0;t<3;t++){const i=e[t],d=(e[t+3]-i)/ho;if(r<8){const e=[...bo];e.length=r;let i=0;for(let r=h;r<l;r+=6,i++){const n=e[i];n.candidate=s[r+2*t],n.count=0;const{bounds:o,leftCacheBounds:a,rightCacheBounds:c}=n;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,o[t]=1/0,o[t+3]=-1/0;oo(r,s,o)}e.sort(lo);let d=r;for(let t=0;t<d;t++){const s=e[t];for(;t+1<d&&e[t+1].candidate===s.candidate;)e.splice(t+1,1),d--}for(let i=h;i<l;i+=6){const r=s[i+2*t];for(let t=0;t<d;t++){const n=e[t];r>=n.candidate?oo(i,s,n.rightCacheBounds):(oo(i,s,n.leftCacheBounds),n.count++)}}for(let s=0;s<d;s++){const i=e[s],h=i.count,l=r-i.count,d=i.leftCacheBounds,b=i.rightCacheBounds;let u=0;0!==h&&(u=ao(d)/n);let f=0;0!==l&&(f=ao(b)/n);const I=1+Xn*(u*h+f*l);I<c&&(o=t,c=I,a=i.candidate)}}else{for(let t=0;t<ho;t++){const e=bo[t];e.count=0,e.candidate=i+d+t*d;const s=e.bounds;for(let t=0;t<3;t++)s[t]=1/0,s[t+3]=-1/0}for(let e=h;e<l;e+=6){let r=~~((s[e+2*t]-i)/d);r>=ho&&(r=31);const n=bo[r];n.count++,oo(e,s,n.bounds)}const e=bo[31];ro(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=bo[t],s=bo[t+1];no(e.bounds,s.rightCacheBounds,e.rightCacheBounds)}let b=0;for(let e=0;e<31;e++){const s=bo[e],i=s.count,h=s.bounds,l=bo[e+1].rightCacheBounds;0!==i&&(0===b?ro(h,uo):no(h,uo,uo)),b+=i;let d=0,u=0;0!==b&&(d=ao(uo)/n);const f=r-b;0!==f&&(u=ao(l)/n);const I=1+Xn*(d*b+u*f);I<c&&(o=t,c=I,a=s.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${n} used.`);return{axis:o,pos:a}}(t.boundingData,h,f,e,c,a);if(-1===_.axis)return E(e+c),t.offset=e,t.count=c,t;const p=I(l,i,f,e,c,_);if(p===e||p===e+c)E(e+c),t.offset=e,t.count=c;else{t.splitAxis=_.axis;const s=new fo,i=e,r=p-e;t.left=s,s.boundingData=new Float32Array(6),co(f,i,r,s.boundingData,u),m(s,i,r,u,b+1);const n=new fo,o=p,a=c-r;t.right=n,n.boundingData=new Float32Array(6),co(f,o,a,n.boundingData,u),m(n,o,a,u,b+1)}return t}}function Eo(t,e){const s=t.geometry;e.indirect&&(t._indirectBuffer=function(t,e){const s=(t.index?t.index.count:t.attributes.position.count)/3,i=s>65536,r=i?4:2,n=e?new SharedArrayBuffer(s*r):new ArrayBuffer(s*r),o=i?new Uint32Array(n):new Uint16Array(n);for(let t=0,e=o.length;t<e;t++)o[t]=t;return o}(s,e.useSharedArrayBuffer),function(t){if(0===t.groups.length)return!1;const e=Qn(t),s=eo(t).sort(((t,e)=>t.offset-e.offset)),i=s[s.length-1];i.count=Math.min(e-i.offset,i.count);let r=0;return s.forEach((({count:t})=>r+=t)),e!==r}(s)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||Jn(s,e);const i=po(t,e);let r,n,o;const a=[],c=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let t=0;t<i.length;t++){const e=i[t];const s=new c(32*h(e));r=new Float32Array(s),n=new Uint32Array(s),o=new Uint16Array(s),l(0,e),a.push(s)}return void(t._roots=a);function h(t){return t.count?1:1+h(t.left)+h(t.right)}function l(t,e){const s=t/4,i=t/2,a=!!e.count,c=e.boundingData;for(let t=0;t<6;t++)r[s+t]=c[t];if(a){const r=e.offset,a=e.count;return n[s+6]=r,o[i+14]=a,o[i+15]=Zn,t+32}{const i=e.left,r=e.right,o=e.splitAxis;let a;if(a=l(t+32,i),a/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return n[s+6]=a/4,a=l(a,r),n[s+7]=o,a}}}class mo{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let r=0,n=t.length;r<n;r++){const n=t[r][e];s=n<s?n:s,i=n>i?n:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let r=0,n=e.length;r<n;r++){const n=e[r],o=t.dot(n);s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}mo.prototype.setFromBox=function(){const t=new s;return function(e,s){const i=s.min,r=s.max;let n=1/0,o=-1/0;for(let s=0;s<=1;s++)for(let a=0;a<=1;a++)for(let c=0;c<=1;c++){t.x=i.x*s+r.x*(1-s),t.y=i.y*a+r.y*(1-a),t.z=i.z*c+r.z*(1-c);const h=e.dot(t);n=Math.min(h,n),o=Math.max(h,o)}this.min=n,this.max=o}}();const Co=function(){const t=new s,e=new s,i=new s;return function(s,r,n){const o=s.start,a=t,c=r.start,h=e;i.subVectors(o,c),t.subVectors(s.end,s.start),e.subVectors(r.end,r.start);const l=i.dot(h),d=h.dot(a),b=h.dot(h),u=i.dot(a),f=a.dot(a)*b-d*d;let I,_;I=0!==f?(l*d-u*b)/f:0,_=(l+I*d)/b,n.x=I,n.y=_}}(),go=function(){const t=new r,e=new s,i=new s;return function(s,r,n,o){Co(s,r,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return s.at(a,n),void r.at(c,o);if(a>=0&&a<=1)return c<0?r.at(0,o):r.at(1,o),void s.closestPointToPoint(o,!0,n);if(c>=0&&c<=1)return a<0?s.at(0,n):s.at(1,n),void r.closestPointToPoint(n,!0,o);{let t,h;t=a<0?s.start:s.end,h=c<0?r.start:r.end;const l=e,d=i;return s.closestPointToPoint(h,!0,e),r.closestPointToPoint(t,!0,i),l.distanceToSquared(h)<=d.distanceToSquared(t)?(n.copy(l),void o.copy(h)):(n.copy(t),void o.copy(d))}}}(),To=function(){const t=new s,e=new s,i=new d,r=new h;return function(s,n){const{radius:o,center:a}=s,{a:c,b:h,c:l}=n;r.start=c,r.end=h;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;r.start=c,r.end=l;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;r.start=h,r.end=l;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;const d=n.getPlane(i);if(Math.abs(d.distanceToPoint(a))<=o){const t=d.projectPoint(a,e);if(n.containsPoint(t))return!0}return!1}}();function Ao(t){return Math.abs(t)<1e-15}class Fo extends I{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new s)),this.satBounds=new Array(4).fill().map((()=>new mo)),this.points=[this.a,this.b,this.c],this.sphere=new l,this.plane=new d,this.needsUpdate=!0}intersectsSphere(t){return To(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,r=this.satAxes,n=this.satBounds,o=r[0],a=n[0];this.getNormal(o),a.setFromPoints(o,i);const c=r[1],h=n[1];c.subVectors(t,e),h.setFromPoints(c,i);const l=r[2],d=n[2];l.subVectors(e,s),d.setFromPoints(l,i);const b=r[3],u=n[3];b.subVectors(s,t),u.setFromPoints(b,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,t),this.needsUpdate=!1}}Fo.prototype.closestPointToSegment=function(){const t=new s,e=new s,i=new h;return function(s,r=null,n=null){const{start:o,end:a}=s,c=this.points;let h,l=1/0;for(let o=0;o<3;o++){const a=(o+1)%3;i.start.copy(c[o]),i.end.copy(c[a]),go(i,s,t,e),h=t.distanceToSquared(e),h<l&&(l=h,r&&r.copy(t),n&&n.copy(e))}return this.closestPointToPoint(o,t),h=o.distanceToSquared(t),h<l&&(l=h,r&&r.copy(t),n&&n.copy(o)),this.closestPointToPoint(a,t),h=a.distanceToSquared(t),h<l&&(l=h,r&&r.copy(t),n&&n.copy(a)),Math.sqrt(l)}}(),Fo.prototype.intersectsTriangle=function(){const t=new Fo,e=new Array(3),i=new Array(3),r=new mo,n=new mo,o=new s,a=new s,c=new s,l=new s,d=new s,b=new h,u=new h,f=new h,I=new s;function _(t,e,s){const i=t.points;let r=0,n=-1;for(let t=0;t<3;t++){const{start:o,end:c}=b;o.copy(i[t]),c.copy(i[(t+1)%3]),b.delta(a);const h=Ao(e.distanceToPoint(o));if(Ao(e.normal.dot(a))&&h){s.copy(b),r=2;break}const l=e.intersectLine(b,I);if(!l&&h&&I.copy(o),(l||h)&&!Ao(I.distanceTo(c))){if(r<=1){(1===r?s.start:s.end).copy(I),h&&(n=r)}else if(r>=2){(1===n?s.start:s.end).copy(I),r=2;break}if(r++,2===r&&-1===n)break}}return r}return function(s,a=null,h=!1){this.needsUpdate&&this.update(),s.isExtendedTriangle?s.needsUpdate&&s.update():(t.copy(s),t.update(),s=t);const b=this.plane,I=s.plane;if(Math.abs(b.normal.dot(I.normal))>1-1e-10){const t=this.satBounds,c=this.satAxes;i[0]=s.a,i[1]=s.b,i[2]=s.c;for(let e=0;e<4;e++){const s=t[e],n=c[e];if(r.setFromPoints(n,i),s.isSeparated(r))return!1}const l=s.satBounds,d=s.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const s=l[t],i=d[t];if(r.setFromPoints(i,e),s.isSeparated(r))return!1}for(let t=0;t<4;t++){const s=c[t];for(let t=0;t<4;t++){const a=d[t];if(o.crossVectors(s,a),r.setFromPoints(o,e),n.setFromPoints(o,i),r.isSeparated(n))return!1}}return a&&(h||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),a.start.set(0,0,0),a.end.set(0,0,0)),!0}{const t=_(this,I,u);if(1===t&&s.containsPoint(u.end))return a&&(a.start.copy(u.end),a.end.copy(u.end)),!0;if(2!==t)return!1;const e=_(s,b,f);if(1===e&&this.containsPoint(f.end))return a&&(a.start.copy(f.end),a.end.copy(f.end)),!0;if(2!==e)return!1;if(u.delta(c),f.delta(l),c.dot(l)<0){let t=f.start;f.start=f.end,f.end=t}const i=u.start.dot(c),r=u.end.dot(c),n=f.start.dot(c),o=f.end.dot(c);return(i===o||n===r||r<n!==i<o)&&(a&&(d.subVectors(u.start,f.start),d.dot(c)>0?a.start.copy(u.start):a.start.copy(f.start),d.subVectors(u.end,f.end),d.dot(c)<0?a.end.copy(u.end):a.end.copy(f.end)),!0)}}}(),Fo.prototype.distanceToPoint=function(){const t=new s;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),Fo.prototype.distanceToTriangle=function(){const t=new s,e=new s,i=["a","b","c"],r=new h,n=new h;return function(s,o=null,a=null){const c=o||a?r:null;if(this.intersectsTriangle(s,c))return(o||a)&&(o&&c.getCenter(o),a&&c.getCenter(a)),0;let h=1/0;for(let e=0;e<3;e++){let r;const n=i[e],c=s[n];this.closestPointToPoint(c,t),r=c.distanceToSquared(t),r<h&&(h=r,o&&o.copy(t),a&&a.copy(c));const l=this[n];s.closestPointToPoint(l,t),r=l.distanceToSquared(t),r<h&&(h=r,o&&o.copy(l),a&&a.copy(t))}for(let c=0;c<3;c++){const l=i[c],d=i[(c+1)%3];r.set(this[l],this[d]);for(let c=0;c<3;c++){const l=i[c],d=i[(c+1)%3];n.set(s[l],s[d]),go(r,n,t,e);const b=t.distanceToSquared(e);b<h&&(h=b,o&&o.copy(t),a&&a.copy(e))}}return Math.sqrt(h)}}();class Ro{constructor(t,e,i){this.isOrientedBox=!0,this.min=new s,this.max=new s,this.matrix=new c,this.invMatrix=new c,this.points=new Array(8).fill().map((()=>new s)),this.satAxes=new Array(3).fill().map((()=>new s)),this.satBounds=new Array(3).fill().map((()=>new mo)),this.alignedSatBounds=new Array(3).fill().map((()=>new mo)),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),i&&this.matrix.copy(i)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}Ro.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let r=0;r<=1;r++)for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){const a=i[1*r|2*n|4*o];a.x=r?s.x:e.x,a.y=n?s.y:e.y,a.z=o?s.z:e.z,a.applyMatrix4(t)}const r=this.satBounds,n=this.satAxes,o=i[0];for(let t=0;t<3;t++){const e=n[t],s=r[t],a=i[1<<t];e.subVectors(o,a),s.setFromPoints(e,i)}const a=this.alignedSatBounds;a[0].setFromPointsField(i,"x"),a[1].setFromPointsField(i,"y"),a[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}(),Ro.prototype.intersectsBox=function(){const t=new mo;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,r=this.satBounds,n=this.satAxes,o=this.alignedSatBounds;if(t.min=s.x,t.max=i.x,o[0].isSeparated(t))return!1;if(t.min=s.y,t.max=i.y,o[1].isSeparated(t))return!1;if(t.min=s.z,t.max=i.z,o[2].isSeparated(t))return!1;for(let s=0;s<3;s++){const i=n[s],o=r[s];if(t.setFromBox(i,e),o.isSeparated(t))return!1}return!0}}(),Ro.prototype.intersectsTriangle=function(){const t=new Fo,e=new Array(3),i=new mo,r=new mo,n=new s;return function(s){this.needsUpdate&&this.update(),s.isExtendedTriangle?s.needsUpdate&&s.update():(t.copy(s),t.update(),s=t);const o=this.satBounds,a=this.satAxes;e[0]=s.a,e[1]=s.b,e[2]=s.c;for(let t=0;t<3;t++){const s=o[t],r=a[t];if(i.setFromPoints(r,e),s.isSeparated(i))return!1}const c=s.satBounds,h=s.satAxes,l=this.points;for(let t=0;t<3;t++){const e=c[t],s=h[t];if(i.setFromPoints(s,l),e.isSeparated(i))return!1}for(let t=0;t<3;t++){const s=a[t];for(let t=0;t<4;t++){const o=h[t];if(n.crossVectors(s,o),i.setFromPoints(n,e),r.setFromPoints(n,l),i.isSeparated(r))return!1}}return!0}}(),Ro.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}(),Ro.prototype.distanceToPoint=function(){const t=new s;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),Ro.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new h)),i=new Array(12).fill().map((()=>new h)),r=new s,n=new s;return function(s,o=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(s))return(a||c)&&(s.getCenter(n),this.closestPointToPoint(n,r),s.closestPointToPoint(r,n),a&&a.copy(r),c&&c.copy(n)),0;const h=o*o,l=s.min,d=s.max,b=this.points;let u=1/0;for(let t=0;t<8;t++){const e=b[t];n.copy(e).clamp(l,d);const s=e.distanceToSquared(n);if(s<u&&(u=s,a&&a.copy(e),c&&c.copy(n),s<h))return Math.sqrt(s)}let f=0;for(let s=0;s<3;s++)for(let r=0;r<=1;r++)for(let n=0;n<=1;n++){const o=(s+1)%3,a=(s+2)%3,c=1<<s|r<<o|n<<a,h=b[r<<o|n<<a],u=b[c];e[f].set(h,u);const I=t[s],_=t[o],p=t[a],E=i[f],m=E.start,C=E.end;m[I]=l[I],m[_]=r?l[_]:d[_],m[p]=n?l[p]:d[_],C[I]=d[I],C[_]=r?l[_]:d[_],C[p]=n?l[p]:d[_],f++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let s=0;s<=1;s++){n.x=t?d.x:l.x,n.y=e?d.y:l.y,n.z=s?d.z:l.z,this.closestPointToPoint(n,r);const i=n.distanceToSquared(r);if(i<u&&(u=i,a&&a.copy(r),c&&c.copy(n),i<h))return Math.sqrt(i)}for(let t=0;t<12;t++){const s=e[t];for(let t=0;t<12;t++){const e=i[t];go(s,e,r,n);const o=r.distanceToSquared(n);if(o<u&&(u=o,a&&a.copy(r),c&&c.copy(n),o<h))return Math.sqrt(o)}}return Math.sqrt(u)}}();class yo{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Oo extends yo{constructor(){super((()=>new Fo))}}const wo=new Oo;function So(t,e){return 65535===e[t+15]}function No(t,e){return e[t+6]}function Lo(t,e){return e[t+14]}function vo(t){return t+8}function xo(t,e){return e[t+6]}function Po(t,e){return e[t+7]}const Mo=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=s=>{e&&t.push(e),e=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}};let Uo,Do;const Vo=[],Bo=new yo((()=>new e));function Go(t,e,s,i,r,n){Uo=Bo.getPrimitive(),Do=Bo.getPrimitive(),Vo.push(Uo,Do),Mo.setBuffer(t._roots[e]);const o=zo(0,t.geometry,s,i,r,n);Mo.clearBuffer(),Bo.releasePrimitive(Uo),Bo.releasePrimitive(Do),Vo.pop(),Vo.pop();const a=Vo.length;return a>0&&(Do=Vo[a-1],Uo=Vo[a-2]),o}function zo(t,e,s,i,r=null,n=0,o=0){const{float32Array:a,uint16Array:c,uint32Array:h}=Mo;let l=2*t;if(So(l,c)){const e=No(t,h),s=Lo(l,c);return so(t,a,Uo),i(e,s,!1,o,n+t,Uo)}{let l=function(t){const{uint16Array:e,uint32Array:s}=Mo;let i=2*t;for(;!So(i,e);)i=2*(t=vo(t));return No(t,s)},d=function(t){const{uint16Array:e,uint32Array:s}=Mo;let i=2*t;for(;!So(i,e);)i=2*(t=xo(t,s));return No(t,s)+Lo(i,e)};const b=vo(t),u=xo(t,h);let f,I,_,p,E=b,m=u;if(r&&(_=Uo,p=Do,so(E,a,_),so(m,a,p),f=r(_),I=r(p),I<f)){E=u,m=b;const t=f;f=I,I=t,_=p}_||(_=Uo,so(E,a,_));const C=s(_,So(2*E,c),f,o+1,n+E);let g;if(2===C){const t=l(E);g=i(t,d(E)-t,!0,o+1,n+E,_)}else g=C&&zo(E,e,s,i,r,n,o+1);if(g)return!0;p=Do,so(m,a,p);const T=s(p,So(2*m,c),I,o+1,n+m);let A;if(2===T){const t=l(m);A=i(t,d(m)-t,!0,o+1,n+m,p)}else A=T&&zo(m,e,s,i,r,n,o+1);return!!A}}const Yo=new s,ko=new s;const Ho=new s,Wo=new s,jo=new s,qo=new r,Xo=new r,Zo=new r,Ko=new s,$o=new s,Qo=new s,Jo=new s;function ta(t,e,i,n,o,a,c,h,l){Ho.fromBufferAttribute(e,a),Wo.fromBufferAttribute(e,c),jo.fromBufferAttribute(e,h);const d=function(t,e,s,i,r,n){let o;return o=n===R?t.intersectTriangle(i,s,e,!0,r):t.intersectTriangle(e,s,i,n!==y,r),null===o?null:{distance:t.origin.distanceTo(r),point:r.clone()}}(t,Ho,Wo,jo,Jo,l);if(d){n&&(qo.fromBufferAttribute(n,a),Xo.fromBufferAttribute(n,c),Zo.fromBufferAttribute(n,h),d.uv=I.getInterpolation(Jo,Ho,Wo,jo,qo,Xo,Zo,new r)),o&&(qo.fromBufferAttribute(o,a),Xo.fromBufferAttribute(o,c),Zo.fromBufferAttribute(o,h),d.uv1=I.getInterpolation(Jo,Ho,Wo,jo,qo,Xo,Zo,new r)),i&&(Ko.fromBufferAttribute(i,a),$o.fromBufferAttribute(i,c),Qo.fromBufferAttribute(i,h),d.normal=I.getInterpolation(Jo,Ho,Wo,jo,Ko,$o,Qo,new s),d.normal.dot(t.direction)>0&&d.normal.multiplyScalar(-1));const e={a:a,b:c,c:h,normal:new s,materialIndex:0};I.getNormal(Ho,Wo,jo,e.normal),d.face=e,d.faceIndex=a}return d}function ea(t,e,s,i,r){const n=3*i;let o=n+0,a=n+1,c=n+2;const h=t.index;t.index&&(o=h.getX(o),a=h.getX(a),c=h.getX(c));const{position:l,normal:d,uv:b,uv1:u}=t.attributes,f=ta(s,l,d,b,u,o,a,c,e);return f?(f.faceIndex=i,r&&r.push(f),f):null}function sa(t,e,s,i){const r=t.a,n=t.b,o=t.c;let a=e,c=e+1,h=e+2;s&&(a=s.getX(a),c=s.getX(c),h=s.getX(h)),r.x=i.getX(a),r.y=i.getY(a),r.z=i.getZ(a),n.x=i.getX(c),n.y=i.getY(c),n.z=i.getZ(c),o.x=i.getX(h),o.y=i.getY(h),o.z=i.getZ(h)}function ia(t,e,s,i,r,n,o){const{geometry:a}=s,{index:c}=a,h=a.attributes.position;for(let s=t,a=e+t;s<a;s++){let t;if(t=s,sa(o,3*t,c,h),o.needsUpdate=!0,i(o,t,r,n))return!0}return!1}function ra(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const s=t.geometry,i=s.index?s.index.array:null,r=s.attributes.position;let n,o,a,c,h=0;const l=t._roots;for(let t=0,e=l.length;t<e;t++)n=l[t],o=new Uint32Array(n),a=new Uint16Array(n),c=new Float32Array(n),d(0,h),h+=n.byteLength;function d(t,s,n=!1){const h=2*t;if(a[h+15]===Zn){const e=o[t+6];let s=1/0,n=1/0,l=1/0,d=-1/0,b=-1/0,u=-1/0;for(let t=3*e,o=3*(e+a[h+14]);t<o;t++){let e=i[t];const o=r.getX(e),a=r.getY(e),c=r.getZ(e);o<s&&(s=o),o>d&&(d=o),a<n&&(n=a),a>b&&(b=a),c<l&&(l=c),c>u&&(u=c)}return(c[t+0]!==s||c[t+1]!==n||c[t+2]!==l||c[t+3]!==d||c[t+4]!==b||c[t+5]!==u)&&(c[t+0]=s,c[t+1]=n,c[t+2]=l,c[t+3]=d,c[t+4]=b,c[t+5]=u,!0)}{const i=t+8,r=o[t+6],a=i+s,h=r+s;let l=n,b=!1,u=!1;e?l||(b=e.has(a),u=e.has(h),l=!b&&!u):(b=!0,u=!0);const f=l||u;let I=!1;(l||b)&&(I=d(i,s,l));let _=!1;f&&(_=d(r,s,l));const p=I||_;if(p)for(let e=0;e<3;e++){const s=i+e,n=r+e,o=c[s],a=c[s+3],h=c[n],l=c[n+3];c[t+e]=o<h?o:h,c[t+e+3]=a>l?a:l}return p}}}const na=new e;function oa(t,e,s,i){return so(t,e,na),s.intersectBox(na,i)}function aa(t,e,s,i,r,n,o){const{geometry:a}=s,{index:c}=a,h=a.attributes.position;for(let a=t,l=e+t;a<l;a++){let t;if(t=s.resolveTriangleIndex(a),sa(o,3*t,c,h),o.needsUpdate=!0,i(o,t,r,n))return!0}return!1}const ca=new s;function ha(t,e,s,i,r){Mo.setBuffer(t._roots[e]),la(0,t,s,i,r),Mo.clearBuffer()}function la(t,e,s,i,r){const{float32Array:n,uint16Array:o,uint32Array:a}=Mo,c=2*t;if(So(c,o)){!function(t,e,s,i,r,n){const{geometry:o,_indirectBuffer:a}=t;for(let t=i,a=i+r;t<a;t++)ea(o,e,s,t,n)}(e,s,i,No(t,a),Lo(c,o),r)}else{const o=vo(t);oa(o,n,i,ca)&&la(o,e,s,i,r);const c=xo(t,a);oa(c,n,i,ca)&&la(c,e,s,i,r)}}const da=new s,ba=["x","y","z"];function ua(t,e,s,i){Mo.setBuffer(t._roots[e]);const r=fa(0,t,s,i);return Mo.clearBuffer(),r}function fa(t,e,s,i){const{float32Array:r,uint16Array:n,uint32Array:o}=Mo;let a=2*t;if(So(a,n)){return function(t,e,s,i,r){const{geometry:n,_indirectBuffer:o}=t;let a=1/0,c=null;for(let t=i,o=i+r;t<o;t++){let i;i=ea(n,e,s,t),i&&i.distance<a&&(c=i,a=i.distance)}return c}(e,s,i,No(t,o),Lo(a,n))}{const n=Po(t,o),a=ba[n],c=i.direction[a]>=0;let h,l;c?(h=vo(t),l=xo(t,o)):(h=xo(t,o),l=vo(t));const d=oa(h,r,i,da)?fa(h,e,s,i):null;if(d){const t=d.point[a];if(c?t<=r[l+n]:t>=r[l+n+3])return d}const b=oa(l,r,i,da)?fa(l,e,s,i):null;return d&&b?d.distance<=b.distance?d:b:d||b||null}}const Ia=new e,_a=new Fo,pa=new Fo,Ea=new c,ma=new Ro,Ca=new Ro;function ga(t,e,s,i){Mo.setBuffer(t._roots[e]);const r=Ta(0,t,s,i);return Mo.clearBuffer(),r}function Ta(t,e,s,i,r=null){const{float32Array:n,uint16Array:o,uint32Array:a}=Mo;let c=2*t;null===r&&(s.boundingBox||s.computeBoundingBox(),ma.set(s.boundingBox.min,s.boundingBox.max,i),r=ma);if(!So(c,o)){const o=t+8,c=a[t+6];so(o,n,Ia);if(r.intersectsBox(Ia)&&Ta(o,e,s,i,r))return!0;so(c,n,Ia);return!!(r.intersectsBox(Ia)&&Ta(c,e,s,i,r))}{const r=e.geometry,h=r.index,l=r.attributes.position,d=s.index,b=s.attributes.position,u=No(t,a),f=Lo(c,o);if(Ea.copy(i).invert(),s.boundsTree){so(t,n,Ca),Ca.matrix.copy(Ea),Ca.needsUpdate=!0;return s.boundsTree.shapecast({intersectsBounds:t=>Ca.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(i),t.b.applyMatrix4(i),t.c.applyMatrix4(i),t.needsUpdate=!0;for(let e=3*u,s=3*(f+u);e<s;e+=3)if(sa(pa,e,h,l),pa.needsUpdate=!0,t.intersectsTriangle(pa))return!0;return!1}})}for(let t=3*u,e=3*(f+u);t<e;t+=3){sa(_a,t,h,l),_a.a.applyMatrix4(Ea),_a.b.applyMatrix4(Ea),_a.c.applyMatrix4(Ea),_a.needsUpdate=!0;for(let t=0,e=d.count;t<e;t+=3)if(sa(pa,t,d,b),pa.needsUpdate=!0,_a.intersectsTriangle(pa))return!0}}}const Aa=new c,Fa=new Ro,Ra=new Ro,ya=new s,Oa=new s,wa=new s,Sa=new s;function Na(t,e,s,i={},r={},n=0,o=1/0){e.boundingBox||e.computeBoundingBox(),Fa.set(e.boundingBox.min,e.boundingBox.max,s),Fa.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,h=a.index,l=e.attributes.position,d=e.index,b=wo.getPrimitive(),u=wo.getPrimitive();let f=ya,I=Oa,_=null,p=null;r&&(_=wa,p=Sa);let E=1/0,m=null,C=null;return Aa.copy(s).invert(),Ra.matrix.copy(Aa),t.shapecast({boundsTraverseOrder:t=>Fa.distanceToBox(t),intersectsBounds:(t,e,s)=>s<E&&s<o&&(e&&(Ra.min.copy(t.min),Ra.max.copy(t.max),Ra.needsUpdate=!0),!0),intersectsRange:(t,i)=>{if(e.boundsTree){return e.boundsTree.shapecast({boundsTraverseOrder:t=>Ra.distanceToBox(t),intersectsBounds:(t,e,s)=>s<E&&s<o,intersectsRange:(e,r)=>{for(let o=e,a=e+r;o<a;o++){sa(u,3*o,d,l),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let e=t,s=t+i;e<s;e++){sa(b,3*e,h,c),b.needsUpdate=!0;const t=b.distanceToTriangle(u,f,_);if(t<E&&(I.copy(f),p&&p.copy(_),E=t,m=e,C=o),t<n)return!0}}}})}for(let r=0,o=Qn(e);r<o;r++){sa(u,3*r,d,l),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let e=t,s=t+i;e<s;e++){sa(b,3*e,h,c),b.needsUpdate=!0;const t=b.distanceToTriangle(u,f,_);if(t<E&&(I.copy(f),p&&p.copy(_),E=t,m=e,C=r),t<n)return!0}}}}),wo.releasePrimitive(b),wo.releasePrimitive(u),E===1/0?null:(i.point?i.point.copy(I):i.point=I.clone(),i.distance=E,i.faceIndex=m,r&&(r.point?r.point.copy(p):r.point=p.clone(),r.point.applyMatrix4(Aa),I.applyMatrix4(Aa),r.distance=I.sub(r.point).length(),r.faceIndex=C),i)}function La(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const s=t.geometry,i=s.index?s.index.array:null,r=s.attributes.position;let n,o,a,c,h=0;const l=t._roots;for(let t=0,e=l.length;t<e;t++)n=l[t],o=new Uint32Array(n),a=new Uint16Array(n),c=new Float32Array(n),d(0,h),h+=n.byteLength;function d(s,n,h=!1){const l=2*s;if(a[l+15]===Zn){const e=o[s+6];let n=1/0,h=1/0,d=1/0,b=-1/0,u=-1/0,f=-1/0;for(let s=e,o=e+a[l+14];s<o;s++){const e=3*t.resolveTriangleIndex(s);for(let t=0;t<3;t++){let s=e+t;s=i?i[s]:s;const o=r.getX(s),a=r.getY(s),c=r.getZ(s);o<n&&(n=o),o>b&&(b=o),a<h&&(h=a),a>u&&(u=a),c<d&&(d=c),c>f&&(f=c)}}return(c[s+0]!==n||c[s+1]!==h||c[s+2]!==d||c[s+3]!==b||c[s+4]!==u||c[s+5]!==f)&&(c[s+0]=n,c[s+1]=h,c[s+2]=d,c[s+3]=b,c[s+4]=u,c[s+5]=f,!0)}{const t=s+8,i=o[s+6],r=t+n,a=i+n;let l=h,b=!1,u=!1;e?l||(b=e.has(r),u=e.has(a),l=!b&&!u):(b=!0,u=!0);const f=l||u;let I=!1;(l||b)&&(I=d(t,n,l));let _=!1;f&&(_=d(i,n,l));const p=I||_;if(p)for(let e=0;e<3;e++){const r=t+e,n=i+e,o=c[r],a=c[r+3],h=c[n],l=c[n+3];c[s+e]=o<h?o:h,c[s+e+3]=a>l?a:l}return p}}}const va=new s;function xa(t,e,s,i,r){Mo.setBuffer(t._roots[e]),Pa(0,t,s,i,r),Mo.clearBuffer()}function Pa(t,e,s,i,r){const{float32Array:n,uint16Array:o,uint32Array:a}=Mo,c=2*t;if(So(c,o)){!function(t,e,s,i,r,n){const{geometry:o,_indirectBuffer:a}=t;for(let t=i,c=i+r;t<c;t++)ea(o,e,s,a?a[t]:t,n)}(e,s,i,No(t,a),Lo(c,o),r)}else{const o=vo(t);oa(o,n,i,va)&&Pa(o,e,s,i,r);const c=xo(t,a);oa(c,n,i,va)&&Pa(c,e,s,i,r)}}const Ma=new s,Ua=["x","y","z"];function Da(t,e,s,i){Mo.setBuffer(t._roots[e]);const r=Va(0,t,s,i);return Mo.clearBuffer(),r}function Va(t,e,s,i){const{float32Array:r,uint16Array:n,uint32Array:o}=Mo;let a=2*t;if(So(a,n)){return function(t,e,s,i,r){const{geometry:n,_indirectBuffer:o}=t;let a=1/0,c=null;for(let t=i,h=i+r;t<h;t++){let i;i=ea(n,e,s,o?o[t]:t),i&&i.distance<a&&(c=i,a=i.distance)}return c}(e,s,i,No(t,o),Lo(a,n))}{const n=Po(t,o),a=Ua[n],c=i.direction[a]>=0;let h,l;c?(h=vo(t),l=xo(t,o)):(h=xo(t,o),l=vo(t));const d=oa(h,r,i,Ma)?Va(h,e,s,i):null;if(d){const t=d.point[a];if(c?t<=r[l+n]:t>=r[l+n+3])return d}const b=oa(l,r,i,Ma)?Va(l,e,s,i):null;return d&&b?d.distance<=b.distance?d:b:d||b||null}}const Ba=new e,Ga=new Fo,za=new Fo,Ya=new c,ka=new Ro,Ha=new Ro;function Wa(t,e,s,i){Mo.setBuffer(t._roots[e]);const r=ja(0,t,s,i);return Mo.clearBuffer(),r}function ja(t,e,s,i,r=null){const{float32Array:n,uint16Array:o,uint32Array:a}=Mo;let c=2*t;null===r&&(s.boundingBox||s.computeBoundingBox(),ka.set(s.boundingBox.min,s.boundingBox.max,i),r=ka);if(!So(c,o)){const o=t+8,c=a[t+6];so(o,n,Ba);if(r.intersectsBox(Ba)&&ja(o,e,s,i,r))return!0;so(c,n,Ba);return!!(r.intersectsBox(Ba)&&ja(c,e,s,i,r))}{const r=e.geometry,h=r.index,l=r.attributes.position,d=s.index,b=s.attributes.position,u=No(t,a),f=Lo(c,o);if(Ya.copy(i).invert(),s.boundsTree){so(t,n,Ha),Ha.matrix.copy(Ya),Ha.needsUpdate=!0;return s.boundsTree.shapecast({intersectsBounds:t=>Ha.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(i),t.b.applyMatrix4(i),t.c.applyMatrix4(i),t.needsUpdate=!0;for(let s=u,i=f+u;s<i;s++)if(sa(za,3*e.resolveTriangleIndex(s),h,l),za.needsUpdate=!0,t.intersectsTriangle(za))return!0;return!1}})}for(let t=u,s=f+u;t<s;t++){const s=e.resolveTriangleIndex(t);sa(Ga,3*s,h,l),Ga.a.applyMatrix4(Ya),Ga.b.applyMatrix4(Ya),Ga.c.applyMatrix4(Ya),Ga.needsUpdate=!0;for(let t=0,e=d.count;t<e;t+=3)if(sa(za,t,d,b),za.needsUpdate=!0,Ga.intersectsTriangle(za))return!0}}}const qa=new c,Xa=new Ro,Za=new Ro,Ka=new s,$a=new s,Qa=new s,Ja=new s;function tc(t,e,s,i={},r={},n=0,o=1/0){e.boundingBox||e.computeBoundingBox(),Xa.set(e.boundingBox.min,e.boundingBox.max,s),Xa.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,h=a.index,l=e.attributes.position,d=e.index,b=wo.getPrimitive(),u=wo.getPrimitive();let f=Ka,I=$a,_=null,p=null;r&&(_=Qa,p=Ja);let E=1/0,m=null,C=null;return qa.copy(s).invert(),Za.matrix.copy(qa),t.shapecast({boundsTraverseOrder:t=>Xa.distanceToBox(t),intersectsBounds:(t,e,s)=>s<E&&s<o&&(e&&(Za.min.copy(t.min),Za.max.copy(t.max),Za.needsUpdate=!0),!0),intersectsRange:(i,r)=>{if(e.boundsTree){const a=e.boundsTree;return a.shapecast({boundsTraverseOrder:t=>Za.distanceToBox(t),intersectsBounds:(t,e,s)=>s<E&&s<o,intersectsRange:(e,o)=>{for(let g=e,T=e+o;g<T;g++){const e=a.resolveTriangleIndex(g);sa(u,3*e,d,l),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let e=i,s=i+r;e<s;e++){const s=t.resolveTriangleIndex(e);sa(b,3*s,h,c),b.needsUpdate=!0;const i=b.distanceToTriangle(u,f,_);if(i<E&&(I.copy(f),p&&p.copy(_),E=i,m=e,C=g),i<n)return!0}}}})}for(let o=0,a=Qn(e);o<a;o++){sa(u,3*o,d,l),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let e=i,s=i+r;e<s;e++){const s=t.resolveTriangleIndex(e);sa(b,3*s,h,c),b.needsUpdate=!0;const i=b.distanceToTriangle(u,f,_);if(i<E&&(I.copy(f),p&&p.copy(_),E=i,m=e,C=o),i<n)return!0}}}}),wo.releasePrimitive(b),wo.releasePrimitive(u),E===1/0?null:(i.point?i.point.copy(I):i.point=I.clone(),i.distance=E,i.faceIndex=m,r&&(r.point?r.point.copy(p):r.point=p.clone(),r.point.applyMatrix4(qa),I.applyMatrix4(qa),r.distance=I.sub(r.point).length(),r.faceIndex=C),i)}const ec=new Mo.constructor,sc=new Mo.constructor,ic=new yo((()=>new e)),rc=new e,nc=new e,oc=new e,ac=new e;let cc=!1;function hc(t,e,s,i,r,n=0,o=0,a=0,c=0,h=null,l=!1){let d,b;l?(d=sc,b=ec):(d=ec,b=sc);const u=d.float32Array,f=d.uint32Array,I=d.uint16Array,_=b.float32Array,p=b.uint32Array,E=b.uint16Array,m=2*e,C=So(2*t,I),g=So(m,E);let T=!1;if(g&&C)T=l?r(No(e,p),Lo(2*e,E),No(t,f),Lo(2*t,I),c,o+e,a,n+t):r(No(t,f),Lo(2*t,I),No(e,p),Lo(2*e,E),a,n+t,c,o+e);else if(g){const h=ic.getPrimitive();so(e,_,h),h.applyMatrix4(s);const d=vo(t),b=xo(t,f);so(d,u,rc),so(b,u,nc);const I=h.intersectsBox(rc),p=h.intersectsBox(nc);T=I&&hc(e,d,i,s,r,o,n,c,a+1,h,!l)||p&&hc(e,b,i,s,r,o,n,c,a+1,h,!l),ic.releasePrimitive(h)}else{const d=vo(e),b=xo(e,p);so(d,_,oc),so(b,_,ac);const I=h.intersectsBox(oc),E=h.intersectsBox(ac);if(I&&E)T=hc(t,d,s,i,r,n,o,a,c+1,h,l)||hc(t,b,s,i,r,n,o,a,c+1,h,l);else if(I)if(C)T=hc(t,d,s,i,r,n,o,a,c+1,h,l);else{const e=ic.getPrimitive();e.copy(oc).applyMatrix4(s);const h=vo(t),b=xo(t,f);so(h,u,rc),so(b,u,nc);const I=e.intersectsBox(rc),_=e.intersectsBox(nc);T=I&&hc(d,h,i,s,r,o,n,c,a+1,e,!l)||_&&hc(d,b,i,s,r,o,n,c,a+1,e,!l),ic.releasePrimitive(e)}else if(E)if(C)T=hc(t,b,s,i,r,n,o,a,c+1,h,l);else{const e=ic.getPrimitive();e.copy(ac).applyMatrix4(s);const h=vo(t),d=xo(t,f);so(h,u,rc),so(d,u,nc);const I=e.intersectsBox(rc),_=e.intersectsBox(nc);T=I&&hc(b,h,i,s,r,o,n,c,a+1,e,!l)||_&&hc(b,d,i,s,r,o,n,c,a+1,e,!l),ic.releasePrimitive(e)}}return T}const lc=new Ro,dc=new e;class bc{static serialize(t,e={}){e={cloneBuffers:!0,...e};const s=t.geometry,i=t._roots,r=t._indirectBuffer,n=s.getIndex();let o;return o=e.cloneBuffers?{roots:i.map((t=>t.slice())),index:n.array.slice(),indirectBuffer:r?r.slice():null}:{roots:i,index:n.array,indirectBuffer:r},o}static deserialize(t,e,s={}){s={setIndex:!0,indirect:Boolean(t.indirectBuffer),...s};const{index:i,roots:r,indirectBuffer:n}=t,o=new bc(e,{...s,[$n]:!0});if(o._roots=r,o._indirectBuffer=n||null,s.setIndex){const s=e.getIndex();if(null===s){const s=new A(t.index,1,!1);e.setIndex(s)}else s.array!==i&&(s.array.set(i),s.needsUpdate=!0)}return o}get indirect(){return!!this._indirectBuffer}constructor(t,s={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((s=Object.assign({strategy:0,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[$n]:!1},s)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,s[$n]||(Eo(this,s),!t.boundingBox&&s.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new e)));const{_indirectBuffer:i}=this;this.resolveTriangleIndex=s.indirect?t=>i[t]:t=>t}refit(t=null){return(this.indirect?La:ra)(this,t)}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),r=new Uint16Array(s);!function e(n,o=0){const a=2*n,c=r[a+15]===Zn;if(c){const e=i[n+6],h=r[a+14];t(o,c,new Float32Array(s,4*n,6),e,h)}else{const r=n+8,a=i[n+6],h=i[n+7];t(o,c,new Float32Array(s,4*n,6),h)||(e(r,o+1),e(a,o+1))}}(0)}raycast(t,e=F){const s=this._roots,i=this.geometry,r=[],n=e.isMaterial,o=Array.isArray(e),a=i.groups,c=n?e.side:e,h=this.indirect?xa:ha;for(let i=0,n=s.length;i<n;i++){const s=o?e[a[i].materialIndex].side:c,n=r.length;if(h(this,i,s,t,r),o){const t=a[i].materialIndex;for(let e=n,s=r.length;e<s;e++)r[e].face.materialIndex=t}}return r}raycastFirst(t,e=F){const s=this._roots,i=this.geometry,r=e.isMaterial,n=Array.isArray(e);let o=null;const a=i.groups,c=r?e.side:e,h=this.indirect?Da:ua;for(let i=0,r=s.length;i<r;i++){const s=h(this,i,n?e[a[i].materialIndex].side:c,t);null!=s&&(null==o||s.distance<o.distance)&&(o=s,n&&(s.face.materialIndex=a[i].materialIndex))}return o}intersectsGeometry(t,e){let s=!1;const i=this._roots,r=this.indirect?Wa:ga;for(let n=0,o=i.length;n<o&&(s=r(this,n,t,e),!s);n++);return s}shapecast(t){const e=wo.getPrimitive(),s=this.indirect?aa:ia;let{boundsTraverseOrder:i,intersectsBounds:r,intersectsRange:n,intersectsTriangle:o}=t;if(n&&o){const t=n;n=(i,r,n,a,c)=>!!t(i,r,n,a,c)||s(i,r,this,o,n,a,e)}else n||(n=o?(t,i,r,n)=>s(t,i,this,o,r,n,e):(t,e,s)=>s);let a=!1,c=0;const h=this._roots;for(let t=0,e=h.length;t<e;t++){const e=h[t];if(a=Go(this,t,r,n,i,c),a)break;c+=e.byteLength}return wo.releasePrimitive(e),a}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:r}=s;const n=wo.getPrimitive(),o=this.geometry.index,a=this.geometry.attributes.position,h=this.indirect?t=>{const e=this.resolveTriangleIndex(t);sa(n,3*e,o,a)}:t=>{sa(n,3*t,o,a)},l=wo.getPrimitive(),d=t.geometry.index,b=t.geometry.attributes.position,u=t.indirect?e=>{const s=t.resolveTriangleIndex(e);sa(l,3*s,d,b)}:t=>{sa(l,3*t,d,b)};if(r){const t=(t,s,i,o,a,c,d,b)=>{for(let f=i,I=i+o;f<I;f++){u(f),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let e=t,i=t+s;e<i;e++)if(h(e),n.needsUpdate=!0,r(n,l,e,f,a,c,d,b))return!0}return!1};if(i){const e=i;i=function(s,i,r,n,o,a,c,h){return!!e(s,i,r,n,o,a,c,h)||t(s,i,r,n,o,a,c,h)}}else i=t}return function(t,e,s,i){if(cc)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");cc=!0;const r=t._roots,n=e._roots;let o,a=0,h=0;const l=(new c).copy(s).invert();for(let t=0,e=r.length;t<e;t++){ec.setBuffer(r[t]),h=0;const e=ic.getPrimitive();so(0,ec.float32Array,e),e.applyMatrix4(l);for(let r=0,c=n.length;r<c&&(sc.setBuffer(n[t]),o=hc(0,0,s,l,i,a,h,0,0,e),sc.clearBuffer(),h+=n[r].length,!o);r++);if(ic.releasePrimitive(e),ec.clearBuffer(),a+=r[t].length,o)break}return cc=!1,o}(this,t,e,i)}intersectsBox(t,e){return lc.set(t.min,t.max,e),lc.needsUpdate=!0,this.shapecast({intersectsBounds:t=>lc.intersectsBox(t),intersectsTriangle:t=>lc.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},r=0,n=1/0){return(this.indirect?tc:Na)(this,t,e,s,i,r,n)}closestPointToPoint(t,e={},s=0,i=1/0){return function(t,e,s={},i=0,r=1/0){const n=i*i,o=r*r;let a=1/0,c=null;if(t.shapecast({boundsTraverseOrder:t=>(Yo.copy(e).clamp(t.min,t.max),Yo.distanceToSquared(e)),intersectsBounds:(t,e,s)=>s<a&&s<o,intersectsTriangle:(t,s)=>{t.closestPointToPoint(e,Yo);const i=e.distanceToSquared(Yo);return i<a&&(ko.copy(Yo),a=i,c=s),i<n}}),a===1/0)return null;const h=Math.sqrt(a);return s.point?s.point.copy(ko):s.point=ko.clone(),s.distance=h,s.faceIndex=c,s}(this,t,e,s,i)}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{so(0,new Float32Array(e),dc),t.union(dc)})),t}}function uc(t,e,s){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(s.ray.origin),t.object=e,t.distance<s.near||t.distance>s.far?null:t)}const fc=new b,Ic=new c,_c=u.prototype.raycast;function pc(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;Ic.copy(this.matrixWorld).invert(),fc.copy(t.ray).applyMatrix4(Ic);const s=this.geometry.boundsTree;if(!0===t.firstHitOnly){const i=uc(s.raycastFirst(fc,this.material),this,t);i&&e.push(i)}else{const i=s.raycast(fc,this.material);for(let s=0,r=i.length;s<r;s++){const r=uc(i[s],this,t);r&&e.push(r)}}}else _c.call(this,t,e)}function Ec(t){return this.boundsTree=new bc(this,t),this.boundsTree}function mc(){this.boundsTree=null}const Cc=class t{static apply(e){t.initialized||(_.prototype.computeBoundsTree=Ec,_.prototype.disposeBoundsTree=mc,u.prototype.raycast=pc,t.initialized=!0),e.boundsTree||e.computeBoundsTree()}static dispose(t){t&&t.disposeBoundsTree&&t.disposeBoundsTree()}};S(Cc,"initialized",!1);let gc=Cc,Tc=class e{constructor(t,e,s){S(this,"ids",new Set),S(this,"itemToInstances",new Map),S(this,"instanceToItem",new Map),S(this,"hiddenItems",new Set),S(this,"id"),S(this,"mesh"),S(this,"capacity",0),S(this,"capacityOffset",10),S(this,"group"),S(this,"_originalColors",new Map),S(this,"_settingVisibility",!1),this.mesh=new qn(t,e,s,this),this.id=this.mesh.uuid,this.capacity=s,this.mesh.count=0,this.mesh.geometry.index.count&&gc.apply(this.mesh.geometry)}get uniqueVertices(){const e=[],s=this.mesh.geometry.getAttribute("position");if(!s)return e;const i=new Set;for(let r=0;r<s.count;r++){const n=s.getX(r),o=s.getY(r),a=s.getZ(r),c=`${n},${o},${a}`;i.has(c)||(i.add(c),e.push(new t.Vector3(n,o,a)))}return e}dispose(t=!0){if(this.clear(),this.group=void 0,this._originalColors.clear(),this.mesh){if(t){for(const t of this.mesh.material)t.dispose();this.mesh.material=[],gc.dispose(this.mesh.geometry),this.mesh.geometry&&this.mesh.geometry.dispose(),this.mesh.geometry=null}this.mesh.removeFromParent(),this.mesh.userData={},this.mesh.dispose(),this.mesh.fragment=null,this.mesh=null}}get(e){const s=this.getInstancesIDs(e);if(!s)throw new Error("Item not found!");const i=[],r=[];for(const e of s){const s=new t.Matrix4;if(this.mesh.getMatrixAt(e,s),i.push(s),this.mesh.instanceColor){const s=new t.Color;this.mesh.getColorAt(e,s),r.push(s)}}return{id:e,transforms:i,colors:r.length?r:void 0}}getItemID(t){return this.instanceToItem.get(t)||null}getInstancesIDs(t){return this.itemToInstances.get(t)||null}update(){this.mesh.instanceColor&&(this.mesh.instanceColor.needsUpdate=!0),this.mesh.instanceMatrix.needsUpdate=!0}add(e){var s;let i=0;for(const t of e)i+=t.transforms.length;const r=this.mesh.count+i;if(r>this.capacity){const e=r+this.capacityOffset,i=new qn(this.mesh.geometry,this.mesh.material,e,this);i.count=this.mesh.count,this.capacity=e;const n=this.mesh;null==(s=n.parent)||s.add(i),n.removeFromParent(),this.mesh=i;const o=new t.Matrix4;for(let t=0;t<n.instanceMatrix.count;t++)n.getMatrixAt(t,o),i.setMatrixAt(t,o);if(n.instanceColor){const e=new t.Color;for(let t=0;t<n.instanceColor.count;t++)n.getColorAt(t,e),i.setColorAt(t,e)}n.dispose()}for(let t=0;t<e.length;t++){const{transforms:s,colors:i,id:r}=e[t];this.itemToInstances.has(r)||this.itemToInstances.set(r,new Set);const n=this.itemToInstances.get(r);this.ids.add(r);for(let t=0;t<s.length;t++){const e=s[t],o=this.mesh.count;if(this.mesh.setMatrixAt(o,e),i){const e=i[t];this.mesh.setColorAt(o,e)}n.add(o),this.instanceToItem.set(o,r),this.mesh.count++}}this.update()}remove(t){if(0!==this.mesh.count){for(const e of t){const t=this.itemToInstances.get(e);if(void 0===t)throw new Error("Instances not found!");for(const e of t){if(0===this.mesh.count)throw new Error("Error with mesh count!");this.putLast(e),this.instanceToItem.delete(e),this.mesh.count--}this.itemToInstances.delete(e),this.ids.delete(e)}this.update()}}clear(){this.hiddenItems.clear(),this.ids.clear(),this.instanceToItem.clear(),this.itemToInstances.clear(),this.mesh.count=0}setVisibility(t,e=this.ids){if(!this._settingVisibility){if(this._settingVisibility=!0,t)for(const t of e){if(!this.ids.has(t))continue;if(!this.hiddenItems.has(t))continue;const e=this.itemToInstances.get(t);if(!e)throw new Error("Instances not found!");for(const t of new Set(e))this.mesh.count++,this.putLast(t);this.hiddenItems.delete(t)}else for(const t of e){if(!this.ids.has(t))continue;if(this.hiddenItems.has(t))continue;const e=this.itemToInstances.get(t);if(!e)throw new Error("Instances not found!");for(const t of new Set(e))this.putLast(t),this.mesh.count--;this.hiddenItems.add(t)}this.update(),this._settingVisibility=!1}}setColor(e,s=this.ids,i=!1){if(!this.mesh.instanceColor)throw new Error("This fragment doesn't have color per instance!");for(const r of s){if(!this.ids.has(r))continue;const s=this.itemToInstances.get(r);if(!s)throw new Error("Instances not found!");const n=this._originalColors.has(r);n||this._originalColors.set(r,new Map);const o=this._originalColors.get(r);for(const r of new Set(s)){if(!n){const e=new t.Color;this.mesh.getColorAt(r,e),o.set(r,e)}this.mesh.setColorAt(r,e),i&&o.set(r,e)}}this.mesh.instanceColor.needsUpdate=!0}resetColor(t=this.ids){if(!this.mesh.instanceColor)throw new Error("This fragment doesn't have color per instance!");for(const e of t){if(!this.ids.has(e))continue;const t=this.itemToInstances.get(e);if(!t)throw new Error("Instances not found!");const s=this._originalColors.get(e);if(s)for(const e of new Set(t)){const t=s.get(e);if(!t)throw new Error("Original color not found!");this.mesh.setColorAt(e,t)}}this.mesh.instanceColor.needsUpdate=!0}applyTransform(e,s){const i=new t.Matrix4;for(const t of e){const e=this.getInstancesIDs(t);if(null!==e)for(const t of e)this.mesh.getMatrixAt(t,i),i.premultiply(s),this.mesh.setMatrixAt(t,i)}this.update()}exportData(){return{...this.mesh.exportData(),ids:Array.from(this.ids),id:this.id}}clone(s=this.ids){const i=new e(this.mesh.geometry,this.mesh.material,this.capacity),r=[];for(const e of s){const s=this.getInstancesIDs(e);if(null===s)continue;const i=[],n=[];for(const e of s){const s=new t.Matrix4,r=new t.Color;this.mesh.getMatrixAt(e,s),this.mesh.getColorAt(e,r),i.push(s),n.push(r)}r.push({id:e,transforms:i,colors:n})}return i.add(r),i}putLast(e){if(0===this.mesh.count)return;const s=this.instanceToItem.get(e),i=this.mesh.count-1;if(i===e)return;const r=this.instanceToItem.get(i);if(void 0===s||void 0===r)throw new Error("Keys not found");if(s!==r){const t=this.itemToInstances.get(s),n=this.itemToInstances.get(r);if(!t||!n)throw new Error("Instances not found");if(!t.has(e)||!n.has(i))throw new Error("Malformed fragment structure");t.delete(e),n.delete(i),t.add(i),n.add(e),this.instanceToItem.set(e,r),this.instanceToItem.set(i,s)}const n=new t.Matrix4,o=new t.Matrix4;if(this.mesh.getMatrixAt(e,n),this.mesh.getMatrixAt(i,o),this.mesh.setMatrixAt(e,o),this.mesh.setMatrixAt(i,n),null!==this.mesh.instanceColor){const n=new t.Color,o=new t.Color;this.mesh.getColorAt(e,n),this.mesh.getColorAt(i,o),this.mesh.setColorAt(e,o),this.mesh.setColorAt(i,n);const a=this._originalColors.get(s);if(a){const t=a.get(e);t&&(a.delete(e),a.set(i,t))}const c=this._originalColors.get(r);if(c){const t=c.get(i);t&&(c.delete(i),c.set(e,t))}}}},Ac=class t{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCivilCurve(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsCivilCurve(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}points(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}data(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}static startCivilCurve(t){t.startObject(2)}static addPoints(t,e){t.addFieldOffset(0,e,0)}static createPointsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPointsVector(t,e){t.startVector(4,e,4)}static addData(t,e){t.addFieldOffset(1,e,0)}static endCivilCurve(t){return t.endObject()}static createCivilCurve(e,s,i){return t.startCivilCurve(e),t.addPoints(e,s),t.addData(e,i),t.endCivilCurve(e)}},Fc=class t{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAlignment(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsAlignment(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}vertical(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new Ac).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}verticalLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontal(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new Ac).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}absolute(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new Ac).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}absoluteLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}initialPk(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}static startAlignment(t){t.startObject(4)}static addVertical(t,e){t.addFieldOffset(0,e,0)}static createVerticalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startVerticalVector(t,e){t.startVector(4,e,4)}static addHorizontal(t,e){t.addFieldOffset(1,e,0)}static createHorizontalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startHorizontalVector(t,e){t.startVector(4,e,4)}static addAbsolute(t,e){t.addFieldOffset(2,e,0)}static createAbsoluteVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAbsoluteVector(t,e){t.startVector(4,e,4)}static addInitialPk(t,e){t.addFieldFloat32(3,e,0)}static endAlignment(t){return t.endObject()}static createAlignment(e,s,i,r,n){return t.startAlignment(e),t.addVertical(e,s),t.addHorizontal(e,i),t.addAbsolute(e,r),t.addInitialPk(e,n),t.endAlignment(e)}},Rc=class t{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCivilData(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsCivilData(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}alignments(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new Fc).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrix(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startCivilData(t){t.startObject(2)}static addAlignments(t,e){t.addFieldOffset(0,e,0)}static createAlignmentsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAlignmentsVector(t,e){t.startVector(4,e,4)}static addCoordinationMatrix(t,e){t.addFieldOffset(1,e,0)}static createCoordinationMatrixVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startCoordinationMatrixVector(t,e){t.startVector(4,e,4)}static endCivilData(t){return t.endObject()}static createCivilData(e,s,i){return t.startCivilData(e),t.addAlignments(e,s),t.addCoordinationMatrix(e,i),t.endCivilData(e)}},yc=class t{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsFragment(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsFragment(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}position(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}positionLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}normalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}indexLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}groups(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}groupsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}groupsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}materials(t){const e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}materialsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}matrices(t){const e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}matricesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}matricesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}colors(t){const e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}colorsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}colorsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsSize(t){const e=this.bb.__offset(this.bb_pos,18);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsSizeLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsSizeArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const e=this.bb.__offset(this.bb_pos,20);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}idsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,20);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}id(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__string(this.bb_pos+e,t):null}capacity(){const t=this.bb.__offset(this.bb_pos,24);return t?this.bb.readUint32(this.bb_pos+t):0}capacityOffset(){const t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readUint32(this.bb_pos+t):0}static startFragment(t){t.startObject(12)}static addPosition(t,e){t.addFieldOffset(0,e,0)}static createPositionVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPositionVector(t,e){t.startVector(4,e,4)}static addNormal(t,e){t.addFieldOffset(1,e,0)}static createNormalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startNormalVector(t,e){t.startVector(4,e,4)}static addIndex(t,e){t.addFieldOffset(2,e,0)}static createIndexVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndexVector(t,e){t.startVector(4,e,4)}static addGroups(t,e){t.addFieldOffset(3,e,0)}static createGroupsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startGroupsVector(t,e){t.startVector(4,e,4)}static addMaterials(t,e){t.addFieldOffset(4,e,0)}static createMaterialsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startMaterialsVector(t,e){t.startVector(4,e,4)}static addMatrices(t,e){t.addFieldOffset(5,e,0)}static createMatricesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startMatricesVector(t,e){t.startVector(4,e,4)}static addColors(t,e){t.addFieldOffset(6,e,0)}static createColorsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startColorsVector(t,e){t.startVector(4,e,4)}static addItemsSize(t,e){t.addFieldOffset(7,e,0)}static createItemsSizeVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsSizeVector(t,e){t.startVector(4,e,4)}static addIds(t,e){t.addFieldOffset(8,e,0)}static createIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIdsVector(t,e){t.startVector(4,e,4)}static addId(t,e){t.addFieldOffset(9,e,0)}static addCapacity(t,e){t.addFieldInt32(10,e,0)}static addCapacityOffset(t,e){t.addFieldInt32(11,e,0)}static endFragment(t){return t.endObject()}static createFragment(e,s,i,r,n,o,a,c,h,l,d,b,u){return t.startFragment(e),t.addPosition(e,s),t.addNormal(e,i),t.addIndex(e,r),t.addGroups(e,n),t.addMaterials(e,o),t.addMatrices(e,a),t.addColors(e,c),t.addItemsSize(e,h),t.addIds(e,l),t.addId(e,d),t.addCapacity(e,b),t.addCapacityOffset(e,u),t.endFragment(e)}},Oc=class t{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsFragmentsGroup(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsFragmentsGroup(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}items(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new yc).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}itemsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}civil(t){const e=this.bb.__offset(this.bb_pos,6);return e?(t||new Rc).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}coordinationMatrix(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}idsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeys(t){const e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsKeysLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeysIndices(t){const e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsKeysIndicesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysIndicesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRels(t){const e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsRelsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRelsIndices(t){const e=this.bb.__offset(this.bb_pos,18);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsRelsIndicesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsIndicesArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}fragmentKeys(t){const e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb_pos+e,t):null}id(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__string(this.bb_pos+e,t):null}name(t){const e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__string(this.bb_pos+e,t):null}ifcName(t){const e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__string(this.bb_pos+e,t):null}ifcDescription(t){const e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__string(this.bb_pos+e,t):null}ifcSchema(t){const e=this.bb.__offset(this.bb_pos,30);return e?this.bb.__string(this.bb_pos+e,t):null}maxExpressId(){const t=this.bb.__offset(this.bb_pos,32);return t?this.bb.readUint32(this.bb_pos+t):0}boundingBox(t){const e=this.bb.__offset(this.bb_pos,34);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}boundingBoxLength(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.__vector_len(this.bb_pos+t):0}boundingBoxArray(){const t=this.bb.__offset(this.bb_pos,34);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}opaqueGeometriesIds(t){const e=this.bb.__offset(this.bb_pos,36);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}opaqueGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,36);return t?this.bb.__vector_len(this.bb_pos+t):0}opaqueGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,36);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transparentGeometriesIds(t){const e=this.bb.__offset(this.bb_pos,38);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}transparentGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,38);return t?this.bb.__vector_len(this.bb_pos+t):0}transparentGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,38);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startFragmentsGroup(t){t.startObject(18)}static addItems(t,e){t.addFieldOffset(0,e,0)}static createItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startItemsVector(t,e){t.startVector(4,e,4)}static addCivil(t,e){t.addFieldOffset(1,e,0)}static addCoordinationMatrix(t,e){t.addFieldOffset(2,e,0)}static createCoordinationMatrixVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startCoordinationMatrixVector(t,e){t.startVector(4,e,4)}static addIds(t,e){t.addFieldOffset(3,e,0)}static createIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIdsVector(t,e){t.startVector(4,e,4)}static addItemsKeys(t,e){t.addFieldOffset(4,e,0)}static createItemsKeysVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsKeysVector(t,e){t.startVector(4,e,4)}static addItemsKeysIndices(t,e){t.addFieldOffset(5,e,0)}static createItemsKeysIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsKeysIndicesVector(t,e){t.startVector(4,e,4)}static addItemsRels(t,e){t.addFieldOffset(6,e,0)}static createItemsRelsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsRelsVector(t,e){t.startVector(4,e,4)}static addItemsRelsIndices(t,e){t.addFieldOffset(7,e,0)}static createItemsRelsIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsRelsIndicesVector(t,e){t.startVector(4,e,4)}static addFragmentKeys(t,e){t.addFieldOffset(8,e,0)}static addId(t,e){t.addFieldOffset(9,e,0)}static addName(t,e){t.addFieldOffset(10,e,0)}static addIfcName(t,e){t.addFieldOffset(11,e,0)}static addIfcDescription(t,e){t.addFieldOffset(12,e,0)}static addIfcSchema(t,e){t.addFieldOffset(13,e,0)}static addMaxExpressId(t,e){t.addFieldInt32(14,e,0)}static addBoundingBox(t,e){t.addFieldOffset(15,e,0)}static createBoundingBoxVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startBoundingBoxVector(t,e){t.startVector(4,e,4)}static addOpaqueGeometriesIds(t,e){t.addFieldOffset(16,e,0)}static createOpaqueGeometriesIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startOpaqueGeometriesIdsVector(t,e){t.startVector(4,e,4)}static addTransparentGeometriesIds(t,e){t.addFieldOffset(17,e,0)}static createTransparentGeometriesIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startTransparentGeometriesIdsVector(t,e){t.startVector(4,e,4)}static endFragmentsGroup(t){return t.endObject()}static finishFragmentsGroupBuffer(t,e){t.finish(e)}static finishSizePrefixedFragmentsGroupBuffer(t,e){t.finish(e,void 0,!0)}};class wc{constructor(){S(this,"version",1),S(this,"fragmentIDSeparator","|")}import(t){const e=new Y(t),s=Oc.getRootAsFragmentsGroup(e),i=this.constructFragmentGroup(s),r=s.itemsLength();for(let t=0;t<r;t++){const e=s.items(t);if(!e)continue;const r=this.constructGeometry(e),n=this.constructMaterials(e),o=e.capacity(),a=new Tc(r,n,o);a.capacityOffset=e.capacityOffset(),this.setInstances(e,a),this.setID(e,a),i.items.push(a),i.add(a.mesh)}return i}export(t){const e=new k(1024),s=[],i=Oc,r=yc;let n=null;if(t.civilData){const s=[],i=Fc,r=Rc;for(const[r,n]of t.civilData.alignments){const{absolute:t,horizontal:r,vertical:o}=n,a=this.saveCivilCurves(r,e),c=this.saveCivilCurves(o,e),h=this.saveCivilCurves(t,e),l=i.createHorizontalVector(e,a),d=i.createVerticalVector(e,c),b=i.createAbsoluteVector(e,h);i.startAlignment(e),i.addHorizontal(e,l),i.addVertical(e,d),i.addAbsolute(e,b),i.addInitialPk(e,n.initialKP);const u=i.endAlignment(e);s.push(u)}const o=r.createAlignmentsVector(e,s),a=r.createCoordinationMatrixVector(e,t.coordinationMatrix.elements);r.startCivilData(e),r.addAlignments(e,o),r.addCoordinationMatrix(e,a),n=r.endCivilData(e)}for(const i of t.items){const t=i.exportData(),n=[];for(const t of i.ids){const e=i.getInstancesIDs(t);if(!e)throw new Error("Instances not found!");n.push(e.size)}const o=r.createPositionVector(e,t.position),a=r.createNormalVector(e,t.normal),c=r.createIndexVector(e,t.index),h=r.createGroupsVector(e,t.groups),l=r.createMaterialsVector(e,t.materials),d=r.createMatricesVector(e,t.matrices),b=r.createColorsVector(e,t.colors),u=r.createIdsVector(e,t.ids),f=r.createItemsSizeVector(e,n),I=e.createString(t.id);r.startFragment(e),r.addPosition(e,o),r.addNormal(e,a),r.addIndex(e,c),r.addGroups(e,h),r.addMaterials(e,l),r.addMatrices(e,d),r.addColors(e,b),r.addIds(e,u),r.addItemsSize(e,f),r.addId(e,I),r.addCapacity(e,i.capacity),r.addCapacityOffset(e,i.capacityOffset);const _=yc.endFragment(e);s.push(_)}const o=i.createItemsVector(e,s),a=i.createCoordinationMatrixVector(e,t.coordinationMatrix.elements);let c="";for(const e of t.keyFragments.values())c.length&&(c+=this.fragmentIDSeparator),c+=e;const h=e.createString(c),l=[],d=[],b=[],u=[],f=[];let I=0,_=0;for(const[e,[s,i]]of t.data){l.push(I),b.push(_),f.push(e);for(const t of s)d.push(t);for(const t of i)u.push(t);I+=s.length,_+=i.length}const p=[],E=[];for(const[e,s]of t.geometryIDs.opaque)p.push(e,s);for(const[e,s]of t.geometryIDs.transparent)E.push(e,s);const m=e.createString(t.uuid),C=e.createString(t.name),g=e.createString(t.ifcMetadata.name),T=e.createString(t.ifcMetadata.description),A=e.createString(t.ifcMetadata.schema),F=i.createItemsKeysIndicesVector(e,l),R=i.createItemsKeysVector(e,d),y=i.createItemsRelsIndicesVector(e,b),O=i.createItemsRelsVector(e,u),w=i.createIdsVector(e,f),S=i.createOpaqueGeometriesIdsVector(e,p),N=i.createTransparentGeometriesIdsVector(e,E),{min:L,max:v}=t.boundingBox,x=[L.x,L.y,L.z,v.x,v.y,v.z],P=i.createBoundingBoxVector(e,x);i.startFragmentsGroup(e),i.addId(e,m),i.addName(e,C),i.addIfcName(e,g),i.addIfcDescription(e,T),i.addIfcSchema(e,A),i.addMaxExpressId(e,t.ifcMetadata.maxExpressID),i.addItems(e,o),i.addFragmentKeys(e,h),i.addIds(e,w),i.addItemsKeysIndices(e,F),i.addItemsKeys(e,R),i.addItemsRelsIndices(e,y),i.addItemsRels(e,O),i.addCoordinationMatrix(e,a),i.addBoundingBox(e,P),i.addOpaqueGeometriesIds(e,S),i.addTransparentGeometriesIds(e,N),null!==n&&i.addCivil(e,n);const M=Oc.endFragmentsGroup(e);return e.finish(M),e.asUint8Array()}setID(t,e){const s=t.id();s&&(e.id=s,e.mesh.uuid=s)}setInstances(e,s){const i=e.matricesArray(),r=e.colorsArray(),n=e.idsArray(),o=e.itemsSizeArray();if(!i||!n||!o)throw new Error("Error: Can't load empty fragment!");const a=[];let c=0;for(let e=0;e<o.length;e++){const s=n[e],h=o[e],l=[],d=[];for(let e=0;e<h;e++){const e=16*c,s=i.subarray(e,e+17),n=(new t.Matrix4).fromArray(s);if(l.push(n),r){const e=3*c,[s,i,n]=r.subarray(e,e+4),o=new t.Color(s,i,n);d.push(o)}c++}const b=d.length?d:void 0;a.push({id:s,transforms:l,colors:b})}s.add(a)}constructMaterials(e){const s=e.materialsArray(),i=[];if(!s)return i;for(let e=0;e<s.length;e+=5){const r=s[e],n=Boolean(s[e+1]),o=s[e+2],a=s[e+3],c=s[e+4],h=new t.Color(o,a,c),l=new t.MeshLambertMaterial({color:h,opacity:r,transparent:n});i.push(l)}return i}constructFragmentGroup(e){const s=new Vc,i=e.civil();if(i){const e=i.coordinationMatrixArray(),r=new t.Matrix4;e&&r.fromArray(e),s.civilData={alignments:new Map,coordinationMatrix:r};const n=i.alignmentsLength();for(let e=0;e<n;e++){const r=new t.LineBasicMaterial({color:16777215}),n=new Bc,o=i.alignments(e);if(!o)throw new Error("Alignment not found!");const a=o.horizontalLength();n.horizontal=this.constructCivilCurves(o,n,"horizontal",a,r);const c=o.verticalLength();n.vertical=this.constructCivilCurves(o,n,"vertical",c,r);const h=o.horizontalLength();n.absolute=this.constructCivilCurves(o,n,"absolute",h,r),n.initialKP=o.initialPk(),s.civilData.alignments.set(e,n)}}s.uuid=e.id()||s.uuid,s.name=e.name()||"",s.ifcMetadata={name:e.ifcName()||"",description:e.ifcDescription()||"",schema:e.ifcSchema()||"IFC2X3",maxExpressID:e.maxExpressId()||0};const r=(new t.Matrix4).elements,n=e.coordinationMatrixArray()||r,o=e.idsArray()||new Uint32Array,a=e.itemsKeysIndicesArray()||new Uint32Array,c=e.itemsKeysArray()||new Uint32Array,h=e.itemsRelsArray()||new Uint32Array,l=e.itemsRelsIndicesArray()||new Uint32Array,d=(e.fragmentKeys()||"").split(this.fragmentIDSeparator);this.setGroupData(s,o,a,c,0),this.setGroupData(s,o,l,h,1);const b=e.opaqueGeometriesIdsArray()||new Uint32Array,u=e.transparentGeometriesIdsArray()||new Uint32Array,f=new Map;for(let t=0;t<b.length-1;t+=2){const e=b[t],s=b[t+1];f.set(e,s)}const I=new Map;for(let t=0;t<u.length-1;t+=2){const e=u[t],s=u[t+1];I.set(e,s)}s.geometryIDs={opaque:f,transparent:I};const _=e.boundingBoxArray()||[0,0,0,0,0,0],[p,E,m,C,g,T]=_;s.boundingBox.min.set(p,E,m),s.boundingBox.max.set(C,g,T);for(let t=0;t<d.length;t++)s.keyFragments.set(t,d[t]);return 16===n.length&&s.coordinationMatrix.fromArray(n),s}setGroupData(t,e,s,i,r){for(let n=0;n<s.length;n++){const o=e[n],a=s[n],c=s[n+1]||i.length,h=[];for(let t=a;t<c;t++)h.push(i[t]);t.data.has(o)||t.data.set(o,[[],[]]);const l=t.data.get(o);l&&(l[r]=h)}}constructGeometry(e){const s=e.positionArray()||new Float32Array,i=e.normalArray()||new Float32Array,r=e.indexArray(),n=e.groupsArray();if(!r)throw new Error("Index not found!");const o=new t.BufferGeometry;if(o.setIndex(Array.from(r)),o.setAttribute("position",new t.BufferAttribute(s,3)),o.setAttribute("normal",new t.BufferAttribute(i,3)),n)for(let t=0;t<n.length;t+=3){const e=n[t],s=n[t+1],i=n[t+2];o.addGroup(e,s,i)}return o}constructCivilCurves(e,s,i,r,n){const o=[];for(let a=0;a<r;a++){const r=e[i](a);if(!r)throw new Error("Curve not found!");const c=r.pointsArray();if(null===c)throw new Error("Curve points not found!");let h={};const l=r.data();l&&(h=JSON.parse(l));const d=new t.EdgesGeometry,b=new t.BufferAttribute(c,3);d.setAttribute("position",b);const u=[];for(let t=0;t<c.length/3-1;t++)u.push(t,t+1);d.setIndex(u);const f=new zc(a,h,s,d,n);o.push(f.curve)}return o}saveCivilCurves(t,e){const s=Ac,i=[];for(const r of t){const t=r.mesh.geometry.attributes.position.array,n=s.createPointsVector(e,t),o=e.createString(JSON.stringify(r.data));s.startCivilCurve(e),s.addPoints(e,n),s.addData(e,o);const a=s.endCivilCurve(e);i.push(a)}return i}}let Sc=class t{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCivilCurve(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsCivilCurve(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}points(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}data(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}static startCivilCurve(t){t.startObject(2)}static addPoints(t,e){t.addFieldOffset(0,e,0)}static createPointsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPointsVector(t,e){t.startVector(4,e,4)}static addData(t,e){t.addFieldOffset(1,e,0)}static endCivilCurve(t){return t.endObject()}static createCivilCurve(e,s,i){return t.startCivilCurve(e),t.addPoints(e,s),t.addData(e,i),t.endCivilCurve(e)}};class Nc{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAlignment(t,e){return(e||new Nc).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAlignment(t,e){return t.setPosition(t.position()+4),(e||new Nc).__init(t.readInt32(t.position())+t.position(),t)}vertical(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new Sc).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}verticalLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontal(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new Sc).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}absolute(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new Sc).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}absoluteLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}initialPk(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}static startAlignment(t){t.startObject(4)}static addVertical(t,e){t.addFieldOffset(0,e,0)}static createVerticalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startVerticalVector(t,e){t.startVector(4,e,4)}static addHorizontal(t,e){t.addFieldOffset(1,e,0)}static createHorizontalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startHorizontalVector(t,e){t.startVector(4,e,4)}static addAbsolute(t,e){t.addFieldOffset(2,e,0)}static createAbsoluteVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAbsoluteVector(t,e){t.startVector(4,e,4)}static addInitialPk(t,e){t.addFieldFloat32(3,e,0)}static endAlignment(t){return t.endObject()}static createAlignment(t,e,s,i,r){return Nc.startAlignment(t),Nc.addVertical(t,e),Nc.addHorizontal(t,s),Nc.addAbsolute(t,i),Nc.addInitialPk(t,r),Nc.endAlignment(t)}}class Lc{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCivilData(t,e){return(e||new Lc).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilData(t,e){return t.setPosition(t.position()+4),(e||new Lc).__init(t.readInt32(t.position())+t.position(),t)}alignments(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new Nc).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrix(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startCivilData(t){t.startObject(2)}static addAlignments(t,e){t.addFieldOffset(0,e,0)}static createAlignmentsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAlignmentsVector(t,e){t.startVector(4,e,4)}static addCoordinationMatrix(t,e){t.addFieldOffset(1,e,0)}static createCoordinationMatrixVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startCoordinationMatrixVector(t,e){t.startVector(4,e,4)}static endCivilData(t){return t.endObject()}static createCivilData(t,e,s){return Lc.startCivilData(t),Lc.addAlignments(t,e),Lc.addCoordinationMatrix(t,s),Lc.endCivilData(t)}}class vc{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsFragment(t,e){return(e||new vc).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragment(t,e){return t.setPosition(t.position()+4),(e||new vc).__init(t.readInt32(t.position())+t.position(),t)}position(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}positionLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}normalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}indexLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}groups(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}groupsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}groupsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}materials(t){const e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}materialsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}matrices(t){const e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}matricesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}matricesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}colors(t){const e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}colorsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}colorsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsSize(t){const e=this.bb.__offset(this.bb_pos,18);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsSizeLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsSizeArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const e=this.bb.__offset(this.bb_pos,20);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}idsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,20);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}id(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__string(this.bb_pos+e,t):null}capacity(){const t=this.bb.__offset(this.bb_pos,24);return t?this.bb.readUint32(this.bb_pos+t):0}capacityOffset(){const t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readUint32(this.bb_pos+t):0}static startFragment(t){t.startObject(12)}static addPosition(t,e){t.addFieldOffset(0,e,0)}static createPositionVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPositionVector(t,e){t.startVector(4,e,4)}static addNormal(t,e){t.addFieldOffset(1,e,0)}static createNormalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startNormalVector(t,e){t.startVector(4,e,4)}static addIndex(t,e){t.addFieldOffset(2,e,0)}static createIndexVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndexVector(t,e){t.startVector(4,e,4)}static addGroups(t,e){t.addFieldOffset(3,e,0)}static createGroupsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startGroupsVector(t,e){t.startVector(4,e,4)}static addMaterials(t,e){t.addFieldOffset(4,e,0)}static createMaterialsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startMaterialsVector(t,e){t.startVector(4,e,4)}static addMatrices(t,e){t.addFieldOffset(5,e,0)}static createMatricesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startMatricesVector(t,e){t.startVector(4,e,4)}static addColors(t,e){t.addFieldOffset(6,e,0)}static createColorsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startColorsVector(t,e){t.startVector(4,e,4)}static addItemsSize(t,e){t.addFieldOffset(7,e,0)}static createItemsSizeVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsSizeVector(t,e){t.startVector(4,e,4)}static addIds(t,e){t.addFieldOffset(8,e,0)}static createIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIdsVector(t,e){t.startVector(4,e,4)}static addId(t,e){t.addFieldOffset(9,e,0)}static addCapacity(t,e){t.addFieldInt32(10,e,0)}static addCapacityOffset(t,e){t.addFieldInt32(11,e,0)}static endFragment(t){return t.endObject()}static createFragment(t,e,s,i,r,n,o,a,c,h,l,d,b){return vc.startFragment(t),vc.addPosition(t,e),vc.addNormal(t,s),vc.addIndex(t,i),vc.addGroups(t,r),vc.addMaterials(t,n),vc.addMatrices(t,o),vc.addColors(t,a),vc.addItemsSize(t,c),vc.addIds(t,h),vc.addId(t,l),vc.addCapacity(t,d),vc.addCapacityOffset(t,b),vc.endFragment(t)}}let xc=class t{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsFragmentsGroup(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsFragmentsGroup(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}items(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new vc).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}itemsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}civil(t){const e=this.bb.__offset(this.bb_pos,6);return e?(t||new Lc).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}coordinationMatrix(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}idsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeys(t){const e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsKeysLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeysIndices(t){const e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsKeysIndicesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysIndicesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRels(t){const e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsRelsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRelsIndices(t){const e=this.bb.__offset(this.bb_pos,18);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsRelsIndicesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsIndicesArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}fragmentKeys(t){const e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb_pos+e,t):null}globalIds(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__string(this.bb_pos+e,t):null}id(t){const e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__string(this.bb_pos+e,t):null}name(t){const e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__string(this.bb_pos+e,t):null}ifcName(t){const e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__string(this.bb_pos+e,t):null}ifcDescription(t){const e=this.bb.__offset(this.bb_pos,30);return e?this.bb.__string(this.bb_pos+e,t):null}ifcSchema(t){const e=this.bb.__offset(this.bb_pos,32);return e?this.bb.__string(this.bb_pos+e,t):null}maxExpressId(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.readUint32(this.bb_pos+t):0}boundingBox(t){const e=this.bb.__offset(this.bb_pos,36);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}boundingBoxLength(){const t=this.bb.__offset(this.bb_pos,36);return t?this.bb.__vector_len(this.bb_pos+t):0}boundingBoxArray(){const t=this.bb.__offset(this.bb_pos,36);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}opaqueGeometriesIds(t){const e=this.bb.__offset(this.bb_pos,38);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}opaqueGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,38);return t?this.bb.__vector_len(this.bb_pos+t):0}opaqueGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,38);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transparentGeometriesIds(t){const e=this.bb.__offset(this.bb_pos,40);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}transparentGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,40);return t?this.bb.__vector_len(this.bb_pos+t):0}transparentGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,40);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startFragmentsGroup(t){t.startObject(19)}static addItems(t,e){t.addFieldOffset(0,e,0)}static createItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startItemsVector(t,e){t.startVector(4,e,4)}static addCivil(t,e){t.addFieldOffset(1,e,0)}static addCoordinationMatrix(t,e){t.addFieldOffset(2,e,0)}static createCoordinationMatrixVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startCoordinationMatrixVector(t,e){t.startVector(4,e,4)}static addIds(t,e){t.addFieldOffset(3,e,0)}static createIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIdsVector(t,e){t.startVector(4,e,4)}static addItemsKeys(t,e){t.addFieldOffset(4,e,0)}static createItemsKeysVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsKeysVector(t,e){t.startVector(4,e,4)}static addItemsKeysIndices(t,e){t.addFieldOffset(5,e,0)}static createItemsKeysIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsKeysIndicesVector(t,e){t.startVector(4,e,4)}static addItemsRels(t,e){t.addFieldOffset(6,e,0)}static createItemsRelsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsRelsVector(t,e){t.startVector(4,e,4)}static addItemsRelsIndices(t,e){t.addFieldOffset(7,e,0)}static createItemsRelsIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsRelsIndicesVector(t,e){t.startVector(4,e,4)}static addFragmentKeys(t,e){t.addFieldOffset(8,e,0)}static addGlobalIds(t,e){t.addFieldOffset(9,e,0)}static addId(t,e){t.addFieldOffset(10,e,0)}static addName(t,e){t.addFieldOffset(11,e,0)}static addIfcName(t,e){t.addFieldOffset(12,e,0)}static addIfcDescription(t,e){t.addFieldOffset(13,e,0)}static addIfcSchema(t,e){t.addFieldOffset(14,e,0)}static addMaxExpressId(t,e){t.addFieldInt32(15,e,0)}static addBoundingBox(t,e){t.addFieldOffset(16,e,0)}static createBoundingBoxVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startBoundingBoxVector(t,e){t.startVector(4,e,4)}static addOpaqueGeometriesIds(t,e){t.addFieldOffset(17,e,0)}static createOpaqueGeometriesIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startOpaqueGeometriesIdsVector(t,e){t.startVector(4,e,4)}static addTransparentGeometriesIds(t,e){t.addFieldOffset(18,e,0)}static createTransparentGeometriesIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startTransparentGeometriesIdsVector(t,e){t.startVector(4,e,4)}static endFragmentsGroup(t){return t.endObject()}static finishFragmentsGroupBuffer(t,e){t.finish(e)}static finishSizePrefixedFragmentsGroupBuffer(t,e){t.finish(e,void 0,!0)}};class Pc{constructor(){S(this,"version",2),S(this,"separator","|")}import(t){const e=new Y(t),s=xc.getRootAsFragmentsGroup(e),i=this.constructFragmentGroup(s),r=s.itemsLength();for(let t=0;t<r;t++){const e=s.items(t);if(!e)continue;const r=this.constructGeometry(e),n=this.constructMaterials(e),o=e.capacity(),a=new Tc(r,n,o);a.capacityOffset=e.capacityOffset(),this.setInstances(e,a),this.setID(e,a),i.items.push(a),i.add(a.mesh)}return i}export(t){const e=new k(1024),s=[],i=xc,r=vc;let n=null;if(t.civilData){const s=[],i=Nc,r=Lc;for(const[r,n]of t.civilData.alignments){const{absolute:t,horizontal:r,vertical:o}=n,a=this.saveCivilCurves(r,e),c=this.saveCivilCurves(o,e),h=this.saveCivilCurves(t,e),l=i.createHorizontalVector(e,a),d=i.createVerticalVector(e,c),b=i.createAbsoluteVector(e,h);i.startAlignment(e),i.addHorizontal(e,l),i.addVertical(e,d),i.addAbsolute(e,b),i.addInitialPk(e,n.initialKP);const u=i.endAlignment(e);s.push(u)}const o=r.createAlignmentsVector(e,s),a=r.createCoordinationMatrixVector(e,t.coordinationMatrix.elements);r.startCivilData(e),r.addAlignments(e,o),r.addCoordinationMatrix(e,a),n=r.endCivilData(e)}for(const i of t.items){const t=i.exportData(),n=[];for(const t of i.ids){const e=i.getInstancesIDs(t);if(!e)throw new Error("Instances not found!");n.push(e.size)}const o=r.createPositionVector(e,t.position),a=r.createNormalVector(e,t.normal),c=r.createIndexVector(e,t.index),h=r.createGroupsVector(e,t.groups),l=r.createMaterialsVector(e,t.materials),d=r.createMatricesVector(e,t.matrices),b=r.createColorsVector(e,t.colors),u=r.createIdsVector(e,t.ids),f=r.createItemsSizeVector(e,n),I=e.createString(t.id);r.startFragment(e),r.addPosition(e,o),r.addNormal(e,a),r.addIndex(e,c),r.addGroups(e,h),r.addMaterials(e,l),r.addMatrices(e,d),r.addColors(e,b),r.addIds(e,u),r.addItemsSize(e,f),r.addId(e,I),r.addCapacity(e,i.capacity),r.addCapacityOffset(e,i.capacityOffset);const _=vc.endFragment(e);s.push(_)}const o=i.createItemsVector(e,s),a=i.createCoordinationMatrixVector(e,t.coordinationMatrix.elements);let c="";for(const e of t.keyFragments.values())c.length&&(c+=this.separator),c+=e;let h="";for(const[e]of t.globalToExpressIDs)h.length&&(h+=this.separator),h+=e;const l=e.createString(c),d=e.createString(h),b=[],u=[],f=[],I=[],_=[];let p=0,E=0;for(const[e,[s,i]]of t.data){b.push(p),f.push(E),_.push(e);for(const t of s)u.push(t);for(const t of i)I.push(t);p+=s.length,E+=i.length}const m=[],C=[];for(const[e,s]of t.geometryIDs.opaque)m.push(e,s);for(const[e,s]of t.geometryIDs.transparent)C.push(e,s);const g=e.createString(t.uuid),T=e.createString(t.name),A=e.createString(t.ifcMetadata.name),F=e.createString(t.ifcMetadata.description),R=e.createString(t.ifcMetadata.schema),y=i.createItemsKeysIndicesVector(e,b),O=i.createItemsKeysVector(e,u),w=i.createItemsRelsIndicesVector(e,f),S=i.createItemsRelsVector(e,I),N=i.createIdsVector(e,_),L=i.createOpaqueGeometriesIdsVector(e,m),v=i.createTransparentGeometriesIdsVector(e,C),{min:x,max:P}=t.boundingBox,M=[x.x,x.y,x.z,P.x,P.y,P.z],U=i.createBoundingBoxVector(e,M);i.startFragmentsGroup(e),i.addId(e,g),i.addName(e,T),i.addIfcName(e,A),i.addIfcDescription(e,F),i.addIfcSchema(e,R),i.addMaxExpressId(e,t.ifcMetadata.maxExpressID),i.addItems(e,o),i.addFragmentKeys(e,l),i.addGlobalIds(e,d),i.addIds(e,N),i.addItemsKeysIndices(e,y),i.addItemsKeys(e,O),i.addItemsRelsIndices(e,w),i.addItemsRels(e,S),i.addCoordinationMatrix(e,a),i.addBoundingBox(e,U),i.addOpaqueGeometriesIds(e,L),i.addTransparentGeometriesIds(e,v),null!==n&&i.addCivil(e,n);const D=xc.endFragmentsGroup(e);return e.finish(D),e.asUint8Array()}setID(t,e){const s=t.id();s&&(e.id=s,e.mesh.uuid=s)}setInstances(e,s){const i=e.matricesArray(),r=e.colorsArray(),n=e.idsArray(),o=e.itemsSizeArray();if(!i||!n||!o)throw new Error("Error: Can't load empty fragment!");const a=[];let c=0;for(let e=0;e<o.length;e++){const s=n[e],h=o[e],l=[],d=[];for(let e=0;e<h;e++){const e=16*c,s=i.subarray(e,e+17),n=(new t.Matrix4).fromArray(s);if(l.push(n),r){const e=3*c,[s,i,n]=r.subarray(e,e+4),o=new t.Color(s,i,n);d.push(o)}c++}const b=d.length?d:void 0;a.push({id:s,transforms:l,colors:b})}s.add(a)}constructMaterials(e){const s=e.materialsArray(),i=[];if(!s)return i;for(let e=0;e<s.length;e+=5){const r=s[e],n=Boolean(s[e+1]),o=s[e+2],a=s[e+3],c=s[e+4],h=new t.Color(o,a,c),l=new t.MeshLambertMaterial({color:h,opacity:r,transparent:n});i.push(l)}return i}constructFragmentGroup(e){const s=new Vc,i=e.civil();if(i){const e=i.coordinationMatrixArray(),r=new t.Matrix4;e&&r.fromArray(e),s.civilData={alignments:new Map,coordinationMatrix:r};const n=i.alignmentsLength();for(let e=0;e<n;e++){const r=new t.LineBasicMaterial({color:16777215}),n=new Bc,o=i.alignments(e);if(!o)throw new Error("Alignment not found!");const a=o.horizontalLength();n.horizontal=this.constructCivilCurves(o,n,"horizontal",a,r);const c=o.verticalLength();n.vertical=this.constructCivilCurves(o,n,"vertical",c,r);const h=o.horizontalLength();n.absolute=this.constructCivilCurves(o,n,"absolute",h,r),n.initialKP=o.initialPk(),s.civilData.alignments.set(e,n)}}s.uuid=e.id()||s.uuid,s.name=e.name()||"",s.ifcMetadata={name:e.ifcName()||"",description:e.ifcDescription()||"",schema:e.ifcSchema()||"IFC2X3",maxExpressID:e.maxExpressId()||0};const r=(new t.Matrix4).elements,n=e.coordinationMatrixArray()||r,o=e.idsArray()||new Uint32Array,a=e.itemsKeysIndicesArray()||new Uint32Array,c=e.itemsKeysArray()||new Uint32Array,h=e.itemsRelsArray()||new Uint32Array,l=e.itemsRelsIndicesArray()||new Uint32Array,d=(e.fragmentKeys()||"").split(this.separator),b=(e.globalIds()||"").split(this.separator);this.setGroupData(s,o,a,c,0),this.setGroupData(s,o,l,h,1);const u=e.opaqueGeometriesIdsArray()||new Uint32Array,f=e.transparentGeometriesIdsArray()||new Uint32Array,I=new Map;for(let t=0;t<u.length-1;t+=2){const e=u[t],s=u[t+1];I.set(e,s)}const _=new Map;for(let t=0;t<f.length-1;t+=2){const e=f[t],s=f[t+1];_.set(e,s)}s.geometryIDs={opaque:I,transparent:_};const p=e.boundingBoxArray()||[0,0,0,0,0,0],[E,m,C,g,T,A]=p;s.boundingBox.min.set(E,m,C),s.boundingBox.max.set(g,T,A);for(let t=0;t<d.length;t++)s.keyFragments.set(t,d[t]);16===n.length&&s.coordinationMatrix.fromArray(n);for(let t=0;t<o.length;t++)s.globalToExpressIDs.set(b[t],o[t]);return s}setGroupData(t,e,s,i,r){for(let n=0;n<s.length;n++){const o=e[n],a=s[n],c=s[n+1],h=void 0===c?i.length:c,l=[];for(let t=a;t<h;t++)l.push(i[t]);t.data.has(o)||t.data.set(o,[[],[]]);const d=t.data.get(o);d&&(d[r]=l)}}constructGeometry(e){const s=e.positionArray()||new Float32Array,i=e.normalArray()||new Float32Array,r=e.indexArray(),n=e.groupsArray();if(!r)throw new Error("Index not found!");const o=new t.BufferGeometry;if(o.setIndex(Array.from(r)),o.setAttribute("position",new t.BufferAttribute(s,3)),o.setAttribute("normal",new t.BufferAttribute(i,3)),n)for(let t=0;t<n.length;t+=3){const e=n[t],s=n[t+1],i=n[t+2];o.addGroup(e,s,i)}return o}constructCivilCurves(e,s,i,r,n){const o=[];for(let a=0;a<r;a++){const r=e[i](a);if(!r)throw new Error("Curve not found!");const c=r.pointsArray();if(null===c)throw new Error("Curve points not found!");let h={};const l=r.data();l&&(h=JSON.parse(l));const d=new t.EdgesGeometry,b=new t.BufferAttribute(c,3);d.setAttribute("position",b);const u=[];for(let t=0;t<c.length/3-1;t++)u.push(t,t+1);d.setIndex(u);const f=new zc(a,h,s,d,n);o.push(f.curve)}return o}saveCivilCurves(t,e){const s=Sc,i=[];for(const r of t){const t=r.mesh.geometry.attributes.position.array,n=s.createPointsVector(e,t),o=e.createString(JSON.stringify(r.data));s.startCivilCurve(e),s.addPoints(e,n),s.addData(e,o);const a=s.endCivilCurve(e);i.push(a)}return i}}class Mc{constructor(){S(this,"parsers",[new Pc,new wc]),S(this,"version","auto")}import(t){const e=this.parsers.length;if("auto"===this.version){for(let s=0;s<this.parsers.length;s++){const i=this.parsers[s].import(t);if(0!==Object.keys(i).length){if(0!==s){const t=this.parsers.length-s;this.warnVersion(t,e)}return i}}throw new Error("No valid parser found for this file")}this.checkCurrentVersionValid(this.version);const s=this.parsers.length-this.version,i=this.parsers[s].import(t);if(0===Object.keys(i).length)throw new Error(`The given version ${this.version} doesn't match to the given file. Try using "auto" in the version property to handle versions automatically.`);return i}export(t){if("auto"===this.version){return this.parsers[0].export(t)}this.checkCurrentVersionValid(this.version);const e=this.parsers.length-this.version;return this.parsers[e].export(t)}checkCurrentVersionValid(t){if("auto"===this.version)return;this.version!==t&&this.warnVersion(this.version,t);if(!Number.isInteger(this.version))throw new Error("Invalid version. Non-automatic versions must an integer.");if(this.version<1||this.version>t)throw new Error(`Invalid version. Versions range from 1 to ${t}.`)}warnVersion(t,e){console.warn(`This fragment file version is ${t}. The latest version is ${e}. To avoid issues, please consider updating your fragments. You can do so by regenerating your fragments from the original IFC file.`)}}class Uc{constructor(t){S(this,"baseDirectory"),S(this,"maxDeadTime",6e4),S(this,"mode","buffer"),S(this,"_memoryCleanTime",1e4),S(this,"_intervalID",null),S(this,"_isCleaningMemory",!1),S(this,"cleanMemory",(async()=>{if(this._isCleaningMemory)return;this._isCleaningMemory=!0;const t=await this.getDir(this.baseDirectory),e=new Set,s=(new Date).getTime();for await(const i of t.values()){const t=localStorage.getItem(i.name)||"0";s-parseInt(t,10)>this.maxDeadTime&&(e.add(i.name),localStorage.removeItem(i.name))}for(const s of e)t.removeEntry(s);this._isCleaningMemory=!1})),this.baseDirectory=t,this.setupMemoryCleanup()}get memoryCleanTime(){return this._memoryCleanTime}set memoryCleanTime(t){this._memoryCleanTime=t,this.dispose(),this.setupMemoryCleanup()}isCached(t){const e=this.encodeName(t);return null!==localStorage.getItem(e)}async get(t){const e=this.encodeName(t),s=await this.getDir(this.baseDirectory);try{const t=await s.getFileHandle(e),i=await t.getFile();return this.updateLastAccessTime(e),i}catch(t){return null}}async add(t,e){const s=this.encodeName(t),i=await this.getDir(this.baseDirectory),r=await i.getFileHandle(s,{create:!0}),n=await r.createWritable();await n.write(e),await n.close(),this.updateLastAccessTime(s)}async clear(){const t=await this.getDir(this.baseDirectory);for await(const[e]of t.entries())await t.removeEntry(e)}dispose(){null!==this._intervalID&&window.clearInterval(this._intervalID)}setupMemoryCleanup(){this._intervalID=window.setInterval(this.cleanMemory,this.memoryCleanTime)}async getDir(t){return(await navigator.storage.getDirectory()).getDirectoryHandle(t,{create:!0})}encodeName(t){return t.replace(/[\\/:*?"<>|]/g,"ñ")}updateLastAccessTime(t){const e=(new Date).getTime().toString();localStorage.setItem(t,e)}}const Dc=class e extends t.Group{constructor(){super(...arguments),S(this,"items",[]),S(this,"boundingBox",new t.Box3),S(this,"coordinationMatrix",new t.Matrix4),S(this,"keyFragments",new Map),S(this,"globalToExpressIDs",new Map),S(this,"data",new Map),S(this,"geometryIDs",{opaque:new Map,transparent:new Map}),S(this,"ifcMetadata",{name:"",description:"",schema:"IFC2X3",maxExpressID:0}),S(this,"civilData"),S(this,"streamSettings",{baseFileName:"",ids:new Map,types:new Map}),S(this,"isStreamed",!1),S(this,"_properties")}get hasProperties(){const t=void 0!==this._properties,e=0!==this.streamSettings.ids.size;return t||e}getFragmentMap(t=this.data.keys()){const e={};for(const s of t){const t=this.data.get(s);if(t)for(const i of t[0]){const t=this.keyFragments.get(i);void 0!==t&&(e[t]||(e[t]=new Set),e[t].add(s))}}return e}getItemVertices(e){const s=[],i=this.getFragmentMap([e]);for(const r in i){const i=this.items.find((t=>t.id===r));if(!i)continue;const n=i.getInstancesIDs(e);if(n)for(const e of n){const r=new t.Matrix4;i.mesh.getMatrixAt(e,r);for(const t of i.uniqueVertices){const e=t.clone().applyMatrix4(r);s.push(e)}}}return s}static setPropertiesDB(t){t?e.propertiesDB||(e.propertiesDB=new Uc("that-open-company-streaming-properties")):t||e.propertiesDB&&e.propertiesDB.dispose()}dispose(e=!0){for(const t of this.items)t.dispose(e);if(this.coordinationMatrix=new t.Matrix4,this.keyFragments.clear(),this.data.clear(),this._properties={},this.removeFromParent(),this.items=[],this.civilData){const{alignments:t}=this.civilData;for(const[e,s]of t)this.disposeAlignment(s.vertical),this.disposeAlignment(s.horizontal),this.disposeAlignment(s.absolute)}this.civilData=void 0}setLocalProperties(t){this._properties=t}getLocalProperties(){return this._properties}getAllPropertiesIDs(){return this._properties?Object.keys(this._properties).map((t=>parseInt(t,10))):Array.from(this.streamSettings.ids.keys())}getAllPropertiesTypes(){if(this._properties){const t=new Set;for(const e in this._properties){const s=this._properties[e];void 0!==s.type&&t.add(s.type)}return Array.from(t)}return Array.from(this.streamSettings.types.keys())}async getProperties(t){if(this._properties)return this._properties[t]||null;const e=this.getPropsURL(t),s=await this.getPropertiesData(e);return s?s[t]:null}async setProperties(t,e){if(!this._properties)throw new Error("Writing streamed properties not supported yet!");null!==e?this._properties[t]=e:delete this._properties[t]}async getAllPropertiesOfType(t){if(this._properties){const e={};let s=!1;for(const i in this._properties){const r=this._properties[i];r.type===t&&(e[r.expressID]=r,s=!0)}return s?e:null}const{types:e}=this.streamSettings,s=e.get(t);if(void 0===s)return null;const i={};for(const t of s){const e=this.constructFileName(t),s=await this.getPropertiesData(e);for(const t in s)i[parseInt(t,10)]=s[t]}return i}clone(t){throw new Error("Use FragmentsGroup.cloneGroup instead!")}cloneGroup(t){const s=new e;s.coordinationMatrix=this.coordinationMatrix,s.position.copy(this.position),s.rotation.copy(this.rotation),s.scale.copy(this.scale),s.updateMatrix(),s.ifcMetadata={...this.ifcMetadata},t||(t=this.getFragmentMap(this.data.keys()));const i=new Set,r=new Map;for(const e of this.items){if(!t[e.id])continue;const n=t[e.id],o=e.clone(n);r.set(e.id,o.id),s.items.push(o),s.add(o.mesh);for(const t of n)i.add(t)}for(const t of i){const e=this.data.get(t);e&&s.data.set(t,e)}for(const[t,e]of this.keyFragments)if(r.has(e)){const i=r.get(e);if(void 0===i)throw new Error("Malformed fragment ID map during clone!");s.keyFragments.set(t,i)}for(const[t,e]of this.globalToExpressIDs)i.has(e)&&s.globalToExpressIDs.set(t,e);return this.civilData&&(s.civilData={coordinationMatrix:this.coordinationMatrix,alignments:new Map}),s}getPropsURL(t){const{ids:e}=this.streamSettings,s=e.get(t);if(void 0===s)throw new Error("ID not found");return this.constructFileName(s)}async getPropertiesData(t){var s;let i;if((null==(s=this.streamSettings.baseUrl)?void 0:s.length)&&(console.warn("streamSettings.baseUrl is deprecated. Use FragmentsGroup.url instead."),e.url=this.streamSettings.baseUrl),e.useCache){let s=null;if(e.propertiesDB&&(s=await e.propertiesDB.get(t)),s)i=await s.text();else{const s=await e.fetch(t);if(i=await s.text(),e.propertiesDB){const s=(new TextEncoder).encode(i);await e.propertiesDB.add(t,s)}}}else{const s=await e.fetch(t);i=await s.text()}return JSON.parse(i)}constructFileName(t){if(e.constructFileName)return e.constructFileName(t);const{baseFileName:s}=this.streamSettings;return`${s}-${t}`}disposeAlignment(t){for(const e of t)if(e.mesh.geometry.dispose(),Array.isArray(e.mesh.material))for(const t of e.mesh.material)t.dispose();else e.mesh.material.dispose();t.length=0}};S(Dc,"fetch",(async t=>fetch(`${Dc.url}${t}`))),S(Dc,"constructFileName",null),S(Dc,"url",""),S(Dc,"useCache",!0),S(Dc,"propertiesDB",null);let Vc=Dc;class Bc{constructor(){S(this,"vertical",[]),S(this,"horizontal",[]),S(this,"absolute",[]),S(this,"initialKP",0)}getLength(t){let e=0;for(const s of this[t])e+=s.getLength();return e}getPointAt(t,e){const s=this.getCurveAt(t,e);return s.curve.getPointAt(s.percentage)}getPercentageAt(t,e,s=.01){const i=this[e];let r=0;for(const n of i){const i=n.getPercentageAt(t,s),o=n.getLength();if(null!==i){return(r+i*o)/this.getLength(e)}r+=o}return null}getCurveAt(t,e){t<0?t=0:t>1&&(t=1);const s=this[e],i=this.getLength(e)*t;let r=0;for(const t of s){const e=t.getLength();if(r+e>=i){return{curve:t,percentage:(i-r)/e}}r+=e}throw new Error("Could not compute point!")}}class Gc{constructor(t,e,s,i){S(this,"index"),S(this,"mesh"),S(this,"data"),S(this,"alignment"),this.index=t,this.mesh=e,this.data=s,this.alignment=i}get _index(){return this.mesh.geometry.index}get _pos(){return this.mesh.geometry.attributes.position.array}getLength(){let t=0;for(let e=0;e<this._index.array.length-1;e+=2){const{startPoint:s,endPoint:i}=this.getSegment(e);t+=s.distanceTo(i)}return t}getPointAt(t){const{startPoint:e,endPoint:s,distanceToStart:i}=this.getSegmentAt(t),r=s.clone();return r.sub(e),r.normalize(),r.multiplyScalar(i),r.add(e),r}getSegmentAt(t){t<0?t=0:t>1&&(t=1);const e=this.getLength()*t;let s=0;for(let t=0;t<this._index.array.length-1;t+=2){const{startPoint:i,endPoint:r}=this.getSegment(t),n=i.distanceTo(r);if(s+n>=e){return{distanceToStart:e-s,index:t,startPoint:i,endPoint:r}}s+=n}throw new Error("Could not compute point")}getPercentageAt(t,e=.01){let s=0;for(let i=0;i<this._index.array.length-1;i+=2){const{startPoint:r,endPoint:n}=this.getSegment(i),o=r.distanceTo(n),a=t.distanceTo(r);if(a+t.distanceTo(n)-o<=e){return(s+a)/this.getLength()}s+=o}return null}getSegment(e){const s=3*this._index.array[e],i=3*this._index.array[e+1];return{startPoint:new t.Vector3(this._pos[s],this._pos[s+1],this._pos[s+2]),endPoint:new t.Vector3(this._pos[i],this._pos[i+1],this._pos[i+2])}}}class zc extends t.LineSegments{constructor(t,e,s,i,r){super(i,r),S(this,"curve"),this.curve=new Gc(t,this,e,s)}}class Yc{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsStreamedGeometry(t,e){return(e||new Yc).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsStreamedGeometry(t,e){return t.setPosition(t.position()+4),(e||new Yc).__init(t.readInt32(t.position())+t.position(),t)}geometryId(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):0}position(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}positionLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}normalLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}indexLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startStreamedGeometry(t){t.startObject(4)}static addGeometryId(t,e){t.addFieldInt32(0,e,0)}static addPosition(t,e){t.addFieldOffset(1,e,0)}static createPositionVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPositionVector(t,e){t.startVector(4,e,4)}static addNormal(t,e){t.addFieldOffset(2,e,0)}static createNormalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startNormalVector(t,e){t.startVector(4,e,4)}static addIndex(t,e){t.addFieldOffset(3,e,0)}static createIndexVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndexVector(t,e){t.startVector(4,e,4)}static endStreamedGeometry(t){return t.endObject()}static createStreamedGeometry(t,e,s,i,r){return Yc.startStreamedGeometry(t),Yc.addGeometryId(t,e),Yc.addPosition(t,s),Yc.addNormal(t,i),Yc.addIndex(t,r),Yc.endStreamedGeometry(t)}}class kc{constructor(){S(this,"bb",null),S(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsStreamedGeometries(t,e){return(e||new kc).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsStreamedGeometries(t,e){return t.setPosition(t.position()+4),(e||new kc).__init(t.readInt32(t.position())+t.position(),t)}geometries(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new Yc).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}geometriesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startStreamedGeometries(t){t.startObject(1)}static addGeometries(t,e){t.addFieldOffset(0,e,0)}static createGeometriesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startGeometriesVector(t,e){t.startVector(4,e,4)}static endStreamedGeometries(t){return t.endObject()}static finishStreamedGeometriesBuffer(t,e){t.finish(e)}static finishSizePrefixedStreamedGeometriesBuffer(t,e){t.finish(e,void 0,!0)}static createStreamedGeometries(t,e){return kc.startStreamedGeometries(t),kc.addGeometries(t,e),kc.endStreamedGeometries(t)}}class Hc{import(t){const e=new Y(t),s=kc.getRootAsStreamedGeometries(e),i=new Map,r=s.geometriesLength();for(let t=0;t<r;t++){const e=s.geometries(t);if(!e)continue;const r=e.geometryId();if(null===r)throw new Error("Error finding ID!");const n=e.positionArray(),o=e.normalArray(),a=e.indexArray();n&&o&&a&&i.set(r,{position:n,normal:o,index:a})}return i}export(t){const e=new k(1024),s=[],i=kc,r=Yc;for(const[i,{index:n,position:o,normal:a}]of t){const t=r.createIndexVector(e,n),c=r.createPositionVector(e,o),h=r.createNormalVector(e,a);r.startStreamedGeometry(e),r.addGeometryId(e,i),r.addIndex(e,t),r.addPosition(e,c),r.addNormal(e,h);const l=r.endStreamedGeometry(e);s.push(l)}const n=i.createGeometriesVector(e,s);i.startStreamedGeometries(e),i.addGeometries(e,n);const o=i.endStreamedGeometries(e);return e.finish(o),e.asUint8Array()}}class Wc{static combine(t){if(0===t.length)return{};if(1===t.length)return t[0];const e={};for(const s of t)for(const t in s){e[t]||(e[t]=new Set);for(const i of s[t])e[t].add(i)}return e}static intersect(t){if(0===t.length)return{};if(1===t.length)return t[0];const e=new Map;let s=0;for(const i of t){s++;for(const t in i){e.has(t)||e.set(t,{count:0,ids:new Map});const s=e.get(t);s.count++;for(const e of i[t]){const t=s.ids.get(e)||0;s.ids.set(e,t+1)}}}const i={};for(const[t,{count:r,ids:n}]of e)if(r===s)for(const[e,r]of n)r===s&&(i[t]||(i[t]=new Set),i[t].add(e));return i}static copy(t){const e={};for(const s in t)e[s]=new Set(t[s]);return e}static export(t){const e={};for(const s in t)e[s]=Array.from(t[s]);return e}static import(t){const e={};for(const s in t)e[s]=new Set(t[s]);return e}}export{H as Alignment,Bc as AlignmentObject,x as AsyncEvent,W as Attribute,K as Axis,$ as AxisPartClass,Q as BoundingBox,q as CircleCurve,J as CircleExtrusion,Gc as CivilCurve,Tt as CurrentLod,zc as CurveMesh,P as DataMap,M as DataSet,tt as DoubleVector,v as Event,j as FloatVector,Tc as Fragment,qn as FragmentMesh,Wc as FragmentUtils,Vc as FragmentsGroup,is as FragmentsModel,bs as FragmentsModels,rt as Geometries,nt as GeometryClass,et as GeometryLines,st as GeometrySample,jn as IfcImporter,Ft as ItemConfigClass,ot as Material,bt as Meshes,It as Model,At as MultiThreadingRequestClass,Ct as ObjectClass,ut as Relation,_t as RenderedFaces,at as Representation,pt as RepresentationClass,ct as Sample,Mc as Serializer,dt as Shell,ht as ShellHole,lt as ShellProfile,Rt as SnappingClass,ft as SpatialStructure,Hc as StreamSerializer,Uc as StreamerFileDb,Et as Stroke,gt as TileRequestClass,it as Transform,X as Wire,Z as WireSet,N as getObject,L as ifcCategoryMap,Wn as ifcClasses,mt as limitOf2Bytes};export default null;
//# sourceMappingURL=/sm/86291ac4f7a12ab3df3e326efc5d9621ed1f0e194f25428ec457caad1bbbe2b6.map
